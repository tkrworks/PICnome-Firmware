CCS PCH C Compiler, Version 4.089, 47658               14-9-10 09:11

               Filename: X:\PICnome-firmware\picnome.lst

               ROM used: 11378 bytes (35%)
                         Largest free fragment is 15242
               RAM used: 1657 (81%) at main() level
                         1709 (83%) worst case
               Stack:    13 worst case (6 in main + 7 for interrupts)

*
1800:  GOTO   42EC
*
1808:  MOVWF  05
180A:  MOVFF  FD8,06
180E:  MOVFF  FE0,07
1812:  MOVLB  0
1814:  MOVFF  FE9,0D
1818:  MOVFF  FEA,08
181C:  MOVFF  FE1,09
1820:  MOVFF  FE2,0A
1824:  MOVFF  FD9,0B
1828:  MOVFF  FDA,0C
182C:  MOVFF  FF3,14
1830:  MOVFF  FF4,15
1834:  MOVFF  FFA,16
1838:  MOVFF  00,0F
183C:  MOVFF  01,10
1840:  MOVFF  02,11
1844:  MOVFF  03,12
1848:  MOVFF  04,13
184C:  BTFSS  FA0.5
184E:  GOTO   1858
1852:  BTFSC  FA1.5
1854:  GOTO   26C0
1858:  MOVFF  0F,00
185C:  MOVFF  10,01
1860:  MOVFF  11,02
1864:  MOVFF  12,03
1868:  MOVFF  13,04
186C:  MOVFF  0D,FE9
1870:  MOVFF  08,FEA
1874:  BSF    08.7
1876:  MOVFF  09,FE1
187A:  MOVFF  0A,FE2
187E:  MOVFF  0B,FD9
1882:  MOVFF  0C,FDA
1886:  MOVFF  14,FF3
188A:  MOVFF  15,FF4
188E:  MOVFF  16,FFA
1892:  MOVF   05,W
1894:  MOVFF  07,FE0
1898:  MOVFF  06,FD8
189C:  RETFIE 0
.................... /* 
....................  * Copyright (C) 2006, Brian Crabtree and Joe Lake, monome.org 
....................  * 
....................  * This file is used the copied code from monome/40h/40h.c. 
....................  * 
....................  * Copylight (C) 2009, Shunichi Yamamoto, tkrworks.net 
....................  * 
....................  * This file is part of PICnome. 
....................  * 
....................  * PICnome is free software: you can redistribute it and/or modify 
....................  * it under the terms of the GNU General Public License as published by 
....................  * the Free Software Foundation, either version 3 of the License, or 
....................  * (at your option ) any later version. 
....................  * 
....................  * PICnome is distributed in the hope that it will be useful, 
....................  * but WITHIOUT ANY WARRANTY; without even the implied warranty of 
....................  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.   See the 
....................  * GNU General Public License for more details. 
....................  * 
....................  * You should have received a copy of the GNU General Public License 
....................  * along with PICnome. if not, see <http:/www.gnu.org/licenses/>. 
....................  * 
....................  * picnome.c,v.1.0.24 2010/09/14 
....................  */ 
....................  
.................... #include "picnome.h" 
.................... /* 
....................  * Copylight (C) 2009, Shunichi Yamamoto, tkrworks.net 
....................  * 
....................  * This file is part of PICnome. 
....................  * 
....................  * PICnome is free software: you can redistribute it and/or modify 
....................  * it under the terms of the GNU General Public License as published by 
....................  * the Free Software Foundation, either version 3 of the License, or 
....................  * (at your option ) any later version. 
....................  * 
....................  * PICnome is distributed in the hope that it will be useful, 
....................  * but WITHIOUT ANY WARRANTY; without even the implied warranty of 
....................  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.   See the 
....................  * GNU General Public License for more details. 
....................  * 
....................  * You should have received a copy of the GNU General Public License 
....................  * along with PICnome. if not, see <http:/www.gnu.org/licenses/>. 
....................  * 
....................  * picnome.h,v.1.0.24 2010/09/14 
....................  */ 
....................  
.................... #define ONE_TWENTY_EIGHT 
....................  
.................... #include <18F2550.h> 
.................... //////// Standard Header file for the PIC18F2550 device //////////////// 
.................... #device PIC18F2550 
.................... #list 
....................  
.................... #device adc=10 
....................  
.................... #FUSES NOWDT                    //No Watch Dog Timer 
.................... #FUSES WDT128                   //Watch Dog Timer uses 1:128 Postscale 
.................... #FUSES HSPLL                    //High Speed Crystal/Resonator with PLL enabled 
.................... #FUSES NOPROTECT                //Code not protected from reading 
.................... #FUSES NOBROWNOUT               //No brownout reset 
.................... #FUSES BORV20                   //Brownout reset at 2.0V 
.................... #FUSES NOPUT                    //No Power Up Timer 
.................... #FUSES NOCPD                    //No EE protection 
.................... #FUSES NOSTVREN                 //Stack full/underflow will not cause reset 
.................... #FUSES NODEBUG                  //No Debug mode for ICD 
.................... #FUSES NOLVP                    //No low voltage prgming, B3(PIC16) or B5(PIC18) used for I/O 
.................... #FUSES NOWRT                    //Program memory not write protected 
.................... #FUSES NOWRTD                   //Data EEPROM not write protected 
.................... #FUSES NOIESO                   //Internal External Switch Over mode disabled 
.................... #FUSES NOFCMEN                  //Fail-safe clock monitor disabled 
.................... #FUSES NOPBADEN                 //PORTB pins are configured as digital I/O on RESET 
.................... #FUSES NOWRTC                   //configuration not registers write protected 
.................... #FUSES NOWRTB                   //Boot block not write protected 
.................... #FUSES NOEBTR                   //Memory not protected from table reads 
.................... #FUSES NOEBTRB                  //Boot block not protected from table reads 
.................... #FUSES NOCPB                    //No Boot Block code protection 
.................... #FUSES LPT1OSC                  //Timer1 configured for low-power operation 
.................... #FUSES NOMCLR                   //Master Clear pin used for I/O 
.................... #FUSES NOXINST                  //Extended set extension and Indexed Addressing mode disabled (Legacy mode) 
.................... #FUSES PLL5                     //Divide By 5(20MHz oscillator input) 
.................... #FUSES USBDIV                   //USB clock source comes from PLL divide by 2 
.................... #FUSES CPUDIV1                  //No System Clock Postscaler 
.................... #FUSES VREGEN                   //USB voltage regulator enabled 
....................  
.................... #USE DELAY(CLOCK=48MHZ, CRYSTAL=20MHZ) 
*
28CA:  MOVLW  02
28CC:  MOVWF  FEA
28CE:  MOVLW  77
28D0:  MOVWF  FE9
28D2:  MOVF   FEF,W
28D4:  BZ    28F2
28D6:  MOVLW  0F
28D8:  MOVWF  01
28DA:  CLRF   00
28DC:  DECFSZ 00,F
28DE:  BRA    28DC
28E0:  DECFSZ 01,F
28E2:  BRA    28DA
28E4:  MOVLW  8F
28E6:  MOVWF  00
28E8:  DECFSZ 00,F
28EA:  BRA    28E8
28EC:  NOP   
28EE:  DECFSZ FEF,F
28F0:  BRA    28D6
28F2:  RETLW  00
....................  
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #define size_t unsigned int8 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #define size_t unsigned int8 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #define size_t unsigned int8 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
*
2D48:  MOVFF  28D,291
2D4C:  MOVFF  28C,290
2D50:  MOVFF  291,03
2D54:  MOVLB  2
2D56:  MOVFF  290,FE9
2D5A:  MOVFF  291,FEA
2D5E:  MOVF   FEF,F
2D60:  BZ    2DB6
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
2D62:  MOVFF  28F,293
2D66:  MOVFF  28E,292
2D6A:  MOVFF  293,03
2D6E:  MOVFF  292,FE9
2D72:  MOVFF  293,FEA
2D76:  MOVF   FEF,F
2D78:  BZ    2DAA
....................          if (*sc1 == *sc2) 
2D7A:  MOVFF  290,FE9
2D7E:  MOVFF  291,FEA
2D82:  MOVFF  FEF,294
2D86:  MOVFF  293,03
2D8A:  MOVFF  292,FE9
2D8E:  MOVFF  293,FEA
2D92:  MOVF   FEF,W
2D94:  SUBWF  x94,W
2D96:  BNZ   2DA2
....................             return(sc1); 
2D98:  MOVFF  290,01
2D9C:  MOVFF  291,02
2DA0:  BRA    2DBC
2DA2:  INCF   x92,F
2DA4:  BTFSC  FD8.2
2DA6:  INCF   x93,F
2DA8:  BRA    2D6A
2DAA:  INCF   x90,F
2DAC:  BTFSC  FD8.2
2DAE:  INCF   x91,F
2DB0:  MOVLB  0
2DB2:  BRA    2D50
2DB4:  MOVLB  2
....................    return(0); 
2DB6:  MOVLW  00
2DB8:  MOVWF  01
2DBA:  MOVWF  02
.................... } 
2DBC:  MOVLB  0
2DBE:  GOTO   2E34 (RETURN)
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
*
2CB8:  MOVFF  28D,291
2CBC:  MOVFF  28C,290
2CC0:  MOVFF  291,03
2CC4:  MOVLB  2
2CC6:  MOVFF  290,FE9
2CCA:  MOVFF  291,FEA
2CCE:  MOVF   FEF,F
2CD0:  BZ    2D32
....................       for (sc2 = s2; ; sc2++) 
2CD2:  MOVFF  28F,293
2CD6:  MOVFF  28E,292
....................     if (*sc2 == '\0') 
2CDA:  MOVFF  293,03
2CDE:  MOVFF  292,FE9
2CE2:  MOVFF  293,FEA
2CE6:  MOVF   FEF,F
2CE8:  BNZ   2CFE
....................        return(sc1 - s1); 
2CEA:  MOVF   x8C,W
2CEC:  SUBWF  x90,W
2CEE:  MOVWF  00
2CF0:  MOVF   x8D,W
2CF2:  SUBWFB x91,W
2CF4:  MOVWF  03
2CF6:  MOVFF  00,01
2CFA:  BRA    2D42
....................          else if (*sc1 == *sc2) 
2CFC:  BRA    2D1E
2CFE:  MOVFF  290,FE9
2D02:  MOVFF  291,FEA
2D06:  MOVFF  FEF,294
2D0A:  MOVFF  293,03
2D0E:  MOVFF  292,FE9
2D12:  MOVFF  293,FEA
2D16:  MOVF   FEF,W
2D18:  SUBWF  x94,W
2D1A:  BNZ   2D1E
....................             break; 
2D1C:  BRA    2D26
2D1E:  INCF   x92,F
2D20:  BTFSC  FD8.2
2D22:  INCF   x93,F
2D24:  BRA    2CDA
2D26:  INCF   x90,F
2D28:  BTFSC  FD8.2
2D2A:  INCF   x91,F
2D2C:  MOVLB  0
2D2E:  BRA    2CC0
2D30:  MOVLB  2
....................    return(sc1 - s1); 
2D32:  MOVF   x8C,W
2D34:  SUBWF  x90,W
2D36:  MOVWF  00
2D38:  MOVF   x8D,W
2D3A:  SUBWFB x91,W
2D3C:  MOVWF  03
2D3E:  MOVFF  00,01
.................... } 
2D42:  MOVLB  0
2D44:  GOTO   2DF2 (RETURN)
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
*
2DC2:  MOVLB  2
2DC4:  MOVF   x84,W
2DC6:  IORWF  x85,W
2DC8:  BZ    2DD2
2DCA:  MOVFF  285,03
2DCE:  MOVF   x84,W
2DD0:  BRA    2DD8
2DD2:  MOVFF  1A,03
2DD6:  MOVF   19,W
2DD8:  MOVWF  x88
2DDA:  MOVFF  03,289
....................    beg += strspn(beg, s2); 
2DDE:  MOVFF  289,28D
2DE2:  MOVFF  288,28C
2DE6:  MOVFF  287,28F
2DEA:  MOVFF  286,28E
2DEE:  MOVLB  0
2DF0:  BRA    2CB8
2DF2:  MOVF   01,W
2DF4:  MOVLB  2
2DF6:  ADDWF  x88,F
2DF8:  MOVLW  00
2DFA:  ADDWFC x89,F
....................    if (*beg == '\0') 
2DFC:  MOVFF  289,03
2E00:  MOVFF  288,FE9
2E04:  MOVFF  289,FEA
2E08:  MOVF   FEF,F
2E0A:  BNZ   2E20
....................    { 
....................       *save = ' '; 
2E0C:  MOVFF  19,FE9
2E10:  MOVFF  1A,FEA
2E14:  MOVLW  20
2E16:  MOVWF  FEF
....................       return(0); 
2E18:  MOVLW  00
2E1A:  MOVWF  01
2E1C:  MOVWF  02
2E1E:  BRA    2E6E
....................    } 
....................    end = strpbrk(beg, s2); 
2E20:  MOVFF  289,28D
2E24:  MOVFF  288,28C
2E28:  MOVFF  287,28F
2E2C:  MOVFF  286,28E
2E30:  MOVLB  0
2E32:  BRA    2D48
2E34:  MOVFF  02,28B
2E38:  MOVFF  01,28A
....................    if (*end != '\0') 
2E3C:  MOVFF  28B,03
2E40:  MOVLB  2
2E42:  MOVFF  28A,FE9
2E46:  MOVFF  28B,FEA
2E4A:  MOVF   FEF,F
2E4C:  BZ    2E5E
....................    { 
....................       *end = '\0'; 
2E4E:  MOVFF  28A,FE9
2E52:  MOVFF  28B,FEA
2E56:  CLRF   FEF
....................       end++; 
2E58:  INCF   x8A,F
2E5A:  BTFSC  FD8.2
2E5C:  INCF   x8B,F
....................    } 
....................    save = end; 
2E5E:  MOVFF  28B,1A
2E62:  MOVFF  28A,19
....................    return(beg); 
2E66:  MOVFF  288,01
2E6A:  MOVFF  289,02
.................... } 
2E6E:  MOVLB  0
2E70:  RETLW  00
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
*
2EC2:  MOVLB  2
2EC4:  CLRF   x89
....................    sign = 0; 
2EC6:  CLRF   x87
....................    base = 10; 
2EC8:  MOVLW  0A
2ECA:  MOVWF  x88
....................    result = 0; 
2ECC:  CLRF   x86
....................  
....................    if (!s) 
2ECE:  MOVF   x84,W
2ED0:  IORWF  x85,W
2ED2:  BNZ   2EDA
....................       return 0; 
2ED4:  MOVLW  00
2ED6:  MOVWF  01
2ED8:  BRA    3060
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
2EDA:  MOVF   x89,W
2EDC:  INCF   x89,F
2EDE:  CLRF   03
2EE0:  ADDWF  x84,W
2EE2:  MOVWF  FE9
2EE4:  MOVF   x85,W
2EE6:  ADDWFC 03,W
2EE8:  MOVWF  FEA
2EEA:  MOVFF  FEF,28A
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
2EEE:  MOVF   x8A,W
2EF0:  SUBLW  2D
2EF2:  BNZ   2F0E
....................    { 
....................       sign = 1;         // Set the sign to negative 
2EF4:  MOVLW  01
2EF6:  MOVWF  x87
....................       c = s[index++]; 
2EF8:  MOVF   x89,W
2EFA:  INCF   x89,F
2EFC:  CLRF   03
2EFE:  ADDWF  x84,W
2F00:  MOVWF  FE9
2F02:  MOVF   x85,W
2F04:  ADDWFC 03,W
2F06:  MOVWF  FEA
2F08:  MOVFF  FEF,28A
....................    } 
....................    else if (c == '+') 
2F0C:  BRA    2F28
2F0E:  MOVF   x8A,W
2F10:  SUBLW  2B
2F12:  BNZ   2F28
....................    { 
....................       c = s[index++]; 
2F14:  MOVF   x89,W
2F16:  INCF   x89,F
2F18:  CLRF   03
2F1A:  ADDWF  x84,W
2F1C:  MOVWF  FE9
2F1E:  MOVF   x85,W
2F20:  ADDWFC 03,W
2F22:  MOVWF  FEA
2F24:  MOVFF  FEF,28A
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
2F28:  MOVF   x8A,W
2F2A:  SUBLW  2F
2F2C:  BTFSC  FD8.0
2F2E:  BRA    3050
2F30:  MOVF   x8A,W
2F32:  SUBLW  39
2F34:  BTFSS  FD8.0
2F36:  BRA    3050
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
2F38:  MOVF   x8A,W
2F3A:  SUBLW  30
2F3C:  BNZ   2F80
2F3E:  CLRF   03
2F40:  MOVF   x89,W
2F42:  ADDWF  x84,W
2F44:  MOVWF  FE9
2F46:  MOVF   x85,W
2F48:  ADDWFC 03,W
2F4A:  MOVWF  FEA
2F4C:  MOVF   FEF,W
2F4E:  SUBLW  78
2F50:  BZ    2F66
2F52:  CLRF   03
2F54:  MOVF   x89,W
2F56:  ADDWF  x84,W
2F58:  MOVWF  FE9
2F5A:  MOVF   x85,W
2F5C:  ADDWFC 03,W
2F5E:  MOVWF  FEA
2F60:  MOVF   FEF,W
2F62:  SUBLW  58
2F64:  BNZ   2F80
....................       { 
....................          base = 16; 
2F66:  MOVLW  10
2F68:  MOVWF  x88
....................          index++; 
2F6A:  INCF   x89,F
....................          c = s[index++]; 
2F6C:  MOVF   x89,W
2F6E:  INCF   x89,F
2F70:  CLRF   03
2F72:  ADDWF  x84,W
2F74:  MOVWF  FE9
2F76:  MOVF   x85,W
2F78:  ADDWFC 03,W
2F7A:  MOVWF  FEA
2F7C:  MOVFF  FEF,28A
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
2F80:  MOVF   x88,W
2F82:  SUBLW  0A
2F84:  BNZ   2FC0
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
2F86:  MOVF   x8A,W
2F88:  SUBLW  2F
2F8A:  BC    2FBE
2F8C:  MOVF   x8A,W
2F8E:  SUBLW  39
2F90:  BNC   2FBE
....................             result = 10*result + (c - '0'); 
2F92:  MOVLW  0A
2F94:  MOVWF  x8B
2F96:  MOVFF  286,28C
2F9A:  MOVLB  0
2F9C:  BRA    2E72
2F9E:  MOVLW  30
2FA0:  MOVLB  2
2FA2:  SUBWF  x8A,W
2FA4:  ADDWF  01,W
2FA6:  MOVWF  x86
....................             c = s[index++]; 
2FA8:  MOVF   x89,W
2FAA:  INCF   x89,F
2FAC:  CLRF   03
2FAE:  ADDWF  x84,W
2FB0:  MOVWF  FE9
2FB2:  MOVF   x85,W
2FB4:  ADDWFC 03,W
2FB6:  MOVWF  FEA
2FB8:  MOVFF  FEF,28A
....................          } 
2FBC:  BRA    2F86
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
2FBE:  BRA    3050
2FC0:  MOVF   x88,W
2FC2:  SUBLW  10
2FC4:  BNZ   3050
....................       { 
....................          c = toupper(c); 
2FC6:  MOVF   x8A,W
2FC8:  SUBLW  60
2FCA:  BC    2FD8
2FCC:  MOVF   x8A,W
2FCE:  SUBLW  7A
2FD0:  BNC   2FD8
2FD2:  MOVF   x8A,W
2FD4:  ANDLW  DF
2FD6:  BRA    2FDA
2FD8:  MOVF   x8A,W
2FDA:  MOVWF  x8A
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
2FDC:  MOVF   x8A,W
2FDE:  SUBLW  2F
2FE0:  BC    2FE8
2FE2:  MOVF   x8A,W
2FE4:  SUBLW  39
2FE6:  BC    2FF4
2FE8:  MOVF   x8A,W
2FEA:  SUBLW  40
2FEC:  BC    3050
2FEE:  MOVF   x8A,W
2FF0:  SUBLW  46
2FF2:  BNC   3050
....................             if (c >= '0' && c <= '9') 
2FF4:  MOVF   x8A,W
2FF6:  SUBLW  2F
2FF8:  BC    3012
2FFA:  MOVF   x8A,W
2FFC:  SUBLW  39
2FFE:  BNC   3012
....................                result = (result << 4) + (c - '0'); 
3000:  SWAPF  x86,W
3002:  MOVWF  x8B
3004:  MOVLW  F0
3006:  ANDWF  x8B,F
3008:  MOVLW  30
300A:  SUBWF  x8A,W
300C:  ADDWF  x8B,W
300E:  MOVWF  x86
....................             else 
3010:  BRA    3024
....................                result = (result << 4) + (c - 'A' + 10); 
3012:  SWAPF  x86,W
3014:  MOVWF  x8B
3016:  MOVLW  F0
3018:  ANDWF  x8B,F
301A:  MOVLW  41
301C:  SUBWF  x8A,W
301E:  ADDLW  0A
3020:  ADDWF  x8B,W
3022:  MOVWF  x86
....................  
....................             c = s[index++]; 
3024:  MOVF   x89,W
3026:  INCF   x89,F
3028:  CLRF   03
302A:  ADDWF  x84,W
302C:  MOVWF  FE9
302E:  MOVF   x85,W
3030:  ADDWFC 03,W
3032:  MOVWF  FEA
3034:  MOVFF  FEF,28A
....................             c = toupper(c); 
3038:  MOVF   x8A,W
303A:  SUBLW  60
303C:  BC    304A
303E:  MOVF   x8A,W
3040:  SUBLW  7A
3042:  BNC   304A
3044:  MOVF   x8A,W
3046:  ANDLW  DF
3048:  BRA    304C
304A:  MOVF   x8A,W
304C:  MOVWF  x8A
....................          } 
304E:  BRA    2FDC
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
3050:  DECFSZ x87,W
3052:  BRA    305C
3054:  MOVF   x88,W
3056:  SUBLW  0A
3058:  BNZ   305C
....................        result = -result; 
305A:  NEGF   x86
....................  
....................    return(result); 
305C:  MOVFF  286,01
.................... } 
3060:  MOVLB  0
3062:  RETLW  00
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
*
3088:  MOVLB  2
308A:  CLRF   x8A
....................    sign = 0; 
308C:  CLRF   x88
....................    base = 10; 
308E:  MOVLW  0A
3090:  MOVWF  x89
....................    result = 0; 
3092:  CLRF   x87
3094:  CLRF   x86
....................  
....................    if (!s) 
3096:  MOVF   x84,W
3098:  IORWF  x85,W
309A:  BNZ   30A4
....................       return 0; 
309C:  MOVLW  00
309E:  MOVWF  01
30A0:  MOVWF  02
30A2:  BRA    3274
....................    c = s[index++]; 
30A4:  MOVF   x8A,W
30A6:  INCF   x8A,F
30A8:  CLRF   03
30AA:  ADDWF  x84,W
30AC:  MOVWF  FE9
30AE:  MOVF   x85,W
30B0:  ADDWFC 03,W
30B2:  MOVWF  FEA
30B4:  MOVFF  FEF,28B
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
30B8:  MOVF   x8B,W
30BA:  SUBLW  2D
30BC:  BNZ   30D8
....................    { 
....................       sign = 1;         // Set the sign to negative 
30BE:  MOVLW  01
30C0:  MOVWF  x88
....................       c = s[index++]; 
30C2:  MOVF   x8A,W
30C4:  INCF   x8A,F
30C6:  CLRF   03
30C8:  ADDWF  x84,W
30CA:  MOVWF  FE9
30CC:  MOVF   x85,W
30CE:  ADDWFC 03,W
30D0:  MOVWF  FEA
30D2:  MOVFF  FEF,28B
....................    } 
....................    else if (c == '+') 
30D6:  BRA    30F2
30D8:  MOVF   x8B,W
30DA:  SUBLW  2B
30DC:  BNZ   30F2
....................    { 
....................       c = s[index++]; 
30DE:  MOVF   x8A,W
30E0:  INCF   x8A,F
30E2:  CLRF   03
30E4:  ADDWF  x84,W
30E6:  MOVWF  FE9
30E8:  MOVF   x85,W
30EA:  ADDWFC 03,W
30EC:  MOVWF  FEA
30EE:  MOVFF  FEF,28B
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
30F2:  MOVF   x8B,W
30F4:  SUBLW  2F
30F6:  BTFSC  FD8.0
30F8:  BRA    3258
30FA:  MOVF   x8B,W
30FC:  SUBLW  39
30FE:  BTFSS  FD8.0
3100:  BRA    3258
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
3102:  MOVF   x8B,W
3104:  SUBLW  30
3106:  BNZ   314A
3108:  CLRF   03
310A:  MOVF   x8A,W
310C:  ADDWF  x84,W
310E:  MOVWF  FE9
3110:  MOVF   x85,W
3112:  ADDWFC 03,W
3114:  MOVWF  FEA
3116:  MOVF   FEF,W
3118:  SUBLW  78
311A:  BZ    3130
311C:  CLRF   03
311E:  MOVF   x8A,W
3120:  ADDWF  x84,W
3122:  MOVWF  FE9
3124:  MOVF   x85,W
3126:  ADDWFC 03,W
3128:  MOVWF  FEA
312A:  MOVF   FEF,W
312C:  SUBLW  58
312E:  BNZ   314A
....................       { 
....................          base = 16; 
3130:  MOVLW  10
3132:  MOVWF  x89
....................          index++; 
3134:  INCF   x8A,F
....................          c = s[index++]; 
3136:  MOVF   x8A,W
3138:  INCF   x8A,F
313A:  CLRF   03
313C:  ADDWF  x84,W
313E:  MOVWF  FE9
3140:  MOVF   x85,W
3142:  ADDWFC 03,W
3144:  MOVWF  FEA
3146:  MOVFF  FEF,28B
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
314A:  MOVF   x89,W
314C:  SUBLW  0A
314E:  BNZ   3196
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
3150:  MOVF   x8B,W
3152:  SUBLW  2F
3154:  BC    3194
3156:  MOVF   x8B,W
3158:  SUBLW  39
315A:  BNC   3194
....................             result = 10*result + (c - '0'); 
315C:  CLRF   x8D
315E:  MOVLW  0A
3160:  MOVWF  x8C
3162:  MOVFF  287,28F
3166:  MOVFF  286,28E
316A:  MOVLB  0
316C:  BRA    3064
316E:  MOVLW  30
3170:  MOVLB  2
3172:  SUBWF  x8B,W
3174:  ADDWF  01,W
3176:  MOVWF  x86
3178:  MOVLW  00
317A:  ADDWFC 02,W
317C:  MOVWF  x87
....................             c = s[index++]; 
317E:  MOVF   x8A,W
3180:  INCF   x8A,F
3182:  CLRF   03
3184:  ADDWF  x84,W
3186:  MOVWF  FE9
3188:  MOVF   x85,W
318A:  ADDWFC 03,W
318C:  MOVWF  FEA
318E:  MOVFF  FEF,28B
....................          } 
3192:  BRA    3150
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
3194:  BRA    3258
3196:  MOVF   x89,W
3198:  SUBLW  10
319A:  BNZ   3258
....................       { 
....................          c = toupper(c); 
319C:  MOVF   x8B,W
319E:  SUBLW  60
31A0:  BC    31AE
31A2:  MOVF   x8B,W
31A4:  SUBLW  7A
31A6:  BNC   31AE
31A8:  MOVF   x8B,W
31AA:  ANDLW  DF
31AC:  BRA    31B0
31AE:  MOVF   x8B,W
31B0:  MOVWF  x8B
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
31B2:  MOVF   x8B,W
31B4:  SUBLW  2F
31B6:  BC    31BE
31B8:  MOVF   x8B,W
31BA:  SUBLW  39
31BC:  BC    31CA
31BE:  MOVF   x8B,W
31C0:  SUBLW  40
31C2:  BC    3258
31C4:  MOVF   x8B,W
31C6:  SUBLW  46
31C8:  BNC   3258
....................             if (c >= '0' && c <= '9') 
31CA:  MOVF   x8B,W
31CC:  SUBLW  2F
31CE:  BC    3202
31D0:  MOVF   x8B,W
31D2:  SUBLW  39
31D4:  BNC   3202
....................                result = (result << 4) + (c - '0'); 
31D6:  RLCF   x86,W
31D8:  MOVWF  x8C
31DA:  RLCF   x87,W
31DC:  MOVWF  x8D
31DE:  RLCF   x8C,F
31E0:  RLCF   x8D,F
31E2:  RLCF   x8C,F
31E4:  RLCF   x8D,F
31E6:  RLCF   x8C,F
31E8:  RLCF   x8D,F
31EA:  MOVLW  F0
31EC:  ANDWF  x8C,F
31EE:  MOVLW  30
31F0:  SUBWF  x8B,W
31F2:  ADDWF  x8C,W
31F4:  MOVWF  01
31F6:  MOVLW  00
31F8:  ADDWFC x8D,W
31FA:  MOVFF  01,286
31FE:  MOVWF  x87
....................             else 
3200:  BRA    322E
....................                result = (result << 4) + (c - 'A' + 10); 
3202:  RLCF   x86,W
3204:  MOVWF  x8C
3206:  RLCF   x87,W
3208:  MOVWF  x8D
320A:  RLCF   x8C,F
320C:  RLCF   x8D,F
320E:  RLCF   x8C,F
3210:  RLCF   x8D,F
3212:  RLCF   x8C,F
3214:  RLCF   x8D,F
3216:  MOVLW  F0
3218:  ANDWF  x8C,F
321A:  MOVLW  41
321C:  SUBWF  x8B,W
321E:  ADDLW  0A
3220:  ADDWF  x8C,W
3222:  MOVWF  01
3224:  MOVLW  00
3226:  ADDWFC x8D,W
3228:  MOVFF  01,286
322C:  MOVWF  x87
....................  
....................             c = s[index++];c = toupper(c); 
322E:  MOVF   x8A,W
3230:  INCF   x8A,F
3232:  CLRF   03
3234:  ADDWF  x84,W
3236:  MOVWF  FE9
3238:  MOVF   x85,W
323A:  ADDWFC 03,W
323C:  MOVWF  FEA
323E:  MOVF   FEF,W
3240:  MOVWF  x8B
3242:  SUBLW  60
3244:  BC    3252
3246:  MOVF   x8B,W
3248:  SUBLW  7A
324A:  BNC   3252
324C:  MOVF   x8B,W
324E:  ANDLW  DF
3250:  BRA    3254
3252:  MOVF   x8B,W
3254:  MOVWF  x8B
....................          } 
3256:  BRA    31B2
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
3258:  MOVF   x89,W
325A:  SUBLW  0A
325C:  BNZ   326C
325E:  DECFSZ x88,W
3260:  BRA    326C
....................       result = -result; 
3262:  COMF   x86,F
3264:  COMF   x87,F
3266:  INCF   x86,F
3268:  BTFSC  FD8.2
326A:  INCF   x87,F
....................  
....................    return(result); 
326C:  MOVFF  286,01
3270:  MOVFF  287,02
.................... } 
3274:  MOVLB  0
3276:  GOTO   3794 (RETURN)
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = TRUE, sign = FALSE, point = FALSE; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = FALSE; 
....................          if (c == '+') 
....................          { 
....................             sign = FALSE; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = TRUE; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = TRUE; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((long *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((long *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = TRUE, sign = FALSE, point = FALSE; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = FALSE; 
....................          if (c == '+') 
....................          { 
....................             sign = FALSE; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = TRUE; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = TRUE; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((long *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((long *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = TRUE, sign = FALSE, point = FALSE; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = FALSE; 
....................          if (c == '+') 
....................          { 
....................             sign = FALSE; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = TRUE; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = TRUE; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((long *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((long *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((long *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((long *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((long *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((long *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    BYTE t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=TRUE; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = FALSE; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #include <usb_bootloader.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                     USB_BOOTLOADER.H                              //// 
.................... ////                                                                   //// 
.................... ////  This include file must be included by any application loaded     //// 
.................... ////  by the example USB bootloader (ex_usb_bootloader                 //// 
.................... ////                                                                   //// 
.................... ////  The directives in this file relocate the reset and interrupt     //// 
.................... ////  vectors as well as reserving space for the bootloader.           //// 
.................... ////                                                                   //// 
.................... ////  For more documentation see ex_usb_bootloader.c                   //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS    //// 
.................... //// C compiler.  This source code may only be distributed to other    //// 
.................... //// licensed users of the CCS C compiler.  No other use,              //// 
.................... //// reproduction or distribution is permitted without written         //// 
.................... //// permission.  Derivative programs created using this software      //// 
.................... //// in object code form are not restricted in any way.                //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... //how big is the bootloader? 
.................... //the bootloader will reside from address 0x0000 to this location.  the 
.................... //application will then sit at this location+1 to the end of program memory. 
.................... #define LOADER_SIZE        (0x17FF) 
....................  
.................... //the loader and application need a common flag that determines if we are in 
.................... //the bootloader or application, that way the ISR knows where to go.  this 
.................... //is the location in ram that is reserved for this flag. 
.................... #define LOC_IN_LOADER_FLAG  0x25 
....................  
.................... //// --- end configuration --- //////////////////////////////////////////// 
....................  
.................... #reserve LOC_IN_LOADER_FLAG 
....................  
.................... int8 g_InBootloader; 
.................... #locate g_InBootloader=LOC_IN_LOADER_FLAG 
....................  
.................... #define LOADER_START       (0) 
.................... #define LOADER_END         (LOADER_SIZE) 
.................... #define APPLICATION_START  (LOADER_SIZE+1) 
.................... #define APPLICATION_END    (getenv("PROGRAM_MEMORY")-1) 
.................... #define APPLICATION_ISR    (APPLICATION_START+8) 
....................  
.................... #ifdef _bootloader 
....................  /* 
....................   Provide an empty application, so if you load this .HEX file into the pic 
....................   without an application this will prevent the pic from executing unknown code. 
....................  */ 
....................  #org APPLICATION_START,APPLICATION_START+0xF 
....................  void BlankApplication(void)  
....................  { 
....................    while(TRUE); 
....................  } 
....................  
....................  //we need to prevent the loader from using application space 
....................  #if APPLICATION_END>0xFFFF 
....................    #org APPLICATION_START+0x10, 0xFFFF {} 
....................    #if APPLICATION_END>0x1FFFF 
....................       #org 0xFFFF, 0x1FFFF {} 
....................    #else 
....................       #org 0xFFFF, APPLICATION_END {} 
....................    #endif 
....................  #else 
....................    #org APPLICATION_START+0x10, APPLICATION_END {} 
....................  #endif 
.................... #endif 
....................  
.................... #ifndef _bootloader 
....................  //in the application, this moves the reset and isr vector out of the bootload 
....................  //space.  it then reserves the loader space from being used by the application. 
....................  #build(reset=APPLICATION_START, interrupt=APPLICATION_ISR) 
....................  #org 0, LOADER_END {} 
.................... #endif 
....................  
.................... #include "usb_cdc.h" 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                                                                 //// 
.................... ////                            usb_cdc.h                            //// 
.................... ////                                                                 //// 
.................... //// Library for adding a virtual COM port on your PC over USB using //// 
.................... //// the standard Communication Device Class (CDC) specification.    //// 
.................... //// Including this file in your code will add all USB code,         //// 
.................... //// interrupts, descriptors and handlers required.  No other        //// 
.................... //// modifications need to be made.                                  //// 
.................... ////                                                                 //// 
.................... //// This library creates a virtual RS232 link between the PC and    //// 
.................... //// the PIC, therefore the library provided will be familiar to     //// 
.................... //// anyone with standard UART stream I/O:                           //// 
.................... ////                                                                 //// 
.................... //// usb_cdc_kbhit() - Returns TRUE if there is one or more          //// 
.................... ////      character received and waiting in the receive buffer.      //// 
.................... ////                                                                 //// 
.................... //// usb_cdc_getc() - Gets a character from the receive buffer.  If  //// 
.................... ////      there is no data in the receive buffer it will wait until  //// 
.................... ////      there is data in the receive buffer.  If you do not want   //// 
.................... ////      to wait in an infinit loop, use usb_cdc_kbhit() first to   //// 
.................... ////      check if there is data before calling usb_cdc_getc().      //// 
.................... ////                                                                 //// 
.................... //// usb_cdc_putc(char c) - Puts a character into the transmit       //// 
.................... ////      buffer.  If the transmit buffer is full it will wait until //// 
.................... ////      the transmit buffer is not full before putting the char    //// 
.................... ////      into the transmit buffer.  The transmit buffer is read by  //// 
.................... ////      the PC very quickly, and therefore the buffer should only  //// 
.................... ////      be full for a few milli-seconds.  If you are concerned     //// 
.................... ////      and don't want to be stuck in a long or infinite loop,     //// 
.................... ////      use usb_cdc_putready() to see if there is space in the     //// 
.................... ////      transmit buffer before putting data into the transmit      //// 
.................... ////      buffer.                                                    //// 
.................... ////                                                                 //// 
.................... //// usb_cdc_putready() - Returns TRUE if there is room left in the  //// 
.................... ////      transmit buffer for another character.                     //// 
.................... ////                                                                 //// 
.................... //// usb_cdc_connected() - Returns TRUE if we received a             //// 
.................... ////      Set_Line_Coding.  On most serial terminal programs (such   //// 
.................... ////      as Hyperterminal), they will send a Set_Line_Coding        //// 
.................... ////      message when the program starts and it opens the virtual   //// 
.................... ////      COM port.  This is a simple way to determine if the PC     //// 
.................... ////      is ready to display data on a serial terminal program,     //// 
.................... ////      but is not garaunteed to work all the time or on other     //// 
.................... ////      terminal programs.                                         //// 
.................... ////                                                                 //// 
.................... //// usb_cdc_putc_fast(char c) - Similar to usb_cdc_putc(), except   //// 
.................... ////      if the transmit buffer is full it will skip the char.      //// 
.................... ////                                                                 //// 
.................... //// usb_cdc_line_coding - A structure used for Set_Line_Coding and  //// 
.................... ////       Get_Line_Coding.  Most of the time you can ignore this.   //// 
.................... ////                                                                 //// 
.................... //// usb_cdc_break - If the PC has sent a break command, this will   //// 
.................... ////       hold the break time (in milli-seconds).  If the PC sends  //// 
.................... ////       a value of 0xFFFF the device is supposed to hold the      //// 
.................... ////       break until it sends a value of 0                         //// 
.................... ////                                                                 //// 
.................... //// usb_cdc_carrier - Where Set_Control_Line_State value is stored. //// 
.................... ////       Of most relevance is the field dte_present, which is the  //// 
.................... ////       DTR setting.                                              //// 
.................... ////                                                                 //// 
.................... //// The following functions are also provided, and are ports of the //// 
.................... //// I/O functions in input.c.  See input.c and the CCS manual for   //// 
.................... //// documentation:                                                  //// 
.................... ////   get_float_usb() - Read a float number from the user           //// 
.................... ////   get_long_usb() - Read a long number from the user             //// 
.................... ////   get_int_usb() - Read an integer number from the user          //// 
.................... ////   get_string_usb(char *s, int max) - Read a string from the user. //// 
.................... ////   gethex_usb() - Read a byte, in HEX, from the user             //// 
.................... ////   gethex1_usb() - Read a HEX character                          //// 
.................... ////                                                                 //// 
.................... //// This driver will load all the rest of the USB code, and a set   //// 
.................... //// of descriptors that will properly describe a CDC device for a   //// 
.................... //// virtual COM port (usb_desc_cdc.h)                               //// 
.................... ////                                                                 //// 
.................... //// An .INF file is provided (cdc_NTXP.inf) that will load the      //// 
.................... //// standard CDC drivers for a virtual COM port in Windows          //// 
.................... //// NT/2000/XP and above.  Unfortunately we do not provide an .inf  //// 
.................... //// file for Windows 98 and ME.                                     //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                                                                 //// 
.................... //// VERSION HISTORY                                                 //// 
.................... ////                                                                 //// 
.................... //// October 27th, 2005: Changed the way incoming packets are        //// 
.................... ////               handled in that CDC driver will not flush         //// 
.................... ////               endpoint until user has handled all data.  This   //// 
.................... ////               will prevent overflows as the USB will NAK        //// 
.................... ////               incoming packets until it is ready to receive     //// 
.................... ////               more.                                             //// 
.................... ////            When using 18F4550 family, the RX buffer is          //// 
.................... ////               mapped directly to the endpoint buffer - this     //// 
.................... ////               saves a chunk of RAM.                             //// 
.................... ////            When using the 18F4550 family, you can increase      //// 
.................... ////               the TX and RX size over 64 bytes.                 //// 
.................... ////            No longer send 0len packets in the TBE interrupt.    //// 
.................... ////            Hopefully fixed bugs that caused random crashes      //// 
.................... ////               if you tried sending more than 64 bytes.          //// 
.................... ////                                                                 //// 
.................... //// July 6th, 2005: Global interrupts disabled when writing to TX   //// 
.................... ////                   buffer.                                       //// 
.................... ////                                                                 //// 
.................... //// July 1st, 2005: Initial Release.                                //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2005 Custom Computer Services         //// 
.................... //// This source code may only be used by licensed users of the CCS  //// 
.................... //// C compiler.  This source code may only be distributed to other  //// 
.................... //// licensed users of the CCS C compiler.  No other use,            //// 
.................... //// reproduction or distribution is permitted without written       //// 
.................... //// permission.  Derivative programs created using this software    //// 
.................... //// in object code form are not restricted in any way.              //// 
.................... ///////////////////////////////////////////////////////////////////////// 
....................  
....................  
.................... //api for the user: 
.................... #define usb_cdc_kbhit() (usb_cdc_get_buffer_status.got) 
.................... #define usb_cdc_putready() (usb_cdc_put_buffer_nextin<USB_CDC_DATA_IN_SIZE) 
.................... #define usb_cdc_connected() (usb_cdc_got_set_line_coding) 
.................... void usb_cdc_putc_fast(char c); 
.................... char usb_cdc_getc(void); 
.................... void usb_cdc_putc(char c); 
....................  
.................... //input.c ported to use CDC: 
.................... float get_float_usb(); 
.................... signed long get_long_usb(); 
.................... signed int get_int_usb(); 
.................... void get_string_usb(char* s, int max); 
.................... BYTE gethex_usb(); 
.................... BYTE gethex1_usb(); 
....................  
.................... //functions automatically called by USB handler code 
.................... void usb_isr_tkn_cdc(void); 
.................... void usb_cdc_init(void); 
.................... void usb_isr_tok_out_cdc_control_dne(void); 
.................... void usb_isr_tok_in_cdc_data_dne(void); 
.................... void usb_isr_tok_out_cdc_data_dne(void); 
....................  
.................... void usb_cdc_flush_out_buffer(void); 
....................  
.................... //Tells the CCS PIC USB firmware to include HID handling code. 
.................... #DEFINE USB_HID_DEVICE  FALSE 
.................... #DEFINE USB_CDC_DEVICE  TRUE 
....................  
.................... #define USB_CDC_COMM_IN_ENDPOINT       1 
.................... #define USB_CDC_COMM_IN_SIZE           8 
.................... #define USB_EP1_TX_ENABLE  USB_ENABLE_INTERRUPT 
.................... #define USB_EP1_TX_SIZE  USB_CDC_COMM_IN_SIZE 
....................  
.................... //pic to pc endpoint config 
.................... #define USB_CDC_DATA_IN_ENDPOINT       2 
.................... #define USB_CDC_DATA_IN_SIZE           64 
.................... #define USB_EP2_TX_ENABLE  USB_ENABLE_BULK 
.................... #define USB_EP2_TX_SIZE  USB_CDC_DATA_IN_SIZE 
....................  
.................... //pc to pic endpoint config 
.................... #define USB_CDC_DATA_OUT_ENDPOINT       2 
.................... #define USB_CDC_DATA_OUT_SIZE           64 
.................... #define USB_EP2_RX_ENABLE  USB_ENABLE_BULK 
.................... #define USB_EP2_RX_SIZE  USB_CDC_DATA_OUT_SIZE 
....................  
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... // 
.................... // Include the CCS USB Libraries.  See the comments at the top of these 
.................... // files for more information 
.................... // 
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... #ifndef __USB_PIC_PERIF__ 
.................... #define __USB_PIC_PERIF__	1 
.................... #endif 
....................  
.................... #if __USB_PIC_PERIF__ 
....................  #if defined(__PCM__) 
....................   #error CDC requires bulk mode!  PIC16C7x5 does not have bulk mode 
....................  #else 
....................   #include <pic18_usb.h>   //Microchip 18Fxx5x hardware layer for usb.c 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                          pic18_usb.c                            //// 
.................... ////                                                                 //// 
.................... //// Hardware layer for CCS's USB library.  This hardware layer      //// 
.................... //// supports the USB peripheral on the PIC18 family chips.  Current //// 
.................... //// supported families are:                                         //// 
.................... ////     PIC18F2455/2550/4455/4550                                   //// 
.................... ////     PIC18F2450/4450                                             //// 
.................... ////     PIC18F65J50/66J50/66J55/67J50/85J50/86J50/86J55/87J50       //// 
.................... ////                                                                 //// 
.................... //// This file is part of CCS's PIC USB driver code, which includes: //// 
.................... ////   usb_desc_*.h - an example set of config and device descriptor //// 
.................... ////   usb.c - USB token and request handler code                    //// 
.................... ////   usb.h - definitions, prototypes and global variables          //// 
.................... ////                                                                 //// 
.................... //// The following examples are provided by CCS:                     //// 
.................... ////   ex_usb_mouse.c - A HID Mouse.                                 //// 
.................... ////   ex_usb_hid.c - A custom application using HID protocol.       //// 
.................... ////   ex_usb_kbmouse.c - A HID Mouse/Keyboard combo using multiple  //// 
.................... ////                      interfaces.                                //// 
.................... ////   ex_usb_kbmouse2.c - A HID Mouse/Keyboard combo using multiple //// 
.................... ////                      HID Reports.                               //// 
.................... ////   ex_usb_scope.c - A digital oscilloscope using a custom        //// 
.................... ////                    protocol requiring custom Windows drivers.   //// 
.................... ////   ex_usb_serial.c -                                             //// 
.................... ////   ex_usb_serial2.c - Two examples of using the CDC driver for   //// 
.................... ////     a virtual COM port.                                         //// 
.................... ////                                                                 //// 
.................... ////   *********** NOTE ABOUT 18F2450/4450 LIMITATIONS **********    //// 
.................... ////  Due to the limited USB RAM of this family, a limitation of     //// 
.................... ////  this driver is that there are only 3 endpoints (0, 1 and 2).   //// 
.................... ////  The HW actually supports more endpoints, but to simplify       //// 
.................... ////  driver development this driver will only support the first 3   //// 
.................... ////  so there is an easier memory block to work with.               //// 
.................... ////                                                                 //// 
.................... ////  USB_MAX_EP0_PACKET_LENGTH will also be set to 8 regardless     //// 
.................... ////  of USB speed, to save RAM.                                     //// 
.................... ////                                                                 //// 
.................... ////   ************** NOTE ABOUT HW REQUIREMENTS ****************    //// 
.................... ////  If you are not using internal pullups, you will need to put    //// 
.................... ////  an internal pullup resistor on C4 or C5 depending on if you    //// 
.................... ////  want to use slow speed or full speed.  This code configures    //// 
.................... ////  the device to use internal pullups, see usb_init() if you      //// 
.................... ////  want to change that.                                           //// 
.................... ////                                                                 //// 
.................... ////  You need approximately 470nF cap on C3, even if you are using  //// 
.................... ////  the internal 3.3V USB regulator.                               //// 
.................... ////                                                                 //// 
.................... ////  To run at full speed, you must use the oscillator              //// 
.................... ////  configuration (PLLx) to set the PLL divide to 4MHz.  You can   //// 
.................... ////  configure the MCU clock to any speed (up to 48MHz) but the     //// 
.................... ////  PLL must run at 4Mhz to provide the USB peripheral with a      //// 
.................... ////  96MHz clock.  See the datasheet for details.                   //// 
.................... ////                                                                 //// 
.................... ////  To run at slow speed you must configure your MCU to run at     //// 
.................... ////  24Mhz.  See the datasheet for details.                         //// 
.................... ////                                                                 //// 
.................... ////   ****************  NOTE ABOUT INTERRUPTS  ******************   //// 
.................... //// This driver uses INT_USB.  It requires INT_USB to interrupt the //// 
.................... //// PIC when an event has happened on the USB Bus.  Therfore        //// 
.................... //// this code enables interrupts.  A user modification can be made  //// 
.................... //// to poll the USB interrupt flag instead of relying on an         //// 
.................... //// interrupt.                                                      //// 
.................... ////                                                                 //// 
.................... ////    ****************   USER FUNCTIONS  ***********************   //// 
.................... ////                                                                 //// 
.................... //// usb_init() - Initializes the USB stack, the USB peripheral and  //// 
.................... ////              attaches the unit to the usb bus.  Enables         //// 
.................... ////              interrupts.                                        //// 
.................... ////                                                                 //// 
.................... //// usb_init_cs() - A smaller usb_init(), does not attach unit      //// 
.................... ////              to usb bus or enable interrupts.                   //// 
.................... ////                                                                 //// 
.................... //// usb_put_packet() - Sends one packet to the host.                //// 
.................... ////                    If you need to send a message that spans     //// 
.................... ////                    more than one packet then see usb_puts() in  //// 
.................... ////                    usb.c                                        //// 
.................... ////                                                                 //// 
.................... //// usb_kbhit() - Returns true if OUT endpoint contains data from   //// 
.................... ////               host.                                             //// 
.................... ////                                                                 //// 
.................... //// usb_rx_packet_size() - Returns the size of packet that was      //// 
.................... ////               received.  usb_kbhit() must return TRUE else      //// 
.................... ////               this is not valid.  Don't forget in USB there     //// 
.................... ////               are 0 len packets!                                //// 
.................... ////                                                                 //// 
.................... //// usb_get_packet() - Gets one packet that from the host.          //// 
.................... ////                    usb_kbhit() must return true before you call //// 
.................... ////                    this routine or your data may not be valid.  //// 
.................... ////                    Once usb_kbhit() returns true you want to    //// 
.................... ////                    call this as soon as possible to get data    //// 
.................... ////                    out of the endpoint buffer so the PC can     //// 
.................... ////                    start sending more data, if needed.          //// 
.................... ////                    This only receives one packet, if you are    //// 
.................... ////                    trying to receive a multi-packet message     //// 
.................... ////                    see usb_gets() in usb.c.                     //// 
.................... ////                                                                 //// 
.................... //// usb_detach() - De-attach USB from the system.                   //// 
.................... ////                                                                 //// 
.................... //// usb_attach() - Attach USB to the system.                        //// 
.................... ////                                                                 //// 
.................... //// usb_attached() - Returns TRUE if the device is attached to a    //// 
.................... ////                  USB cable.  A macro that looks at the defined  //// 
.................... ////                  connection sense pin.                          //// 
.................... ////                                                                 //// 
.................... //// usb_task() - Keeps track of connection sense, calling           //// 
.................... ////              usb_detach() and usb_attach() when needed.         //// 
.................... ////                                                                 //// 
.................... //// For more documentation on these functions read the comments at  //// 
.................... //// each function.                                                  //// 
.................... ////                                                                 //// 
.................... //// The other functions defined in this file are for use by the     //// 
.................... //// USB code, and is not meant to be used by the user.              //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                                                                 //// 
.................... //// Version History:                                                //// 
.................... ////                                                                 //// 
.................... ////   09-19-07: Fixed problems with 18F4450 family.                 //// 
.................... ////                                                                 //// 
.................... ////   07-17-07: Added 18F4450,2450 support                          //// 
.................... ////                                                                 //// 
.................... ////   07-13-07: Added 87J50 family support                          //// 
.................... ////                                                                 //// 
.................... ////   11-01-05: usb_detach(), usb_attach() and usb_init_cs()        //// 
.................... ////               changed for the better.                           //// 
.................... ////                                                                 //// 
.................... ////   10-28-05: Added usb_rx_packet_size()                          //// 
.................... ////                                                                 //// 
.................... ////   07-13-05: usb_put_packet() changed for 16bit packet sizes     //// 
.................... ////             usb_flush_in() changed for 16bit packet sizes       //// 
.................... ////             usb_get_packet() changed for 16bit packet sizes     //// 
.................... ////             usb_flush_out() changed for 16bit packet sizes      //// 
.................... ////             usb_set_configured() changed for 16bit packet sizes //// 
.................... ////                                                                 //// 
.................... ////   06-30-05: usb_tbe() added                                     //// 
.................... ////             The way endpoint 0 DTS is set has been changed.     //// 
.................... ////                                                                 //// 
.................... ////   06-20-05: Initial Release                                     //// 
.................... ////                                                                 //// 
.................... ////   05-13-05: Beta Release (Full Speed works)                     //// 
.................... ////                                                                 //// 
.................... ////   03-21-05: Initial Alpha Release                               //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2005 Custom Computer Services         //// 
.................... //// This source code may only be used by licensed users of the CCS  //// 
.................... //// C compiler.  This source code may only be distributed to other  //// 
.................... //// licensed users of the CCS C compiler.  No other use,            //// 
.................... //// reproduction or distribution is permitted without written       //// 
.................... //// permission.  Derivative programs created using this software    //// 
.................... //// in object code form are not restricted in any way.              //// 
.................... ///////////////////////////////////////////////////////////////////////// 
....................  
.................... #IFNDEF __USB_HARDWARE__ 
.................... #DEFINE __USB_HARDWARE__ 
....................  
.................... //let the USB Stack know that we are using a PIC with internal USB peripheral 
.................... #DEFINE __PIC__   1 
....................  
.................... #if ((getenv("DEVICE")=="PIC18F87J50") || (getenv("DEVICE")=="PIC18F86J55") || \ 
....................      (getenv("DEVICE")=="PIC18F86J50") || (getenv("DEVICE")=="PIC18F85J50") || \ 
....................      (getenv("DEVICE")=="PIC18F67J50") || (getenv("DEVICE")=="PIC18F66J55") || \ 
....................      (getenv("DEVICE")=="PIC18F66J50") || (getenv("DEVICE")=="PIC18F65J50")) 
....................  #define __USB_87J50__ 
....................  #define USB_TOTAL_BUFFER_SPACE  ((int16)getenv("RAM")-0x500) 
....................  #define USB_MAX_NUM_ENDPOINTS  16 
.................... #elif ((getenv("DEVICE")=="PIC18F2450") || (getenv("DEVICE")=="PIC18F4450")) 
....................  #define __USB_4450__ 
....................  #if ((USB_EP3_TX_SIZE + USB_EP3_RX_SIZE + USB_EP4_TX_SIZE + USB_EP4_RX_SIZE + \ 
....................       USB_EP5_TX_SIZE + USB_EP5_RX_SIZE + USB_EP6_TX_SIZE + USB_EP6_RX_SIZE + \ 
....................       USB_EP7_TX_SIZE + USB_EP7_RX_SIZE + USB_EP8_TX_SIZE + USB_EP8_RX_SIZE + \ 
....................       USB_EP9_TX_SIZE + USB_EP9_RX_SIZE + USB_EP10_TX_SIZE + USB_EP10_RX_SIZE + \ 
....................       USB_EP11_TX_SIZE + USB_EP11_RX_SIZE + USB_EP12_TX_SIZE +USB_EP12_RX_SIZE + \ 
....................       USB_EP13_TX_SIZE + USB_EP13_RX_SIZE + USB_EP14_TX_SIZE + USB_EP14_RX_SIZE + \ 
....................       USB_EP15_TX_SIZE + USB_EP15_RX_SIZE) > 0) 
....................    #error This driver only supports endpoints 0, 1 and 2 for this chip. 
....................  #endif 
....................  #define USB_MAX_NUM_ENDPOINTS  3 
....................  #define USB_TOTAL_BUFFER_SPACE  (0x100 - USB_MAX_NUM_ENDPOINTS*8) 
.................... #elif ((getenv("DEVICE")=="PIC18F2455") || (getenv("DEVICE")=="PIC18F2550") || \ 
....................        (getenv("DEVICE")=="PIC18F4455") || (getenv("DEVICE")=="PIC18F4550")) 
....................  #define __USB_4550__ 
....................  #define USB_TOTAL_BUFFER_SPACE  ((int16)0x300) 
....................  #define USB_MAX_NUM_ENDPOINTS  16 
.................... #else 
....................  #error Unknown PIC device, USB not supported in this library. 
.................... #endif 
....................  
.................... #ifndef USB_USE_FULL_SPEED 
....................  #define USB_USE_FULL_SPEED   TRUE 
.................... #endif 
....................  
.................... #ifndef USB_CON_SENSE_PIN 
....................  #define USB_CON_SENSE_PIN  0 
.................... #endif 
....................  
.................... #if defined(__USB_4450__) 
....................    //due to limited ram, force max packet length to 8 for this chip 
....................    #define USB_MAX_EP0_PACKET_LENGTH   8 
.................... #else 
....................    #if USB_USE_FULL_SPEED==FALSE 
....................       //slow speed requires 8byte max packet size for endpoint 0 
....................       #DEFINE USB_MAX_EP0_PACKET_LENGTH   8 
....................    #else 
....................       //for full speed you can still use 8bytes, but 64 will be faster 
....................       #DEFINE USB_MAX_EP0_PACKET_LENGTH   64 
....................    #endif 
.................... #endif 
....................  
.................... #INCLUDE <usb.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                              usb.h                                //// 
.................... ////                                                                   //// 
.................... //// Function protypes, defintions and globals used by CCS USB driver  //// 
.................... ////                                                                   //// 
.................... //// This file is part of CCS's PIC USB driver code, which includes:   //// 
.................... ////   usb_desc_*.h - an example set of config and device descriptor   //// 
.................... ////   usb.c - USB token and request handler code                      //// 
.................... ////   usb.h - definitions, prototypes and global variables            //// 
.................... ////                                                                   //// 
.................... //// The following examples are provided by CCS:                       //// 
.................... ////   ex_usb_mouse.c - A HID Mouse.                                   //// 
.................... ////   ex_usb_hid.c - A custom application using HID protocol.         //// 
.................... ////   ex_usb_kbmouse.c - A HID Mouse/Keyboard combo using multiple    //// 
.................... ////                      interfaces.                                  //// 
.................... ////   ex_usb_kbmouse.c - A HID Mouse/Keyboard combo using multiple    //// 
.................... ////                      HID Reports.                                 //// 
.................... ////   ex_usb_scope.c - A digital oscilloscope using a custom          //// 
.................... ////                    protocol requiring custom Windows drivers.     //// 
.................... ////                                                                   //// 
.................... ////                   **** DEFINITIONS *****                          //// 
.................... //// The following definitions are declared here, but can be           //// 
.................... //// overwritten in your code.  Unless needed otherwise, leave         //// 
.................... //// to default value.  If confused about a definition read the        //// 
.................... //// comments at each defintion                                        //// 
.................... ////                                                                   //// 
.................... //// USB_HID_IDLE (FALSE) - Set to TRUE if your device supports        //// 
.................... ////                            Set_Idle HID class request.  Set to    //// 
.................... ////                            False if you do not (device will       //// 
.................... ////                            send a Wrong-state if computer         //// 
.................... ////                            sends a Set_Idle / Get_Idle command)   //// 
.................... ////                            NOTE: If you set to TRUE you must      //// 
.................... ////                            provide your own code.  See            //// 
.................... ////                            usb_isr_tkn_setup_ClassInterface() in  //// 
.................... ////                            usb.c                                  //// 
.................... ////                                                                   //// 
.................... //// USB_HID_BOOT_PROTOCOL (FALSE) - Set to TRUE if your device supports   //// 
.................... ////                            Set_Protocl HID class request. Set to  //// 
.................... ////                            False if you do not (device will       //// 
.................... ////                            send a Wrong-state if computer         //// 
.................... ////                            sends a Set_Protocl / Get_Protocol     //// 
.................... ////                            command).                              //// 
.................... ////                            NOTE: If you set to TRUE you must      //// 
.................... ////                            provide your own code in the           //// 
.................... ////                            application that properly send boot    //// 
.................... ////                            or HID packets.                        //// 
.................... ////                                                                   //// 
.................... //// USB_MAX_EP0_PACKET_LENGTH (8) - Max Packet size for Endpoint 0.   //// 
.................... ////                            Only the 18Fxx5x USB peripheral can    //// 
.................... ////                            have a value larger than 8.            //// 
.................... ////                                                                   //// 
.................... //// USB_EPx_RX_ENABLE (USB_ENABLE_DISABLED) - Where x is the          //// 
.................... ////                         endpoint number. Change this define       //// 
.................... ////                         to specify what kind of transfer method   //// 
.................... ////                         this RX (PC to device) endpoint uses.     //// 
.................... ////                       Here is the list of valid transfer methods: //// 
.................... ////                             USB_ENABLE_CONTROL                    //// 
.................... ////                             USB_ENABLE_ISOCHRONOUS                //// 
.................... ////                             USB_ENABLE_BULK                       //// 
.................... ////                             USB_ENABLE_INTERRUPT                  //// 
.................... ////                             USB_ENABLE_DISABLED                   //// 
.................... ////                        Don't forget that you must specify the     //// 
.................... ////                        transfer method properly in your endpoint  //// 
.................... ////                        descriptor, too.                           //// 
.................... ////                                                                   //// 
.................... //// USB_EPx_RX_SIZE (0) - For some hardware it is important to know   //// 
.................... ////                       how much memory to reserve for receiving    //// 
.................... ////                       packets.                                    //// 
.................... ////                                                                   //// 
.................... ////  *** NOTE *** You must have both USB_EPx_RX_ENABLE defined and    //// 
.................... ////               USB_EPx_RX_SIZE defined (non 0) to enable a RX      //// 
.................... ////               endpoint.                                           //// 
.................... ////  *** NOTE *** Endpoint 0 is always enabled.                       //// 
.................... ////                                                                   //// 
.................... //// USB_EPx_TX_ENABLE (USB_ENABLE_DISABLED) - Where x is the          //// 
.................... ////                         endpoint number. Change this define       //// 
.................... ////                         to specify what kind of transfer method   //// 
.................... ////                         this TX (device to PC) endpoint uses.     //// 
.................... ////                       Here is the list of valid transfer methods: //// 
.................... ////                             USB_ENABLE_CONTROL                    //// 
.................... ////                             USB_ENABLE_ISOCHRONOUS                //// 
.................... ////                             USB_ENABLE_BULK                       //// 
.................... ////                             USB_ENABLE_INTERRUPT                  //// 
.................... ////                             USB_ENABLE_DISABLED                   //// 
.................... ////                        Don't forget that you must specify the     //// 
.................... ////                        transfer method properly in your endpoint  //// 
.................... ////                        descriptor, too.                           //// 
.................... ////                                                                   //// 
.................... //// USB_EPx_TX_SIZE (0) - For some hardware it is important to know   //// 
.................... ////                       how much memory to reserve for transmitting //// 
.................... ////                       packets.                                    //// 
.................... ////                                                                   //// 
.................... ////  *** NOTE *** You must have both USB_EPx_TX_ENABLE defined and    //// 
.................... ////               USB_EPx_TX_SIZE defined (non 0) to enable a TX      //// 
.................... ////               endpoint.                                           //// 
.................... ////                                                                   //// 
.................... ////                                                                   //// 
.................... //// USB_HID_DEVICE (TRUE) - HID devices require extra code to handle  //// 
.................... ////                         HID requests.  You can disable to save    //// 
.................... ////                         ROM space if you are not using a HID      //// 
.................... ////                         device.  If you are not using a HID       //// 
.................... ////                         device you must provide your own O/S      //// 
.................... ////                         (Windows) driver.                         //// 
.................... ////                                                                   //// 
.................... //// The other definitions should not be changed.                      //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... //// Version History:                                                  //// 
.................... ////                                                                   //// 
.................... //// July 13th, 2005:                                                  //// 
.................... ////  usb_ep_tx_size[] and usb_ep_rx_size[] changed to 16bits          //// 
.................... ////                                                                   //// 
.................... //// June 20th, 2005:                                                  //// 
.................... ////  Initial 18fxx5x release                                          //// 
.................... ////                                                                   //// 
.................... //// May 13th, 2005:                                                   //// 
.................... ////  Beta release, only works with 18Fxx5x hardware layer.            //// 
.................... ////  Now supports multiple interfaces (many defines in descriptors    //// 
.................... ////   will have to be changed, see examples)                          //// 
.................... ////                                                                   //// 
.................... //// Mar 21st, 2005:                                                   //// 
.................... ////  Initial Alpha Release with PIC18Fxx5x support.  (ONLY TESTED     //// 
.................... ////   WITH 18F4550)                                                   //// 
.................... ////  usb_gets() and usb_puts() changed (see usb.c)                    //// 
.................... ////                                                                   //// 
.................... //// June 24th, 2004:                                                  //// 
.................... ////  Optimization and cleanup.                                        //// 
.................... ////                The following definitions changed:                 //// 
.................... ////  USB_EPx_TX_ENABLE and USB_EPx_RX_ENABLE have changed. See usb.h  //// 
.................... ////  USB_CONFIG_DESCRIPTORS[] removed                                 //// 
.................... ////  USB_CONFIG_DESC_LEN changed to USB_DESC_CONFIG_LEN               //// 
.................... ////  USB_INTERFACE_DESC_LEN changed to USB_DESC_INTERFACE_LEN         //// 
.................... ////  USB_CLASS_DESC_LEN changed to USB_DESC_CLASS_LEN                 //// 
.................... ////  USB_ENDPOINT_DESC_LEN changed to USB_DESC_ENDPOINT_LEN           //// 
.................... ////  USB_CONFIG_DESC_KEY changed to USB_DESC_CONFIG_TYPE              //// 
.................... ////  USB_INTERFACE_DESC_KEY changed to USB_DESC_INTERFACE_TYPE        //// 
.................... ////  USB_CLASS_DESC_KEY changed to USB_DESC_CLASS_TYPE                //// 
.................... ////  USB_ENDPOINT_DESC_KEY changed to USB_DESC_ENDPOINT_TYPE          //// 
.................... ////  USB_STRING_X[] arrays removed, see USB_STRING_DESC[] and         //// 
.................... ////                                 USB_STRING_DESC_OFFSET[]          //// 
.................... ////  dev_req, curr_config, status_device and getdesc_type global      //// 
.................... ////        variables moved into struct USB_stack_status               //// 
.................... ////                                                                   //// 
.................... //// October 15th, 2003: Support for boot protocol added.              //// 
.................... ////         Set USB_HID_BOOT_PROTOCOL to TRUE to support this.        //// 
.................... ////         The array hid_protocol[] saves which protocol mode each   //// 
.................... ////         interface is in.  It is your applications job to send     //// 
.................... ////         data that either fit the boot protocol or HID protocol.   //// 
.................... ////                                                                   //// 
.................... //// May 6th, 2003: Fixed a potential stack overflow using PCM         //// 
.................... ////                                                                   //// 
.................... //// October 29th, 2002: New definition added to USB_STATES            //// 
.................... ////                                                                   //// 
.................... //// August 2nd, 2002: Initial Public Release                          //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2005 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS    //// 
.................... //// C compiler.  This source code may only be distributed to other    //// 
.................... //// licensed users of the CCS C compiler.  No other use,              //// 
.................... //// reproduction or distribution is permitted without written         //// 
.................... //// permission.  Derivative programs created using this software      //// 
.................... //// in object code form are not restricted in any way.                //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
....................  
.................... #IFNDEF __USB_PROTOTYPES__ 
.................... #DEFINE __USB_PROTOTYPES__ 
....................  
.................... #IFNDEF USB_HID_BOOT_PROTOCOL 
....................    #DEFINE USB_HID_BOOT_PROTOCOL FALSE 
.................... #ENDIF 
....................  
.................... #IFNDEF USB_HID_IDLE 
....................    #DEFINE USB_HID_IDLE FALSE 
.................... #ENDIF 
....................  
.................... //should the compiler add the extra HID handler code?  Defaults to yes. 
.................... #IFNDEF USB_HID_DEVICE 
....................    #DEFINE USB_HID_DEVICE TRUE 
.................... #ENDIF 
....................  
.................... #IFNDEF USB_CDC_DEVICE 
....................    #DEFINE USB_CDC_DEVICE FALSE 
.................... #ENDIF 
....................  
.................... #ifndef USB_OPT_FOR_ROM 
....................    #define USB_OPT_FOR_ROM TRUE  //set to false to opt for less RAM, true to opt for less ROM 
.................... #endif 
....................  
.................... #IFNDEF USB_MAX_EP0_PACKET_LENGTH 
....................   #DEFINE USB_MAX_EP0_PACKET_LENGTH 8 
.................... #ENDIF 
....................  
.................... //CCS only supports one configuration at this time 
.................... #DEFINE USB_NUM_CONFIGURATIONS 1 //DO NOT CHANGE 
....................  
.................... //PID values for tokens (see page 48 of USB Complete ed.1) 
.................... #define PID_IN       0x09  //device to host transactions 
.................... #define PID_OUT      0x01  //host to device transactions 
.................... #define PID_SETUP    0x0D  //host to device setup transaction 
.................... #define PID_ACK      0x02  //receiver accepts error-free data packet 
.................... #define PID_DATA0    0x03  //data packet with even sync bit 
.................... #define PID_SOF      0x05  //start of framer marker and frame number 
.................... #define PID_NAK      0x0A  //receiver can't accept data or sender cant send data or has no data to transmit 
.................... #define PID_DATA1    0x0B  //data packet with odd sync bit 
.................... #define PID_PRE      0x0C  //preamble issued by host.  enables downstream traffic to low-speed device 
.................... #define PID_STALL    0x0E  //a control request isnt supported or the endpoint is halted 
....................  
.................... //Key which identifies descritpors 
.................... #DEFINE USB_DESC_DEVICE_TYPE     0x01  //#DEFINE USB_DEVICE_DESC_KEY      0x01 
.................... #DEFINE USB_DESC_CONFIG_TYPE     0x02  //#DEFINE USB_CONFIG_DESC_KEY      0x02 
.................... #DEFINE USB_DESC_STRING_TYPE     0x03  //#DEFINE USB_STRING_DESC_KEY      0x03 
.................... #DEFINE USB_DESC_INTERFACE_TYPE  0x04  //#DEFINE USB_INTERFACE_DESC_KEY   0x04 
.................... #DEFINE USB_DESC_ENDPOINT_TYPE   0x05  //#DEFINE USB_ENDPOINT_DESC_KEY    0x05 
.................... #DEFINE USB_DESC_CLASS_TYPE      0x21  //#DEFINE USB_CLASS_DESC_KEY       0x21 
.................... #DEFINE USB_DESC_HIDREPORT_TYPE  0x22 
....................  
.................... //The length of each descriptor 
.................... #DEFINE USB_DESC_DEVICE_LEN      18 //#DEFINE USB_DEVICE_DESC_LEN      18 
.................... #DEFINE USB_DESC_CONFIG_LEN      9  //#DEFINE USB_CONFIG_DESC_LEN      9 
.................... #DEFINE USB_DESC_INTERFACE_LEN   9  //#DEFINE USB_INTERFACE_DESC_LEN   9 
.................... #DEFINE USB_DESC_CLASS_LEN       9  //#DEFINE USB_CLASS_DESC_LEN       9 
.................... #DEFINE USB_DESC_ENDPOINT_LEN    7  //#DEFINE USB_ENDPOINT_DESC_LEN    7 
....................  
.................... //Standard USB Setup bRequest Codes 
.................... #define USB_STANDARD_REQUEST_GET_STATUS         0x00 
.................... #define USB_STANDARD_REQUEST_CLEAR_FEATURE      0x01 
.................... #define USB_STANDARD_REQUEST_SET_FEATURE        0x03 
.................... #define USB_STANDARD_REQUEST_SET_ADDRESS        0x05 
.................... #define USB_STANDARD_REQUEST_GET_DESCRIPTOR     0x06 
.................... #define USB_STANDARD_REQUEST_SET_DESCRIPTOR     0x07 
.................... #define USB_STANDARD_REQUEST_GET_CONFIGURATION  0x08 
.................... #define USB_STANDARD_REQUEST_SET_CONFIGURATION  0x09 
.................... #define USB_STANDARD_REQUEST_GET_INTERFACE      0x0A 
.................... #define USB_STANDARD_REQUEST_SET_INTERFACE      0x0B 
.................... #define USB_STANDARD_REQUEST_SYNCH_FRAME        0x0C 
....................  
.................... //HID Class Setup bRequest Codes 
.................... #define USB_HID_REQUEST_GET_REPORT     0x01 
.................... #define USB_HID_REQUEST_GET_IDLE       0x02 
.................... #define USB_HID_REQUEST_GET_PROTOCOL   0x03 
.................... #define USB_HID_REQUEST_SET_REPORT     0x09 
.................... #define USB_HID_REQUEST_SET_IDLE       0x0A 
.................... #define USB_HID_REQUEST_SET_PROTOCOL   0x0B 
....................  
.................... //types of endpoints as defined in the descriptor 
.................... #define USB_ENDPOINT_TYPE_CONTROL      0x00 
.................... #define USB_ENDPOINT_TYPE_ISOCHRONOUS  0x01 
.................... #define USB_ENDPOINT_TYPE_BULK         0x02 
.................... #define USB_ENDPOINT_TYPE_INTERRUPT    0x03 
....................  
.................... //types of endpoints used internally in this api 
.................... #define USB_ENABLE_DISABLED     0 
.................... #define USB_ENABLE_BULK         0x01 
.................... #define USB_ENABLE_ISOCHRONOUS  0x02 
.................... #define USB_ENABLE_INTERRUPT    0x03 
.................... #define USB_ENABLE_CONTROL      0x04 
....................  
.................... //// DO NOT CHANGE THE FOLLOWING VALUES: 
....................  
.................... enum USB_STATES {GET_DESCRIPTOR=1,SET_ADDRESS=2,NONE=0}; 
....................  
.................... enum USB_DTS_BIT {USB_DTS_DATA1=1, USB_DTS_TOGGLE=2, USB_DTS_DATA0=0, 
....................                    USB_DTS_STALL=3, USB_DTS_USERX=4}; 
....................  
.................... enum USB_GETDESC_TYPES {USB_GETDESC_CONFIG_TYPE=0,USB_GETDESC_HIDREPORT_TYPE=1,USB_GETDESC_STRING_TYPE=2,USB_GETDESC_DEVICE_TYPE=3}; 
....................  
.................... #if USB_OPT_FOR_ROM 
.................... struct { 
....................    USB_STATES dev_req;   //what did the last setup token set us up to do?.  init at none 
....................    int  curr_config;  //our current config.  start at none/powered (NOT THAT THIS LIMITS US TO 3 CONFIGURATIONS) 
....................    int status_device; //Holds our state for Set_Feature and Clear_Feature 
....................    USB_GETDESC_TYPES getdesc_type;   //which get_descriptor() we are handling 
.................... } USB_stack_status; 
.................... #else 
.................... struct { 
....................    USB_STATES dev_req:2;   //what did the last setup token set us up to do?.  init at none 
....................    int  Curr_config:2;  //our current config.  start at none/powered (NOT THAT THIS LIMITS US TO 3 CONFIGURATIONS) 
....................    int status_device:2; //Holds our state for Set_Feature and Clear_Feature 
....................    USB_GETDESC_TYPES getdesc_type:2;   //which get_descriptor() we are handling 
.................... } USB_stack_status; 
.................... #endif 
....................  
.................... int16 __usb_kbhit_status; 
....................  
.................... /// *** User function prototypes 
.................... void usb_wait_for_enumeration(void); 
.................... int1 usb_unermated(void); 
.................... int8 usb_gets(int8 endpoint, int8 * ptr, int16 max, int16 timeout); 
.................... int1 usb_puts(int8 endpoint, int8 * ptr, int16 len, int8 timeout); 
....................  
.................... /// *** Token and request hanlder function prototypes 
.................... void usb_token_reset(); 
....................  
.................... void usb_put_0len_0(void); 
.................... void usb_request_send_response(int len);   //always sends usb_ep0_rx_buffer[] to endpoint 0 with a toggle of DATA 
....................  
.................... void usb_match_registers(int8 endpoint, int16 *status, int16 *buffer, int8 *size); 
....................  
.................... void usb_isr_tok_in_dne(int8 endpoint); 
.................... void usb_isr_tok_out_dne(int8 endpoint); 
.................... void usb_isr_tok_setup_dne(void); 
....................  
.................... void usb_isr_tkn_setup_StandardEndpoint(void); 
.................... void usb_isr_tkn_setup_StandardDevice(void); 
.................... void usb_isr_tkn_setup_StandardInterface(void); 
....................  
.................... #IF USB_HID_DEVICE 
....................    void usb_isr_tkn_setup_ClassInterface(void); 
.................... #ENDIF 
....................  
.................... void usb_Get_Descriptor(void); 
.................... void usb_copy_desc_seg_to_ep(void); 
....................  
.................... void usb_finish_set_address(void); 
....................  
.................... //*** ENABLE RX ENDPOINTS AND BUFFERS 
....................  
.................... //--------- endpoint 0 defines ---------- 
.................... #define USB_EP0_TX_ENABLE  USB_ENABLE_CONTROL 
.................... #define USB_EP0_RX_ENABLE  USB_ENABLE_CONTROL 
.................... #define USB_EP0_RX_SIZE    USB_MAX_EP0_PACKET_LENGTH  //endpoint 0 is setup, and should always be the MAX_PACKET_LENGTH.  Slow speed specifies 8 
.................... #define USB_EP0_TX_SIZE    USB_MAX_EP0_PACKET_LENGTH  //endpoint 0 is setup, and should always be the MAX_PACKET_LENGTH.  Slow speed specifies 8 
....................  
.................... //--------- endpoint 1 defines ---------- 
.................... #ifndef USB_EP1_TX_ENABLE 
....................  #define USB_EP1_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP1_RX_ENABLE 
....................  #define USB_EP1_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP1_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP1_RX_SIZE 
....................   #undef USB_EP1_RX_SIZE 
....................  #endif 
....................  #define USB_EP1_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP1_RX_SIZE 
....................   #error You enabled EP1 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP1_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP1_TX_SIZE 
....................   #undef USB_EP1_TX_SIZE 
....................  #endif 
....................  #define USB_EP1_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP1_TX_SIZE 
....................   #error You enabled EP1 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 2 defines ---------- 
.................... #ifndef USB_EP2_TX_ENABLE 
....................  #define USB_EP2_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP2_RX_ENABLE 
....................  #define USB_EP2_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP2_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP2_RX_SIZE 
....................   #undef USB_EP2_RX_SIZE 
....................  #endif 
....................  #define USB_EP2_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP2_RX_SIZE 
....................   #error You enabled EP2 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP2_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP2_TX_SIZE 
....................   #undef USB_EP2_TX_SIZE 
....................  #endif 
....................  #define USB_EP2_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP2_TX_SIZE 
....................   #error You enabled EP2 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 3 defines ---------- 
.................... #ifndef USB_EP3_TX_ENABLE 
....................  #define USB_EP3_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP3_RX_ENABLE 
....................  #define USB_EP3_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP3_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP3_RX_SIZE 
....................   #undef USB_EP3_RX_SIZE 
....................  #endif 
....................  #define USB_EP3_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP3_RX_SIZE 
....................   #error You enabled EP3 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP3_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP3_TX_SIZE 
....................   #undef USB_EP3_TX_SIZE 
....................  #endif 
....................  #define USB_EP3_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP3_TX_SIZE 
....................   #error You enabled EP3 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 4 defines ---------- 
.................... #ifndef USB_EP4_TX_ENABLE 
....................  #define USB_EP4_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP4_RX_ENABLE 
....................  #define USB_EP4_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP4_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP4_RX_SIZE 
....................   #undef USB_EP4_RX_SIZE 
....................  #endif 
....................  #define USB_EP4_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP4_RX_SIZE 
....................   #error You enabled EP4 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP4_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP4_TX_SIZE 
....................   #undef USB_EP4_TX_SIZE 
....................  #endif 
....................  #define USB_EP4_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP4_TX_SIZE 
....................   #error You enabled EP4 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 5 defines ---------- 
.................... #ifndef USB_EP5_TX_ENABLE 
....................  #define USB_EP5_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP5_RX_ENABLE 
....................  #define USB_EP5_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP5_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP5_RX_SIZE 
....................   #undef USB_EP5_RX_SIZE 
....................  #endif 
....................  #define USB_EP5_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP5_RX_SIZE 
....................   #error You enabled EP5 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP5_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP5_TX_SIZE 
....................   #undef USB_EP5_TX_SIZE 
....................  #endif 
....................  #define USB_EP5_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP5_TX_SIZE 
....................   #error You enabled EP5 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 6 defines ---------- 
.................... #ifndef USB_EP6_TX_ENABLE 
....................  #define USB_EP6_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP6_RX_ENABLE 
....................  #define USB_EP6_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP6_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP6_RX_SIZE 
....................   #undef USB_EP6_RX_SIZE 
....................  #endif 
....................  #define USB_EP6_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP6_RX_SIZE 
....................   #error You enabled EP6 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP6_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP6_TX_SIZE 
....................   #undef USB_EP6_TX_SIZE 
....................  #endif 
....................  #define USB_EP6_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP6_TX_SIZE 
....................   #error You enabled EP6 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 7 defines ---------- 
.................... #ifndef USB_EP7_TX_ENABLE 
....................  #define USB_EP7_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP7_RX_ENABLE 
....................  #define USB_EP7_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP7_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP7_RX_SIZE 
....................   #undef USB_EP7_RX_SIZE 
....................  #endif 
....................  #define USB_EP7_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP7_RX_SIZE 
....................   #error You enabled EP7 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP7_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP7_TX_SIZE 
....................   #undef USB_EP7_TX_SIZE 
....................  #endif 
....................  #define USB_EP7_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP7_TX_SIZE 
....................   #error You enabled EP7 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 8 defines ---------- 
.................... #ifndef USB_EP8_TX_ENABLE 
....................  #define USB_EP8_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP8_RX_ENABLE 
....................  #define USB_EP8_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP8_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP8_RX_SIZE 
....................   #undef USB_EP8_RX_SIZE 
....................  #endif 
....................  #define USB_EP8_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP8_RX_SIZE 
....................   #error You enabled EP8 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP8_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP8_TX_SIZE 
....................   #undef USB_EP8_TX_SIZE 
....................  #endif 
....................  #define USB_EP8_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP8_TX_SIZE 
....................   #error You enabled EP8 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 9 defines ---------- 
.................... #ifndef USB_EP9_TX_ENABLE 
....................  #define USB_EP9_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP9_RX_ENABLE 
....................  #define USB_EP9_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP9_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP9_RX_SIZE 
....................   #undef USB_EP9_RX_SIZE 
....................  #endif 
....................  #define USB_EP9_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP9_RX_SIZE 
....................   #error You enabled EP9 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP9_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP9_TX_SIZE 
....................   #undef USB_EP9_TX_SIZE 
....................  #endif 
....................  #define USB_EP9_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP9_TX_SIZE 
....................   #error You enabled EP9 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 10 defines ---------- 
.................... #ifndef USB_EP10_TX_ENABLE 
....................  #define USB_EP10_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP10_RX_ENABLE 
....................  #define USB_EP10_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP10_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP10_RX_SIZE 
....................   #undef USB_EP10_RX_SIZE 
....................  #endif 
....................  #define USB_EP10_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP10_RX_SIZE 
....................   #error You enabled EP10 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP10_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP10_TX_SIZE 
....................   #undef USB_EP10_TX_SIZE 
....................  #endif 
....................  #define USB_EP10_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP10_TX_SIZE 
....................   #error You enabled EP10 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 11 defines ---------- 
.................... #ifndef USB_EP11_TX_ENABLE 
....................  #define USB_EP11_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP11_RX_ENABLE 
....................  #define USB_EP11_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP11_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP11_RX_SIZE 
....................   #undef USB_EP11_RX_SIZE 
....................  #endif 
....................  #define USB_EP11_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP11_RX_SIZE 
....................   #error You enabled EP11 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP11_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP11_TX_SIZE 
....................   #undef USB_EP11_TX_SIZE 
....................  #endif 
....................  #define USB_EP11_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP11_TX_SIZE 
....................   #error You enabled EP11 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 12 defines ---------- 
.................... #ifndef USB_EP12_TX_ENABLE 
....................  #define USB_EP12_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP12_RX_ENABLE 
....................  #define USB_EP12_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP12_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP12_RX_SIZE 
....................   #undef USB_EP12_RX_SIZE 
....................  #endif 
....................  #define USB_EP12_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP12_RX_SIZE 
....................   #error You enabled EP12 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP12_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP12_TX_SIZE 
....................   #undef USB_EP12_TX_SIZE 
....................  #endif 
....................  #define USB_EP12_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP12_TX_SIZE 
....................   #error You enabled EP12 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 13 defines ---------- 
.................... #ifndef USB_EP13_TX_ENABLE 
....................  #define USB_EP13_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP13_RX_ENABLE 
....................  #define USB_EP13_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP13_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP13_RX_SIZE 
....................   #undef USB_EP13_RX_SIZE 
....................  #endif 
....................  #define USB_EP13_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP13_RX_SIZE 
....................   #error You enabled EP13 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP13_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP13_TX_SIZE 
....................   #undef USB_EP13_TX_SIZE 
....................  #endif 
....................  #define USB_EP13_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP13_TX_SIZE 
....................   #error You enabled EP13 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 14 defines ---------- 
.................... #ifndef USB_EP14_TX_ENABLE 
....................  #define USB_EP14_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP14_RX_ENABLE 
....................  #define USB_EP14_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP14_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP14_RX_SIZE 
....................   #undef USB_EP14_RX_SIZE 
....................  #endif 
....................  #define USB_EP14_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP14_RX_SIZE 
....................   #error You enabled EP14 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP14_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP14_TX_SIZE 
....................   #undef USB_EP14_TX_SIZE 
....................  #endif 
....................  #define USB_EP14_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP14_TX_SIZE 
....................   #error You enabled EP14 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 15 defines ---------- 
.................... #ifndef USB_EP15_TX_ENABLE 
....................  #define USB_EP15_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP15_RX_ENABLE 
....................  #define USB_EP15_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP15_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP15_RX_SIZE 
....................   #undef USB_EP15_RX_SIZE 
....................  #endif 
....................  #define USB_EP15_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP15_RX_SIZE 
....................   #error You enabled EP15 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP15_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP15_TX_SIZE 
....................   #undef USB_EP15_TX_SIZE 
....................  #endif 
....................  #define USB_EP15_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP15_TX_SIZE 
....................   #error You enabled EP15 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... const int8 usb_ep_tx_type[16]={ 
....................   USB_EP0_TX_ENABLE, USB_EP1_TX_ENABLE, USB_EP2_TX_ENABLE, 
....................   USB_EP3_TX_ENABLE, USB_EP4_TX_ENABLE, USB_EP5_TX_ENABLE, 
....................   USB_EP6_TX_ENABLE, USB_EP7_TX_ENABLE, USB_EP8_TX_ENABLE, 
....................   USB_EP9_TX_ENABLE, USB_EP10_TX_ENABLE, USB_EP11_TX_ENABLE, 
....................   USB_EP12_TX_ENABLE, USB_EP13_TX_ENABLE, USB_EP14_TX_ENABLE, 
....................   USB_EP15_TX_ENABLE 
.................... }; 
....................  
.................... const int8 usb_ep_rx_type[16]={ 
....................   USB_EP0_RX_ENABLE, USB_EP1_RX_ENABLE, USB_EP2_RX_ENABLE, 
....................   USB_EP3_RX_ENABLE, USB_EP4_RX_ENABLE, USB_EP5_RX_ENABLE, 
....................   USB_EP6_RX_ENABLE, USB_EP7_RX_ENABLE, USB_EP8_RX_ENABLE, 
....................   USB_EP9_RX_ENABLE, USB_EP10_RX_ENABLE, USB_EP11_RX_ENABLE, 
....................   USB_EP12_RX_ENABLE, USB_EP13_RX_ENABLE, USB_EP14_RX_ENABLE, 
....................   USB_EP15_RX_ENABLE 
.................... }; 
....................  
.................... const int16 usb_ep_tx_size[16]={ 
....................   USB_EP0_TX_SIZE, USB_EP1_TX_SIZE, USB_EP2_TX_SIZE, 
....................   USB_EP3_TX_SIZE, USB_EP4_TX_SIZE, USB_EP5_TX_SIZE, 
....................   USB_EP6_TX_SIZE, USB_EP7_TX_SIZE, USB_EP8_TX_SIZE, 
....................   USB_EP9_TX_SIZE, USB_EP10_TX_SIZE, USB_EP11_TX_SIZE, 
....................   USB_EP12_TX_SIZE, USB_EP13_TX_SIZE, USB_EP14_TX_SIZE, 
....................   USB_EP15_TX_SIZE 
.................... }; 
....................  
.................... const int16 usb_ep_rx_size[16]={ 
....................   USB_EP0_RX_SIZE, USB_EP1_RX_SIZE, USB_EP2_RX_SIZE, 
....................   USB_EP3_RX_SIZE, USB_EP4_RX_SIZE, USB_EP5_RX_SIZE, 
....................   USB_EP6_RX_SIZE, USB_EP7_RX_SIZE, USB_EP8_RX_SIZE, 
....................   USB_EP9_RX_SIZE, USB_EP10_RX_SIZE, USB_EP11_RX_SIZE, 
....................   USB_EP12_RX_SIZE, USB_EP13_RX_SIZE, USB_EP14_RX_SIZE, 
....................   USB_EP15_RX_SIZE 
.................... }; 
....................  
.................... #ENDIF 
....................  
....................  
.................... #define USB_BUFFER_NEEDED (USB_EP0_TX_SIZE+USB_EP0_RX_SIZE+USB_EP1_TX_SIZE+USB_EP1_RX_SIZE+USB_EP2_TX_SIZE+USB_EP2_RX_SIZE+USB_EP3_TX_SIZE+USB_EP3_RX_SIZE+USB_EP4_TX_SIZE+USB_EP4_RX_SIZE+USB_EP5_TX_SIZE+USB_EP5_RX_SIZE+USB_EP6_TX_SIZE+USB_EP6_RX_SIZE+USB_EP7_TX_SIZE+USB_EP7_RX_SIZE+USB_EP8_TX_SIZE+USB_EP8_RX_SIZE+USB_EP9_TX_SIZE+USB_EP9_RX_SIZE+USB_EP10_TX_SIZE+USB_EP10_RX_SIZE+USB_EP11_TX_SIZE+USB_EP11_RX_SIZE+USB_EP12_TX_SIZE+USB_EP12_RX_SIZE+USB_EP13_TX_SIZE+USB_EP13_RX_SIZE+USB_EP14_TX_SIZE+USB_EP14_RX_SIZE+USB_EP15_TX_SIZE+USB_EP15_RX_SIZE) 
....................  
.................... #if (USB_BUFFER_NEEDED > USB_TOTAL_BUFFER_SPACE) 
....................  #error You are trying to allocate more memory for endpoints than the PIC can handle 
.................... #endif 
....................  
.................... #if defined(__USB_4450__) 
....................  #reserve 0x400:0x4FF 
.................... #else 
....................  #reserve 0x400:0x4FF+USB_BUFFER_NEEDED 
.................... #endif 
....................  
.................... #define debug_usb(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z) 
.................... //#define debug_usb printf 
.................... //#define debug_putc putc_tbe 
.................... #define debug_display_ram(x,y) 
.................... /* 
.................... void debug_display_ram(int8 len, int8 *ptr) { 
....................    int8 max=16; 
....................    debug_usb(debug_putc,"%U - ",len); 
....................    if (max>len) {max=len;} 
....................    while(max--) { 
....................       debug_usb(debug_putc,"%X",*ptr); 
....................       len--; 
....................       ptr++; 
....................    } 
....................    if (len) {debug_usb(debug_putc,"...");} 
.................... } 
.................... */ 
....................  
.................... //if you are worried that the PIC is not receiving packets because a bug in the 
.................... //DATA0/DATA1 synch code, you can set this to TRUE to ignore the DTS on 
.................... //receiving. 
.................... #ifndef USB_IGNORE_RX_DTS 
....................  #define USB_IGNORE_RX_DTS FALSE 
.................... #endif 
....................  
.................... #ifndef USB_IGNORE_TX_DTS 
....................  #define USB_IGNORE_TX_DTS FALSE 
.................... #endif 
....................  
.................... //if you enable this it will keep a counter of the 6 possible errors the 
.................... //pic can detect.  disabling this will save you ROM, RAM and execution time. 
.................... #ifndef USB_USE_ERROR_COUNTER 
....................    #define USB_USE_ERROR_COUNTER FALSE 
.................... #endif 
....................  
.................... #define USB_PING_PONG_MODE_OFF   0  //no ping pong 
.................... #define USB_PING_PONG_MODE_E0    1  //ping pong endpoint 0 only 
.................... #define USB_PING_PONG_MODE_ON    2  //ping pong all endpoints 
....................  
.................... //NOTE - PING PONG MODE IS NOT SUPPORTED BY CCS! 
.................... #ifndef USB_PING_PONG_MODE 
....................    #define USB_PING_PONG_MODE USB_PING_PONG_MODE_OFF 
.................... #endif 
....................  
.................... #if USB_USE_ERROR_COUNTER 
....................    int ERROR_COUNTER[6]; 
.................... #endif 
....................  
.................... //---pic18fxx5x memory locations 
.................... #if defined(__USB_4550__) || defined(__USB_4450__) 
....................    #byte UFRML   =  0xF66 
....................    #byte UFRMH   =  0xF67 
....................    #byte UIR     =  0xF68 
....................    #byte UIE     =  0xF69 
....................    #byte UEIR    =  0xF6A 
....................    #byte UEIE    =  0xF6B 
....................    #byte USTAT   =  0xF6C 
....................    #byte UCON    =  0xF6D 
....................    #byte UADDR   =  0xF6E 
....................    #byte UCFG    =  0xF6F 
....................    #define  UEP0_LOC 0xF70 
.................... #else 
....................    #byte UFRML   =  0xF60 
....................    #byte UFRMH   =  0xF61 
....................    #byte UIR     =  0xF62 
....................    #byte UIE     =  0xF5C 
....................    #byte UEIR    =  0xF63 
....................    #byte UEIE    =  0xF5D 
....................    #byte USTAT   =  0xF64 
....................    #byte UCON    =  0xF65 
....................    #byte UADDR   =  0xF5E 
....................    #byte UCFG    =  0xF5F 
....................    #define  UEP0_LOC 0xF4C 
.................... #endif 
....................  
.................... #byte UEP0    =  UEP0_LOC 
....................  
.................... #if defined(__USB_4450__) 
....................  //#define USB_BUFFER (0x400 + (USB_MAX_NUM_ENDPOINTS*8)) //compiler doesnt support this 
....................  #if USB_MAX_NUM_ENDPOINTS==3 
....................   #define USB_BUFFER 0x418   //if you have an old compiler you will need to use this 
....................  #else 
....................   #error Define USB_BUFFER for the number of endpoints you have (0x400 + NUM*0x08) 
....................  #endif 
.................... #else 
....................  #define USB_BUFFER 0x500 
.................... #endif 
....................  
.................... #byte BD0STAT  =  0x400 
.................... #byte BD0CNT  =  0x401 
.................... #byte BD0ADRL  =  0x402 
.................... #byte BD0ADRJ  =  0x403 
....................  
.................... #define BD0STAT_LOC 0x400 
.................... #define BD0CNT_LOC  0x401 
.................... #define BD0ADRL_LOC 0x402 
.................... #define BD0ADRH_LOC 0x403 
....................  
.................... #define UEP(x) *(UEP0_LOC+x) 
....................  
.................... #BIT UIR_SOF = UIR.6 
.................... #BIT UIR_STALL = UIR.5 
.................... #BIT UIR_IDLE = UIR.4 
.................... #BIT UIR_TRN = UIR.3 
.................... #BIT UIR_ACTV = UIR.2 
.................... #BIT UIR_UERR = UIR.1 
.................... #BIT UIR_URST = UIR.0 
....................  
.................... #BIT UIE_SOF = UIE.6 
.................... #BIT UIE_STALL = UIE.5 
.................... #BIT UIE_IDLE = UIE.4 
.................... #BIT UIE_TRN = UIE.3 
.................... #BIT UIE_ACTV = UIE.2 
.................... #BIT UIE_UERR = UIE.1 
.................... #BIT UIE_URST = UIE.0 
....................  
.................... #bit UCON_PBRST=UCON.6 
.................... #bit UCON_SE0=UCON.5 
.................... #bit UCON_PKTDIS=UCON.4 
.................... #bit UCON_USBEN=UCON.3 
.................... #bit UCON_RESUME=UCON.2 
.................... #bit UCON_SUSPND=UCON.1 
....................  
.................... #if (USB_PING_PONG_MODE==USB_PING_PONG_MODE_OFF) 
....................  #define EP_BDxST_O(x)    *(BD0STAT_LOC + x*8) 
....................  #define EP_BDxCNT_O(x)    *(BD0CNT_LOC + x*8) 
....................  #define EP_BDxADR_O(x)   *(int16 *)(BD0ADRL_LOC + x*8) 
....................  #define EP_BDxST_I(x)    *(BD0STAT_LOC + 4 + x*8) 
....................  #define EP_BDxCNT_I(x)    *(BD0CNT_LOC + 4 + x*8) 
....................  #define EP_BDxADR_I(x)   *(int16 *)(BD0ADRL_LOC + 4 + x*8) 
.................... #else 
.................... #error Right now this driver only supports no ping pong 
.................... #endif 
....................  
.................... //See UEPn (0xF70-0xF7F) 
.................... #define ENDPT_DISABLED   0x00   //endpoint not used 
.................... #define ENDPT_IN_ONLY   0x02    //endpoint supports IN transactions only 
.................... #define ENDPT_OUT_ONLY   0x04    //endpoint supports OUT transactions only 
.................... #define ENDPT_CONTROL   0x06    //Supports IN, OUT and CONTROL transactions - Only use with EP0 
.................... #define ENDPT_NON_CONTROL 0x0E  //Supports both IN and OUT transactions 
....................  
.................... //Define the states that the USB interface can be in 
.................... enum {USB_STATE_DETACHED=0, USB_STATE_ATTACHED=1, USB_STATE_POWERED=2, USB_STATE_DEFAULT=3, 
....................     USB_STATE_ADDRESS=4, USB_STATE_CONFIGURED=5} usb_state=0; 
....................  
.................... //--BDendST has their PIDs upshifed 2 
.................... #define USB_PIC_PID_IN       0x24  //device to host transactions 
.................... #define USB_PIC_PID_OUT      0x04  //host to device transactions 
.................... #define USB_PIC_PID_SETUP    0x34  //host to device setup transaction 
....................  
.................... #define USTAT_IN_E0        4 
.................... #define USTAT_OUT_SETUP_E0 0 
....................  
.................... #define __USB_UIF_RESET    0x01 
.................... #define __USB_UIF_ERROR    0x02 
.................... #define __USB_UIF_ACTIVE   0x04 
.................... #define __USB_UIF_TOKEN    0x08 
.................... #define __USB_UIF_IDLE     0x10 
.................... #define __USB_UIF_STALL    0x20 
.................... #define __USB_UIF_SOF      0x40 
....................  
.................... #if USB_USE_ERROR_COUNTER 
....................  #define STANDARD_INTS 0x3F 
.................... #else 
....................  #define STANDARD_INTS 0x3D 
.................... #endif 
....................  
.................... #define __USB_UCFG_UTEYE   0x80 
.................... #if defined(__USB_4550__) 
....................  #define __USB_UCFG_UOEMON  0x40 
.................... #endif 
.................... #define __USB_UCFG_UPUEN   0x10 
.................... #define __USB_UCFG_UTRDIS  0x08 
.................... #define __USB_UCFG_FSEN    0x04 
....................  
.................... #if USB_USE_FULL_SPEED 
....................    #define __UCFG_VAL_ENABLED__ (__USB_UCFG_UPUEN | __USB_UCFG_FSEN | USB_PING_PONG_MODE) 
.................... #else 
....................    #define __UCFG_VAL_ENABLED__ (__USB_UCFG_UPUEN | USB_PING_PONG_MODE); 
.................... #endif 
....................  
.................... #define __UCFG_VAL_DISABLED__ 0x08 
....................  
.................... char usb_ep0_rx_buffer[USB_MAX_EP0_PACKET_LENGTH]; 
.................... #locate usb_ep0_rx_buffer=USB_BUFFER 
....................  
.................... char usb_ep0_tx_buffer[USB_MAX_EP0_PACKET_LENGTH]; 
.................... #locate usb_ep0_tx_buffer=USB_BUFFER+USB_MAX_EP0_PACKET_LENGTH 
....................  
.................... char usb_data_buffer[USB_TOTAL_BUFFER_SPACE-USB_MAX_EP0_PACKET_LENGTH-USB_MAX_EP0_PACKET_LENGTH]; 
.................... #locate usb_data_buffer=USB_BUFFER+USB_MAX_EP0_PACKET_LENGTH+USB_MAX_EP0_PACKET_LENGTH 
....................  
.................... int8 __setup_0_tx_size; 
....................  
.................... //interrupt handler, specific to PIC18Fxx5x peripheral only 
.................... void usb_handle_interrupt(); 
.................... void usb_isr_rst(); 
.................... void usb_isr_uerr(); 
.................... void usb_isr_sof(void); 
.................... void usb_isr_activity(); 
.................... void usb_isr_uidle(); 
.................... void usb_isr_tok_dne(); 
.................... void usb_isr_stall(void); 
.................... void usb_init_ep0_setup(void); 
....................  
.................... //following functions standard part of CCS PIC USB driver, and used by usb.c 
.................... void usb_init(); 
.................... void usb_detach(); 
.................... int1 usb_put_packet(int endpoint, int * ptr, int16 len, USB_DTS_BIT tgl); 
.................... int1 usb_flush_in(int8 endpoint, int16 len, USB_DTS_BIT tgl); //marks the transmit buffer as ready for transmission 
.................... int16 usb_get_packet(int8 endpoint, int8 * ptr, int16 max); 
.................... int16 usb_rx_packet_size(int8 endpoint); 
.................... int16 usb_get_packet_buffer(int8 endpoint, int8 *ptr, int16 max); 
.................... void usb_flush_out(int8 endpoint, USB_DTS_BIT tgl); 
.................... void usb_stall_ep(int8 endpoint); 
.................... void usb_unstall_ep(int8 endpoint); 
.................... int1 usb_endpoint_stalled(int8 endpoint); 
.................... void usb_set_address(int8 address); 
.................... void usb_set_configured(int config); 
.................... void usb_disable_endpoints(void); 
....................  
.................... //// BEGIN User Functions: 
....................  
.................... /****************************************************************************** 
.................... /* usb_attached() 
.................... /* 
.................... /* Summary: Returns TRUE if the device is attached to a USB cable 
.................... /* 
.................... /*****************************************************************************/ 
.................... #if USB_CON_SENSE_PIN 
....................  #define usb_attached() input(USB_CON_SENSE_PIN) 
.................... #else 
....................  #define usb_attached() TRUE 
.................... #endif 
....................  
.................... /****************************************************************************** 
.................... /* usb_detach() 
.................... /* 
.................... /* Summary: Remove the D+/D- lines from the USB bus.  Basically, disable USB. 
.................... /* 
.................... /*****************************************************************************/ 
.................... void usb_detach(void) {  //done 
....................    UCON=0;  //disable USB hardware 
*
2B60:  CLRF   F6D
....................    UIE=0;   //disable USB interrupts 
2B62:  CLRF   F69
....................    UCFG = __UCFG_VAL_DISABLED__; 
2B64:  MOVLW  08
2B66:  MOVWF  F6F
....................    set_tris_c(*0xF94 | 0x30); 
2B68:  MOVF   F94,W
2B6A:  IORLW  30
2B6C:  MOVLB  2
2B6E:  MOVWF  F94
....................    usb_state=USB_STATE_DETACHED; 
2B70:  CLRF   26
2B72:  CLRF   18
2B74:  BTFSC  FF2.7
2B76:  BSF    18.7
2B78:  BCF    FF2.7
....................    usb_token_reset();              //clear the chapter9 stack 
2B7A:  MOVLB  0
2B7C:  CALL   1A6C
2B80:  BTFSC  18.7
2B82:  BSF    FF2.7
....................    __usb_kbhit_status=0; 
2B84:  CLRF   24
2B86:  CLRF   23
.................... } 
2B88:  GOTO   2BD2 (RETURN)
....................  
.................... /****************************************************************************** 
.................... /* usb_attach() 
.................... /* 
.................... /* Summary: Attach the D+/D- lines to the USB bus.  Enable the USB peripheral. 
.................... /* 
.................... /* You should wait until UCON_SE0 is clear before enabling reset/idle interrupt 
.................... /* 
.................... /*****************************************************************************/ 
.................... void usb_attach(void) { 
2B8C:  CLRF   18
2B8E:  BTFSC  FF2.7
2B90:  BSF    18.7
2B92:  BCF    FF2.7
....................    usb_token_reset(); 
2B94:  CALL   1A6C
2B98:  BTFSC  18.7
2B9A:  BSF    FF2.7
....................     UCON = 0; 
2B9C:  CLRF   F6D
....................    UCFG = __UCFG_VAL_ENABLED__; 
2B9E:  MOVLW  14
2BA0:  MOVWF  F6F
....................     UIE = 0;                                // Mask all USB interrupts 
2BA2:  CLRF   F69
....................     UCON_USBEN = 1;                     // Enable module & attach to bus 
2BA4:  BSF    F6D.3
....................     usb_state = USB_STATE_ATTACHED;      // Defined in usbmmap.c & .h 
2BA6:  MOVLW  01
2BA8:  MOVWF  26
.................... } 
2BAA:  GOTO   2BB4 (RETURN)
....................  
.................... /***************************************************************************** 
.................... /* usb_init_cs() 
.................... /* 
.................... /* Summary: Resets and initalizes USB peripheral.  Does not attach the peripheral 
.................... /*          to the USB bus.  See usb_attach() and usb_task() on how to 
.................... /*          attach to the USB bus. 
.................... /* 
.................... /*          You must call this before any other USB code. 
.................... /* 
.................... /*          NOTE: an alternative function, usb_init(), is provided that 
.................... /*                initializes the USB and then connects. 
.................... /* 
.................... /*****************************************************************************/ 
.................... #define usb_init_cs usb_detach 
....................  
.................... /***************************************************************************** 
.................... /* usb_task() 
.................... /* 
.................... /* Summary: Keeps an eye on the connection sense pin to determine if we are 
.................... /*          attached to a USB cable or not.  If we are attached to a USB cable, 
.................... /*          initialize the USB peripheral if needed.  If we are disconnected 
.................... /*          from the USB cable, disable the USB peripheral. 
.................... /* 
.................... /*          NOTE: If you are not using a connection sense pin, will automatically 
.................... /*                enable the USB peripheral. 
.................... /* 
.................... /*          NOTE: this enables interrupts once the USB peripheral is ready 
.................... /* 
.................... /*****************************************************************************/ 
.................... void usb_task(void) { 
....................    if (usb_attached()) { 
....................       if (UCON_USBEN==0) { 
2BAE:  BTFSC  F6D.3
2BB0:  BRA    2BB4
....................          debug_usb(debug_putc, "\r\n\nUSB TASK: ATTACH"); 
....................          usb_attach(); 
2BB2:  BRA    2B8C
....................       } 
....................    } 
....................    else { 
....................       if (UCON_USBEN==1)  { 
....................          debug_usb(debug_putc, "\r\n\nUSB TASK: DE-ATTACH"); 
....................          usb_detach(); 
....................       } 
....................    } 
....................  
....................    if ((usb_state == USB_STATE_ATTACHED)&&(!UCON_SE0)) { 
2BB4:  DECFSZ 26,W
2BB6:  BRA    2BCE
2BB8:  BTFSC  F6D.5
2BBA:  BRA    2BCE
....................       UIR=0; 
2BBC:  CLRF   F68
....................       UIE=0; 
2BBE:  CLRF   F69
....................       enable_interrupts(INT_USB); 
2BC0:  BSF    FA0.5
....................       enable_interrupts(GLOBAL); 
2BC2:  MOVLW  C0
2BC4:  IORWF  FF2,F
....................       UIE=__USB_UIF_IDLE | __USB_UIF_RESET;  //enable IDLE and RESET USB interrupt 
2BC6:  MOVLW  11
2BC8:  MOVWF  F69
....................       usb_state=USB_STATE_POWERED; 
2BCA:  MOVLW  02
2BCC:  MOVWF  26
....................       debug_usb(debug_putc, "\r\n\nUSB TASK: POWERED"); 
....................    } 
.................... } 
2BCE:  RETLW  00
....................  
.................... /***************************************************************************** 
.................... /* usb_init() 
.................... /* 
.................... /* Summary: Resets and initalizes USB hardware.  You must call this first before 
.................... /*          using code.  Will attach the USB periperhal to the USB bus. 
.................... /* 
.................... /*          NOTE: If you are using a connection sense pin, this will wait in 
.................... /*                an infinite loop until the device is connected to a USB cable. 
.................... /* 
.................... /*          NOTE: If you are not using a connection sense pin, this will wait 
.................... /*                in an infinte loop until the SE0 condition clears, which usually 
.................... /*                doesn't take long 
.................... /* 
.................... /*          NOTE: this enables interrupts. 
.................... /* 
.................... /*****************************************************************************/ 
.................... void usb_init(void) { 
....................    usb_init_cs(); 
2BD0:  BRA    2B60
....................  
....................    do { 
....................       usb_task(); 
2BD2:  RCALL  2BAE
....................    } while (usb_state != USB_STATE_POWERED); 
2BD4:  MOVF   26,W
2BD6:  SUBLW  02
2BD8:  BNZ   2BD2
.................... } 
2BDA:  GOTO   445C (RETURN)
....................  
....................  
.................... /************************************************************** 
.................... /* usb_flush_in() 
.................... /* 
.................... /* Input: endpoint - which endpoint to mark for transfer 
.................... /*        len - length of data that is being tramsferred 
.................... /*        tgl - Data toggle synchronization for this packet 
.................... /* 
.................... /* Output: TRUE if success, FALSE if error (we don't control the endpoint) 
.................... /* 
.................... /* Summary: Marks the endpoint ready for transmission.  You must 
.................... /*          have already loaded the endpoint buffer with data. 
.................... /*          (IN is PIC -> PC) 
.................... /***************************************************************/ 
.................... int1 usb_flush_in(int8 endpoint, int16 len, USB_DTS_BIT tgl) { 
....................    int8 i; 
....................  
....................    debug_usb(debug_putc,"\r\nPUT %X %U %LU",endpoint, tgl, len); 
....................  
....................    i=EP_BDxST_I(endpoint); 
*
22D0:  MOVLB  2
22D2:  MOVF   xA6,W
22D4:  MULLW  08
22D6:  MOVF   FF3,W
22D8:  ADDLW  04
22DA:  MOVWF  01
22DC:  MOVLW  04
22DE:  MOVWF  03
22E0:  BTFSC  FD8.0
22E2:  INCF   03,F
22E4:  MOVFF  01,FE9
22E8:  MOVFF  03,FEA
22EC:  MOVFF  FEF,2AA
....................    if (!bit_test(i,7)) { 
22F0:  BTFSC  xAA.7
22F2:  BRA    23AA
....................  
....................       EP_BDxCNT_I(endpoint)=len; 
22F4:  MOVF   xA6,W
22F6:  MULLW  08
22F8:  MOVF   FF3,W
22FA:  ADDLW  05
22FC:  MOVWF  01
22FE:  MOVLW  04
2300:  MOVWF  03
2302:  BTFSC  FD8.0
2304:  INCF   03,F
2306:  MOVFF  01,FE9
230A:  MOVFF  03,FEA
230E:  MOVFF  2A7,FEF
....................  
....................      debug_display_ram(len, EP_BDxADR_I(endpoint)); 
....................  
....................      #if USB_IGNORE_TX_DTS 
....................       i=0x80; 
....................      #else 
....................       if (tgl == USB_DTS_TOGGLE) { 
2312:  MOVF   xA9,W
2314:  SUBLW  02
2316:  BNZ   2344
....................          i=EP_BDxST_I(endpoint); 
2318:  MOVF   xA6,W
231A:  MULLW  08
231C:  MOVF   FF3,W
231E:  ADDLW  04
2320:  MOVWF  01
2322:  MOVLW  04
2324:  MOVWF  03
2326:  BTFSC  FD8.0
2328:  INCF   03,F
232A:  MOVFF  01,FE9
232E:  MOVFF  03,FEA
2332:  MOVFF  FEF,2AA
....................          if (bit_test(i,6)) 
2336:  BTFSS  xAA.6
2338:  BRA    233E
....................             tgl=USB_DTS_DATA0;  //was DATA1, goto DATA0 
233A:  CLRF   xA9
....................          else 
233C:  BRA    2342
....................             tgl=USB_DTS_DATA1;  //was DATA0, goto DATA1 
233E:  MOVLW  01
2340:  MOVWF  xA9
....................       } 
....................       else if (tgl == USB_DTS_USERX) { 
2342:  BRA    236A
2344:  MOVF   xA9,W
2346:  SUBLW  04
2348:  BNZ   236A
....................          i=EP_BDxST_O(endpoint); 
234A:  MOVF   xA6,W
234C:  MULLW  08
234E:  MOVFF  FF3,01
2352:  MOVLW  04
2354:  MOVFF  01,FE9
2358:  MOVWF  FEA
235A:  MOVFF  FEF,2AA
....................          if (bit_test(i,6)) 
235E:  BTFSS  xAA.6
2360:  BRA    2368
....................             tgl=USB_DTS_DATA1; 
2362:  MOVLW  01
2364:  MOVWF  xA9
....................          else 
2366:  BRA    236A
....................             tgl=USB_DTS_DATA0; 
2368:  CLRF   xA9
....................       } 
....................       if (tgl == USB_DTS_DATA1) { 
236A:  DECFSZ xA9,W
236C:  BRA    2374
....................          i=0xC8;  //DATA1, UOWN 
236E:  MOVLW  C8
2370:  MOVWF  xAA
....................       } 
....................       else if (tgl == USB_DTS_DATA0) { 
2372:  BRA    237C
2374:  MOVF   xA9,F
2376:  BNZ   237C
....................          i=0x88; //DATA0, UOWN 
2378:  MOVLW  88
237A:  MOVWF  xAA
....................       } 
....................      #endif 
....................  
....................       //set BC8 and BC9 
....................       if (bit_test(len,8)) {bit_set(i,0);} 
237C:  BTFSC  xA8.0
237E:  BSF    xAA.0
....................       if (bit_test(len,9)) {bit_set(i,1);} 
2380:  BTFSC  xA8.1
2382:  BSF    xAA.1
....................  
....................       debug_usb(debug_putc," %X",i); 
....................  
....................       EP_BDxST_I(endpoint)=i;//save changes 
2384:  MOVF   xA6,W
2386:  MULLW  08
2388:  MOVF   FF3,W
238A:  ADDLW  04
238C:  MOVWF  01
238E:  MOVLW  04
2390:  MOVWF  03
2392:  BTFSC  FD8.0
2394:  INCF   03,F
2396:  MOVFF  01,FE9
239A:  MOVFF  03,FEA
239E:  MOVFF  2AA,FEF
....................  
....................       return(1); 
23A2:  MOVLW  01
23A4:  MOVWF  01
23A6:  BRA    23AE
....................    } 
....................     else { 
23A8:  BRA    23AA
....................          debug_usb(debug_putc,"\r\nPUT ERR"); 
....................     } 
....................    return(0); 
23AA:  MOVLW  00
23AC:  MOVWF  01
.................... } 
23AE:  MOVLB  0
23B0:  RETLW  00
....................  
.................... /******************************************************************************* 
.................... /* usb_put_packet(endpoint,*ptr,len,toggle) 
.................... /* 
.................... /* Input: endpoint - endpoint to send packet to 
.................... /*        ptr - points to data to send 
.................... /*        len - amount of data to send 
.................... /*        toggle - whether to send data with a DATA0 pid, a DATA1 pid, or toggle from the last DATAx pid. 
.................... /* 
.................... /* Output: TRUE if data was sent correctly, FALSE if it was not.  The only reason it will 
.................... /*         return FALSE is if because the TX buffer is still full from the last time you 
.................... /*         tried to send a packet. 
.................... /* 
.................... /* Summary: Sends one packet out the EP to the host.  Notice that there is a difference 
.................... /*          between a packet and a message.  If you wanted to send a 512 byte message you 
.................... /*          would accomplish this by sending 8 64-byte packets, followed by a 0 length packet. 
.................... /*          If the last (or only packet) being sent is less than the max packet size defined 
.................... /*          in your descriptor then you do not need to send a 0 length packet to identify 
.................... /*          an end of message. 
.................... /* 
.................... /*          usb_puts() (provided in usb.c) will send a multi-packet message correctly. 
.................... /* 
.................... /********************************************************************************/ 
.................... int1 usb_put_packet(int8 endpoint, int8 * ptr, int16 len, USB_DTS_BIT tgl) { //done 
....................    int16 j; 
....................    int8 i; 
....................    int8 * buff_add;     
....................  
....................    i=EP_BDxST_I(endpoint); 
*
24BE:  MOVLB  2
24C0:  MOVF   x9B,W
24C2:  MULLW  08
24C4:  MOVF   FF3,W
24C6:  ADDLW  04
24C8:  MOVWF  01
24CA:  MOVLW  04
24CC:  MOVWF  03
24CE:  BTFSC  FD8.0
24D0:  INCF   03,F
24D2:  MOVFF  01,FE9
24D6:  MOVFF  03,FEA
24DA:  MOVFF  FEF,2A3
....................    if (!bit_test(i,7)) { 
24DE:  BTFSC  xA3.7
24E0:  BRA    2564
....................  
....................       buff_add=EP_BDxADR_I(endpoint); 
24E2:  MOVF   x9B,W
24E4:  MULLW  08
24E6:  MOVF   FF3,W
24E8:  ADDLW  06
24EA:  MOVWF  01
24EC:  MOVLW  04
24EE:  MOVWF  03
24F0:  BTFSC  FD8.0
24F2:  INCF   03,F
24F4:  MOVFF  01,FE9
24F8:  MOVFF  03,FEA
24FC:  MOVFF  FEC,03
2500:  MOVF   FED,F
2502:  MOVFF  FEF,2A4
2506:  MOVFF  03,2A5
....................  
....................       for (j=0;j<len;j++) { 
250A:  CLRF   xA2
250C:  CLRF   xA1
250E:  MOVF   xA2,W
2510:  SUBWF  x9F,W
2512:  BNC   2548
2514:  BNZ   251C
2516:  MOVF   x9E,W
2518:  SUBWF  xA1,W
251A:  BC    2548
....................          *buff_add=*ptr; 
251C:  MOVFF  29C,FE9
2520:  MOVFF  29D,FEA
2524:  MOVFF  FEF,2A8
2528:  MOVFF  2A5,FEA
252C:  MOVFF  2A4,FE9
2530:  MOVFF  2A8,FEF
....................          buff_add++; 
2534:  INCF   xA4,F
2536:  BTFSC  FD8.2
2538:  INCF   xA5,F
....................          ptr++; 
253A:  INCF   x9C,F
253C:  BTFSC  FD8.2
253E:  INCF   x9D,F
....................       } 
2540:  INCF   xA1,F
2542:  BTFSC  FD8.2
2544:  INCF   xA2,F
2546:  BRA    250E
....................  
....................       return(usb_flush_in(endpoint, len, tgl)); 
2548:  MOVFF  29B,2A6
254C:  MOVFF  29F,2A8
2550:  MOVFF  29E,2A7
2554:  MOVFF  2A0,2A9
2558:  MOVLB  0
255A:  RCALL  22D0
255C:  MOVF   01,W
255E:  BRA    2568
....................     } 
....................     else { 
2560:  BRA    2562
2562:  MOVLB  2
....................         debug_usb(debug_putc,"\r\nPUT ERR"); 
....................     } 
....................     return(0); 
2564:  MOVLW  00
2566:  MOVWF  01
2568:  MOVLB  0
.................... } 
256A:  RETLW  00
....................  
.................... /// END User Functions 
....................  
....................  
.................... /// BEGIN Hardware layer functions required by USB.C 
....................  
.................... /************************************************************** 
.................... /* usb_flush_out() 
.................... /* 
.................... /* Input: endpoint - which endpoint to mark for transfer 
.................... /*        tgl - Data toggle synchronization to expect in the next packet 
.................... /* 
.................... /* Output: NONE 
.................... /* 
.................... /* Summary: Clears the previously received packet, and then marks this 
.................... /*          endpoint's receive buffer as ready for more data. 
.................... /*          (OUT is PC -> PIC) 
.................... /***************************************************************/ 
.................... void usb_flush_out(int8 endpoint, USB_DTS_BIT tgl) { 
....................    int8 i; 
....................    int16 len; 
....................  
....................      #if USB_IGNORE_RX_DTS 
....................       if (tgl == USB_DTS_STALL) { 
....................          debug_usb(debug_putc, '*'); 
....................          i=0x84; 
....................          EP_BDxST_I(endpoint)=0x84; 
....................          return; 
....................       } 
....................       else 
....................          i=0x80; 
....................      #else 
....................       i=EP_BDxST_O(endpoint); 
*
21E2:  MOVLB  2
21E4:  MOVF   x9A,W
21E6:  MULLW  08
21E8:  MOVFF  FF3,01
21EC:  MOVLW  04
21EE:  MOVFF  01,FE9
21F2:  MOVWF  FEA
21F4:  MOVFF  FEF,29C
....................       if (tgl == USB_DTS_TOGGLE) { 
21F8:  MOVF   x9B,W
21FA:  SUBLW  02
21FC:  BNZ   220A
....................          if (bit_test(i,6)) 
21FE:  BTFSS  x9C.6
2200:  BRA    2206
....................             tgl=USB_DTS_DATA0;  //was DATA1, goto DATA0 
2202:  CLRF   x9B
....................          else 
2204:  BRA    220A
....................             tgl=USB_DTS_DATA1;  //was DATA0, goto DATA1 
2206:  MOVLW  01
2208:  MOVWF  x9B
....................       } 
....................       if (tgl == USB_DTS_STALL) { 
220A:  MOVF   x9B,W
220C:  SUBLW  03
220E:  BNZ   2234
....................          i=0x84; 
2210:  MOVLW  84
2212:  MOVWF  x9C
....................          EP_BDxST_I(endpoint)=0x84; //stall both in and out endpoints 
2214:  MOVF   x9A,W
2216:  MULLW  08
2218:  MOVF   FF3,W
221A:  ADDLW  04
221C:  MOVWF  01
221E:  MOVLW  04
2220:  MOVWF  03
2222:  BTFSC  FD8.0
2224:  INCF   03,F
2226:  MOVFF  01,FE9
222A:  MOVFF  03,FEA
222E:  MOVLW  84
2230:  MOVWF  FEF
....................       } 
....................       else if (tgl == USB_DTS_DATA1) { 
2232:  BRA    2246
2234:  DECFSZ x9B,W
2236:  BRA    223E
....................          i=0xC8;  //DATA1, UOWN 
2238:  MOVLW  C8
223A:  MOVWF  x9C
....................       } 
....................       else if (tgl == USB_DTS_DATA0) { 
223C:  BRA    2246
223E:  MOVF   x9B,F
2240:  BNZ   2246
....................          i=0x88; //DATA0, UOWN 
2242:  MOVLW  88
2244:  MOVWF  x9C
....................       } 
....................      #endif 
....................  
....................    bit_clear(__usb_kbhit_status,endpoint); 
2246:  CLRF   03
2248:  MOVLW  01
224A:  MOVWF  02
224C:  MOVF   x9A,W
224E:  MOVWF  00
2250:  BZ    225C
2252:  BCF    FD8.0
2254:  RLCF   02,F
2256:  RLCF   03,F
2258:  DECFSZ 00,F
225A:  BRA    2252
225C:  MOVF   02,W
225E:  XORLW  FF
2260:  MOVWF  00
2262:  MOVLW  FF
2264:  XORWF  03,F
2266:  MOVF   00,W
2268:  ANDWF  23,F
226A:  MOVF   03,W
226C:  ANDWF  24,F
....................  
....................    len=usb_ep_rx_size[endpoint]; 
226E:  BCF    FD8.0
2270:  RLCF   x9A,W
2272:  CLRF   03
2274:  MOVFF  FF2,29F
2278:  BCF    FF2.7
227A:  MOVLB  0
227C:  CALL   190E
2280:  TBLRD*+
2282:  MOVFF  FF5,03
2286:  MOVLB  2
2288:  BTFSC  x9F.7
228A:  BSF    FF2.7
228C:  MOVWF  x9D
228E:  MOVFF  03,29E
....................    EP_BDxCNT_O(endpoint)=len; 
2292:  MOVF   x9A,W
2294:  MULLW  08
2296:  MOVF   FF3,W
2298:  ADDLW  01
229A:  MOVWF  01
229C:  MOVLW  04
229E:  MOVWF  03
22A0:  BTFSC  FD8.0
22A2:  INCF   03,F
22A4:  MOVFF  01,FE9
22A8:  MOVFF  03,FEA
22AC:  MOVFF  29D,FEF
....................    if (bit_test(len,8)) {bit_set(i,0);} 
22B0:  BTFSC  x9E.0
22B2:  BSF    x9C.0
....................    if (bit_test(len,9)) {bit_set(i,1);} 
22B4:  BTFSC  x9E.1
22B6:  BSF    x9C.1
....................  
....................  
....................    EP_BDxST_O(endpoint)=i; 
22B8:  MOVF   x9A,W
22BA:  MULLW  08
22BC:  MOVFF  FF3,01
22C0:  MOVLW  04
22C2:  MOVFF  01,FE9
22C6:  MOVWF  FEA
22C8:  MOVFF  29C,FEF
.................... } 
22CC:  MOVLB  0
22CE:  RETLW  00
....................  
.................... int16 usb_rx_packet_size(int8 endpoint) { 
....................    return(EP_BDxCNT_O(endpoint)); 
*
2416:  MOVLB  2
2418:  MOVF   x9B,W
241A:  MULLW  08
241C:  MOVF   FF3,W
241E:  ADDLW  01
2420:  MOVWF  01
2422:  MOVLW  04
2424:  MOVWF  03
2426:  BTFSC  FD8.0
2428:  INCF   03,F
242A:  MOVFF  01,FE9
242E:  MOVFF  03,FEA
2432:  CLRF   03
2434:  MOVFF  FEF,01
2438:  MOVFF  03,02
.................... } 
243C:  MOVLB  0
243E:  GOTO   2450 (RETURN)
....................  
.................... /******************************************************************************* 
.................... /* usb_get_packet_buffer(endpoint, *ptr, max) 
.................... /* 
.................... /* Input: endpoint - endpoint to get data from 
.................... /*        ptr - where to save data to local PIC RAM 
.................... /*        max - max amount of data to receive from buffer 
.................... /* 
.................... /* Output: the amount of data taken from the buffer. 
.................... /* 
.................... /* Summary: Gets a packet of data from the USB buffer and puts into local PIC RAM. 
.................... /*          Does not mark the endpoint as ready for more data.  Once you are 
.................... /*          done with data, call usb_flush_out() to mark the endpoint ready 
.................... /*          to receive more data. 
.................... /* 
.................... /********************************************************************************/ 
.................... int16 usb_get_packet_buffer(int8 endpoint, int8 *ptr, int16 max) { 
....................    int8 * al; 
....................    int8 st; 
....................    int16 i; 
....................  
....................    al=EP_BDxADR_O(endpoint); 
....................    i=EP_BDxCNT_O(endpoint); 
....................    st=EP_BDxST_O(endpoint); 
....................  
....................    //read BC8 and BC9 
....................    if (bit_test(st,0)) {bit_set(i,8);} 
....................    if (bit_test(st,1)) {bit_set(i,9);} 
....................  
....................    if (i<max) {max=i;} 
....................  
....................    i=0; 
....................  
....................    while (i<max) { 
....................        *ptr=*al; 
....................        ptr++; 
....................        al++; 
....................        i++; 
....................    } 
....................  
....................    return(max); 
.................... } 
....................  
.................... /******************************************************************************* 
.................... /* usb_get_packet(endpoint, *ptr, max) 
.................... /* 
.................... /* Input: endpoint - endpoint to get data from 
.................... /*        ptr - where to save data to local PIC RAM 
.................... /*        max - max amount of data to receive from buffer 
.................... /* 
.................... /* Output: the amount of data taken from the buffer. 
.................... /* 
.................... /*         NOTE - IF THERE IS NO PACKET TO GET YOU WILL GET INVALID RESULTS! 
.................... /*                VERIFY WITH USB_KBHIT() BEFORE YOU CALL USB_GET_PACKET()! 
.................... /* 
.................... /* Summary: Gets a packet of data from the USB buffer and puts into local PIC RAM. 
.................... /*          Until you call usb_get_packet() the data will sit in the endpoint 
.................... /*          buffer and the PC will get NAKs when it tries to write more data 
.................... /*          to the endpoint. 
.................... /* 
.................... /********************************************************************************/ 
.................... int16 usb_get_packet(int8 endpoint, int8 * ptr, int16 max) { 
....................  
....................    max=usb_get_packet_buffer(endpoint,ptr,max); 
....................    usb_flush_out(endpoint, USB_DTS_TOGGLE); 
....................  
....................    return(max); 
.................... } 
....................  
.................... /******************************************************************************* 
.................... /* usb_tbe(endpoint) 
.................... /* 
.................... /* Input: endpoint - endpoint to check 
.................... /*        ptr - where to save data to local PIC RAM 
.................... /*        max - max amount of data to receive from buffer 
.................... /* 
.................... /* Output: returns TRUE if this endpoint's IN buffer (PIC-PC) is empty and ready 
.................... /*         returns FALSE if this endpoint's IN buffer is still processing the last 
.................... /*         transmit or if this endpoint is invalid. 
.................... /* 
.................... /********************************************************************************/ 
.................... int8 usb_tbe(int8 endpoint) { 
....................    int8 st; 
....................    st=EP_BDxST_I(endpoint); 
....................    if (!bit_test(st,7)) 
....................       return(TRUE); 
....................    return(FALSE); 
.................... } 
....................  
.................... /******************************************************************************* 
.................... /* usb_stall_ep(endpoint,direction) 
.................... /* 
.................... /* Input: endpoint - endpoint to stall. 
.................... /*                   top most bit indicates direction (set is IN, clear is OUT) 
.................... /* 
.................... /* Summary: Stalls specified endpoint.  If endpoint is stalled it will send STALL packet 
.................... /*          if the host tries to access this endpoint's buffer. 
.................... /* 
.................... /* 
.................... /* NOTE: WE ASSUME ENDPOINT IS VALID.  USB.C SHOULD CHECK THIS 
.................... /* 
.................... /********************************************************************************/ 
.................... void usb_stall_ep(int8 endpoint) {  //done 
....................    int1 direction; 
....................    direction=bit_test(endpoint,7); 
*
1FFA:  MOVLB  2
1FFC:  BCF    x9B.0
1FFE:  BTFSC  x9A.7
2000:  BSF    x9B.0
....................    endpoint&=0x7F; 
2002:  BCF    x9A.7
....................    if (direction) { 
2004:  BTFSS  x9B.0
2006:  BRA    2028
....................       EP_BDxST_I(endpoint)=0x84; 
2008:  MOVF   x9A,W
200A:  MULLW  08
200C:  MOVF   FF3,W
200E:  ADDLW  04
2010:  MOVWF  01
2012:  MOVLW  04
2014:  MOVWF  03
2016:  BTFSC  FD8.0
2018:  INCF   03,F
201A:  MOVFF  01,FE9
201E:  MOVFF  03,FEA
2022:  MOVLW  84
2024:  MOVWF  FEF
....................    } 
....................    else { 
2026:  BRA    203C
....................       EP_BDxST_O(endpoint)=0x84; 
2028:  MOVF   x9A,W
202A:  MULLW  08
202C:  MOVFF  FF3,01
2030:  MOVLW  04
2032:  MOVFF  01,FE9
2036:  MOVWF  FEA
2038:  MOVLW  84
203A:  MOVWF  FEF
....................    } 
.................... } 
203C:  MOVLB  0
203E:  GOTO   20CE (RETURN)
....................  
.................... /******************************************************************************* 
.................... /* usb_unstall_ep(endpoint, direction) 
.................... /* 
.................... /* Input: endpoint - endpoint to un-stall. 
.................... /*                   top most bit indicates direction (set is IN, clear is OUT) 
.................... /* 
.................... /* Summary: Un-stalls endpoint. 
.................... /* 
.................... /* NOTE: WE ASSUME ENDPOINT IS VALID.  USB.C SHOULD CHECK THIS 
.................... /********************************************************************************/ 
.................... void usb_unstall_ep(int8 endpoint) {   //done 
....................    int1 direction; 
....................    direction=bit_test(endpoint,7); 
*
1FB4:  MOVLB  2
1FB6:  BCF    x9B.0
1FB8:  BTFSC  x9A.7
1FBA:  BSF    x9B.0
....................    endpoint&=0x7F; 
1FBC:  BCF    x9A.7
....................    if (direction) { 
1FBE:  BTFSS  x9B.0
1FC0:  BRA    1FE2
....................       #if USB_IGNORE_RX_DTS 
....................       EP_BDxST_I(endpoint)=0x80; 
....................       #else 
....................       EP_BDxST_I(endpoint)=0x88; 
1FC2:  MOVF   x9A,W
1FC4:  MULLW  08
1FC6:  MOVF   FF3,W
1FC8:  ADDLW  04
1FCA:  MOVWF  01
1FCC:  MOVLW  04
1FCE:  MOVWF  03
1FD0:  BTFSC  FD8.0
1FD2:  INCF   03,F
1FD4:  MOVFF  01,FE9
1FD8:  MOVFF  03,FEA
1FDC:  MOVLW  88
1FDE:  MOVWF  FEF
....................       #endif 
....................    } 
....................    else { 
1FE0:  BRA    1FF4
....................       EP_BDxST_O(endpoint)=0x00; 
1FE2:  MOVF   x9A,W
1FE4:  MULLW  08
1FE6:  MOVFF  FF3,01
1FEA:  MOVLW  04
1FEC:  MOVFF  01,FE9
1FF0:  MOVWF  FEA
1FF2:  CLRF   FEF
....................    } 
.................... } 
1FF4:  MOVLB  0
1FF6:  GOTO   20BE (RETURN)
....................  
.................... /******************************************************************************* 
.................... /* usb_endpoint_stalled(endpoint) 
.................... /* 
.................... /* Input: endpoint - endpoint to check 
.................... /*                   top most bit indicates direction (set is IN, clear is OUT) 
.................... /* 
.................... /* Output: returns a TRUE if endpoint is stalled, FALSE if it is not. 
.................... /* 
.................... /* Summary: Looks to see if an endpoint is stalled, or not.  Does not look to 
.................... /*          see if endpoint has been issued a STALL, just whether or not it is 
.................... /*          configured to STALL on the next packet.  See Set_Feature and Clear_Feature 
.................... /*          Chapter 9 requests. 
.................... /* 
.................... /* NOTE: WE ASSUME ENDPOINT IS VALID.  USB.C SHOULD CHECK THIS 
.................... /********************************************************************************/ 
.................... int1 usb_endpoint_stalled(int8 endpoint) {   //done 
....................    int1 direction; 
....................    int8 st; 
....................    direction=bit_test(endpoint,7); 
*
2042:  MOVLB  2
2044:  BCF    x9B.0
2046:  BTFSC  x9A.7
2048:  BSF    x9B.0
....................    endpoint&=0x7F; 
204A:  BCF    x9A.7
....................    if (direction) { 
204C:  BTFSS  x9B.0
204E:  BRA    2070
....................       st=EP_BDxST_I(endpoint); 
2050:  MOVF   x9A,W
2052:  MULLW  08
2054:  MOVF   FF3,W
2056:  ADDLW  04
2058:  MOVWF  01
205A:  MOVLW  04
205C:  MOVWF  03
205E:  BTFSC  FD8.0
2060:  INCF   03,F
2062:  MOVFF  01,FE9
2066:  MOVFF  03,FEA
206A:  MOVFF  FEF,29C
....................    } 
....................    else { 
206E:  BRA    2084
....................       st=EP_BDxST_O(endpoint); 
2070:  MOVF   x9A,W
2072:  MULLW  08
2074:  MOVFF  FF3,01
2078:  MOVLW  04
207A:  MOVFF  01,FE9
207E:  MOVWF  FEA
2080:  MOVFF  FEF,29C
....................    } 
....................    return(bit_test(st,7) && bit_test(st,2)); 
2084:  BTFSS  x9C.7
2086:  BRA    208C
2088:  BTFSC  x9C.2
208A:  BRA    2090
208C:  MOVLW  00
208E:  BRA    2092
2090:  MOVLW  01
2092:  MOVWF  01
.................... } 
2094:  MOVLB  0
2096:  GOTO   20E6 (RETURN)
....................  
....................  
.................... /******************************************************************************* 
.................... /* usb_set_address(address) 
.................... /* 
.................... /* Input: address - address the host specified that we use 
.................... /* 
.................... /* Summary: Configures the USB Peripheral for the specified device address.  The host 
.................... /*          will now talk to use with the following address. 
.................... /* 
.................... /********************************************************************************/ 
.................... void usb_set_address(int8 address) {   //done 
....................    UADDR=address; 
*
2496:  MOVFF  29B,F6E
....................    if (address) { 
249A:  MOVLB  2
249C:  MOVF   x9B,F
249E:  BZ    24A6
....................       usb_state=USB_STATE_ADDRESS; 
24A0:  MOVLW  04
24A2:  MOVWF  26
....................    } 
....................    else { 
24A4:  BRA    24AA
....................       usb_state=USB_STATE_POWERED; 
24A6:  MOVLW  02
24A8:  MOVWF  26
....................    } 
.................... } 
24AA:  MOVLB  0
24AC:  GOTO   24BA (RETURN)
....................  
....................  
.................... /******************************************************************************* 
.................... /* usb_set_configured(config) 
.................... /* 
.................... /* Input: config - Configuration to use.  0 to uncofigure device. 
.................... /* 
.................... /* Summary: Configures or unconfigures device.  If configuring device it will 
.................... /*          enable all the endpoints the user specified for this configuration. 
.................... /*          If un-configuring device it will disable all endpoints. 
.................... /* 
.................... /*          NOTE: CCS only provides code to handle 1 configuration. 
.................... /* 
.................... /********************************************************************************/ 
.................... void usb_set_configured(int config) { 
....................    int8 en; 
....................    int16 addy; 
....................    int8 new_uep; 
....................    int16 len; 
....................    int8 i; 
....................       if (config==0) { 
*
1C4C:  MOVLB  2
1C4E:  MOVF   x9A,F
1C50:  BNZ   1C5E
....................          //if config=0 then set addressed state 
....................          usb_state=USB_STATE_ADDRESS; 
1C52:  MOVLW  04
1C54:  MOVWF  26
....................          usb_disable_endpoints(); 
1C56:  MOVLB  0
1C58:  RCALL  1A98
....................       } 
....................       else { 
1C5A:  BRA    1DF8
1C5C:  MOVLB  2
....................          usb_state=USB_STATE_CONFIGURED; //else set configed state 
1C5E:  MOVLW  05
1C60:  MOVWF  26
....................          addy=(int16)USB_BUFFER+(2*USB_MAX_EP0_PACKET_LENGTH); 
1C62:  MOVWF  x9D
1C64:  MOVLW  80
1C66:  MOVWF  x9C
....................          for (en=1;en<16;en++) { 
1C68:  MOVLW  01
1C6A:  MOVWF  x9B
1C6C:  MOVF   x9B,W
1C6E:  SUBLW  0F
1C70:  BTFSS  FD8.0
1C72:  BRA    1DF8
....................             new_uep=0; 
1C74:  CLRF   x9E
....................             if (usb_ep_rx_type[en]!=USB_ENABLE_DISABLED) { 
1C76:  CLRF   03
1C78:  MOVF   x9B,W
1C7A:  MOVFF  FF2,2A2
1C7E:  BCF    FF2.7
1C80:  MOVLB  0
1C82:  RCALL  18BE
1C84:  MOVLB  2
1C86:  BTFSC  xA2.7
1C88:  BSF    FF2.7
1C8A:  XORLW  00
1C8C:  BZ    1D38
....................                new_uep=0x04; 
1C8E:  MOVLW  04
1C90:  MOVWF  x9E
....................                len=usb_ep_rx_size[en]; 
1C92:  BCF    FD8.0
1C94:  RLCF   x9B,W
1C96:  CLRF   03
1C98:  MOVFF  FF2,2A2
1C9C:  BCF    FF2.7
1C9E:  MOVLB  0
1CA0:  RCALL  190E
1CA2:  TBLRD*+
1CA4:  MOVFF  FF5,03
1CA8:  MOVLB  2
1CAA:  BTFSC  xA2.7
1CAC:  BSF    FF2.7
1CAE:  MOVWF  x9F
1CB0:  MOVFF  03,2A0
....................                EP_BDxCNT_O(en)=len; 
1CB4:  MOVF   x9B,W
1CB6:  MULLW  08
1CB8:  MOVF   FF3,W
1CBA:  ADDLW  01
1CBC:  MOVWF  01
1CBE:  MOVLW  04
1CC0:  MOVWF  03
1CC2:  BTFSC  FD8.0
1CC4:  INCF   03,F
1CC6:  MOVFF  01,FE9
1CCA:  MOVFF  03,FEA
1CCE:  MOVFF  29F,FEF
....................                EP_BDxADR_O(en)=addy; 
1CD2:  MOVF   x9B,W
1CD4:  MULLW  08
1CD6:  MOVF   FF3,W
1CD8:  ADDLW  02
1CDA:  MOVWF  01
1CDC:  MOVLW  04
1CDE:  MOVWF  03
1CE0:  BTFSC  FD8.0
1CE2:  INCF   03,F
1CE4:  MOVFF  01,FE9
1CE8:  MOVFF  03,FEA
1CEC:  MOVFF  29D,FEC
1CF0:  MOVF   FED,F
1CF2:  MOVFF  29C,FEF
....................                addy+=usb_ep_rx_size[en]; 
1CF6:  BCF    FD8.0
1CF8:  RLCF   x9B,W
1CFA:  CLRF   03
1CFC:  MOVFF  FF2,2A2
1D00:  BCF    FF2.7
1D02:  MOVLB  0
1D04:  RCALL  190E
1D06:  TBLRD*+
1D08:  MOVFF  FF5,03
1D0C:  MOVLB  2
1D0E:  BTFSC  xA2.7
1D10:  BSF    FF2.7
1D12:  ADDWF  x9C,F
1D14:  MOVF   03,W
1D16:  ADDWFC x9D,F
....................                #if USB_IGNORE_RX_DTS 
....................                   i=0x80; 
....................                #else 
....................                   i=0x88; 
1D18:  MOVLW  88
1D1A:  MOVWF  xA1
....................                #endif 
....................                if (bit_test(len,8)) {bit_set(i,0);} 
1D1C:  BTFSC  xA0.0
1D1E:  BSF    xA1.0
....................                if (bit_test(len,9)) {bit_set(i,1);} 
1D20:  BTFSC  xA0.1
1D22:  BSF    xA1.1
....................                EP_BDxST_O(en)=i; 
1D24:  MOVF   x9B,W
1D26:  MULLW  08
1D28:  MOVFF  FF3,01
1D2C:  MOVLW  04
1D2E:  MOVFF  01,FE9
1D32:  MOVWF  FEA
1D34:  MOVFF  2A1,FEF
....................             } 
....................             if (usb_ep_tx_type[en]!=USB_ENABLE_DISABLED) { 
1D38:  CLRF   03
1D3A:  MOVF   x9B,W
1D3C:  MOVFF  FF2,2A2
1D40:  BCF    FF2.7
1D42:  MOVLB  0
1D44:  RCALL  189E
1D46:  MOVLB  2
1D48:  BTFSC  xA2.7
1D4A:  BSF    FF2.7
1D4C:  XORLW  00
1D4E:  BZ    1DB6
....................                new_uep|=0x02; 
1D50:  BSF    x9E.1
....................                EP_BDxADR_I(en)=addy; 
1D52:  MOVF   x9B,W
1D54:  MULLW  08
1D56:  MOVF   FF3,W
1D58:  ADDLW  06
1D5A:  MOVWF  01
1D5C:  MOVLW  04
1D5E:  MOVWF  03
1D60:  BTFSC  FD8.0
1D62:  INCF   03,F
1D64:  MOVFF  01,FE9
1D68:  MOVFF  03,FEA
1D6C:  MOVFF  29D,FEC
1D70:  MOVF   FED,F
1D72:  MOVFF  29C,FEF
....................                addy+=usb_ep_tx_size[en]; 
1D76:  BCF    FD8.0
1D78:  RLCF   x9B,W
1D7A:  CLRF   03
1D7C:  MOVFF  FF2,2A2
1D80:  BCF    FF2.7
1D82:  MOVLB  0
1D84:  RCALL  18DE
1D86:  TBLRD*+
1D88:  MOVFF  FF5,03
1D8C:  MOVLB  2
1D8E:  BTFSC  xA2.7
1D90:  BSF    FF2.7
1D92:  ADDWF  x9C,F
1D94:  MOVF   03,W
1D96:  ADDWFC x9D,F
....................                EP_BDxST_I(en)=0x40; 
1D98:  MOVF   x9B,W
1D9A:  MULLW  08
1D9C:  MOVF   FF3,W
1D9E:  ADDLW  04
1DA0:  MOVWF  01
1DA2:  MOVLW  04
1DA4:  MOVWF  03
1DA6:  BTFSC  FD8.0
1DA8:  INCF   03,F
1DAA:  MOVFF  01,FE9
1DAE:  MOVFF  03,FEA
1DB2:  MOVLW  40
1DB4:  MOVWF  FEF
....................             } 
....................             if (new_uep==0x06) {new_uep=0x0E;} 
1DB6:  MOVF   x9E,W
1DB8:  SUBLW  06
1DBA:  BNZ   1DC0
1DBC:  MOVLW  0E
1DBE:  MOVWF  x9E
....................             if (usb_ep_tx_type[en]!=USB_ENABLE_ISOCHRONOUS) { 
1DC0:  CLRF   03
1DC2:  MOVF   x9B,W
1DC4:  MOVFF  FF2,2A2
1DC8:  BCF    FF2.7
1DCA:  MOVLB  0
1DCC:  RCALL  189E
1DCE:  MOVLB  2
1DD0:  BTFSC  xA2.7
1DD2:  BSF    FF2.7
1DD4:  SUBLW  02
1DD6:  BZ    1DDA
....................                new_uep|=0x10; 
1DD8:  BSF    x9E.4
....................             } 
....................             UEP(en)=new_uep; 
1DDA:  MOVLW  70
1DDC:  ADDWF  x9B,W
1DDE:  MOVWF  01
1DE0:  MOVLW  0F
1DE2:  MOVWF  03
1DE4:  BTFSC  FD8.0
1DE6:  INCF   03,F
1DE8:  MOVFF  01,FE9
1DEC:  MOVFF  03,FEA
1DF0:  MOVFF  29E,FEF
....................          } 
1DF4:  INCF   x9B,F
1DF6:  BRA    1C6C
1DF8:  MOVLB  0
....................       } 
.................... } 
1DFA:  GOTO   1E9E (RETURN)
....................  
.................... /// END Hardware layer functions required by USB.C 
....................  
....................  
.................... /// BEGIN USB Interrupt Service Routine 
....................  
.................... /******************************************************************************* 
.................... /* usb_handle_interrupt() 
.................... /* 
.................... /* Summary: Checks the interrupt, and acts upon event.  Processing finished 
.................... /*          tokens is the majority of this code, and is handled by usb.c 
.................... /* 
.................... /* NOTE: If you wish to change to a polling method (and not an interrupt method), 
.................... /*       then you must call this function rapidly.  If there is more than 10ms 
.................... /*       latency the PC may think the USB device is stalled and disable it. 
.................... /*       To switch to a polling method, remove the #int_usb line above this fuction. 
.................... /*       Also, goto usb_init() and remove the code that enables the USB interrupt. 
.................... /********************************************************************************/ 
.................... #int_usb 
.................... void usb_isr() { 
....................    if (usb_state==USB_STATE_DETACHED) return;   //should never happen, though 
*
26C0:  MOVF   26,F
26C2:  BNZ   26C6
26C4:  BRA    2724
....................    if (UIR) { 
26C6:  MOVF   F68,F
26C8:  BZ    2724
....................       debug_usb(debug_putc,"\r\n\n[%X] ",UIR); 
....................       if (UIR_ACTV && UIE_ACTV) {usb_isr_activity();}  //activity detected.  (only enable after sleep) 
26CA:  BTFSS  F68.2
26CC:  BRA    26D6
26CE:  BTFSS  F69.2
26D0:  BRA    26D6
26D2:  GOTO   1A36
....................  
....................       if (UCON_SUSPND) return; 
26D6:  BTFSS  F6D.1
26D8:  BRA    26DC
26DA:  BRA    2724
....................  
....................       if (UIR_UERR && UIE_UERR) {usb_isr_uerr();}          //error has been detected 
26DC:  BTFSS  F68.1
26DE:  BRA    26E8
26E0:  BTFSS  F69.1
26E2:  BRA    26E8
26E4:  GOTO   1A40
....................  
....................       if (UIR_URST && UIE_URST) {usb_isr_rst();}        //usb reset has been detected 
26E8:  BTFSS  F68.0
26EA:  BRA    26F4
26EC:  BTFSS  F69.0
26EE:  BRA    26F4
26F0:  GOTO   1AE6
....................  
....................       if (UIR_IDLE && UIE_IDLE) {usb_isr_uidle();}        //idle time, we can go to sleep 
26F4:  BTFSS  F68.4
26F6:  BRA    2700
26F8:  BTFSS  F69.4
26FA:  BRA    2700
26FC:  GOTO   1B10
....................       if (UIR_SOF && UIE_SOF) {usb_isr_sof();} 
2700:  BTFSS  F68.6
2702:  BRA    270C
2704:  BTFSS  F69.6
2706:  BRA    270C
2708:  GOTO   1B1A
....................       if (UIR_STALL && UIE_STALL) {usb_isr_stall();}        //a stall handshake was sent 
270C:  BTFSS  F68.5
270E:  BRA    2718
2710:  BTFSS  F69.5
2712:  BRA    2718
2714:  GOTO   1B20
....................  
....................       if (UIR_TRN && UIE_TRN) { 
2718:  BTFSS  F68.3
271A:  BRA    2724
271C:  BTFSS  F69.3
271E:  BRA    2724
....................          usb_isr_tok_dne(); 
2720:  BRA    25D0
....................          UIR_TRN=0;    // clear the token done interrupt., 0x190.3 
2722:  BCF    F68.3
....................       }    //a token has been detected (majority of isrs) 
....................    } 
.................... } 
....................  
.................... //SOF interrupt not handled.  user must add this depending on application 
2724:  BCF    FA1.5
2726:  GOTO   1858
.................... void usb_isr_sof(void) { 
....................    debug_usb(debug_putc,"\r\nSOF"); 
....................    UIR_SOF=0; 
*
1B1A:  BCF    F68.6
.................... } 
1B1C:  GOTO   270C (RETURN)
....................  
.................... /******************************************************************************* 
.................... /* usb_disable_endpoints() 
.................... /* 
.................... /* Summary: Disables endpoints 1 thru 15 
.................... /* 
.................... /********************************************************************************/ 
.................... void usb_disable_endpoints(void) { 
....................    int8 i; 
....................    for (i=1;i<16;i++) { 
*
1A98:  MOVLW  01
1A9A:  MOVLB  2
1A9C:  MOVWF  xA2
1A9E:  MOVF   xA2,W
1AA0:  SUBLW  0F
1AA2:  BNC   1AC0
....................       UEP(i)=ENDPT_DISABLED; 
1AA4:  MOVLW  70
1AA6:  ADDWF  xA2,W
1AA8:  MOVWF  01
1AAA:  MOVLW  0F
1AAC:  MOVWF  03
1AAE:  BTFSC  FD8.0
1AB0:  INCF   03,F
1AB2:  MOVFF  01,FE9
1AB6:  MOVFF  03,FEA
1ABA:  CLRF   FEF
....................    } 
1ABC:  INCF   xA2,F
1ABE:  BRA    1A9E
....................    __usb_kbhit_status=0; 
1AC0:  CLRF   24
1AC2:  CLRF   23
.................... } 
1AC4:  MOVLB  0
1AC6:  RETLW  00
....................  
.................... /******************************************************************************* 
.................... /* usb_isr_rst() 
.................... /* 
.................... /* Summary: The host (computer) sent us a RESET command.  Reset USB device 
.................... /*          and token handler code to initial state. 
.................... /* 
.................... /********************************************************************************/ 
.................... void usb_isr_rst() { 
....................    debug_usb(debug_putc,"R"); 
....................  
....................    UEIR=0; 
*
1AE6:  CLRF   F6A
....................    UIR=0; 
1AE8:  CLRF   F68
....................    UEIE=0x9F; 
1AEA:  MOVLW  9F
1AEC:  MOVWF  F6B
....................    UIE=STANDARD_INTS & ~__USB_UIF_ACTIVE; 
1AEE:  MOVLW  39
1AF0:  MOVWF  F69
....................  
....................    UADDR=0; 
1AF2:  CLRF   F6E
....................  
....................    usb_token_reset(); 
1AF4:  RCALL  1A6C
....................  
....................    usb_disable_endpoints(); 
1AF6:  RCALL  1A98
....................  
....................    UEP(0)=ENDPT_CONTROL | 0x10; 
1AF8:  MOVLW  16
1AFA:  MOVWF  F70
....................  
....................    while (UIR_TRN) { 
1AFC:  BTFSS  F68.3
1AFE:  BRA    1B04
....................       UIR_TRN=0;    //do this to clear out the ustat fifo 
1B00:  BCF    F68.3
....................    } 
1B02:  BRA    1AFC
....................  
....................    UCON_PKTDIS=0; //SIE token and packet processing enabled 
1B04:  BCF    F6D.4
....................  
....................    usb_init_ep0_setup(); 
1B06:  RCALL  1AC8
....................  
....................    usb_state=USB_STATE_DEFAULT; //put usb mcu into default state 
1B08:  MOVLW  03
1B0A:  MOVWF  26
.................... } 
1B0C:  GOTO   26F4 (RETURN)
....................  
.................... /***************************************************************************** 
.................... /* usb_init_ep0_setup() 
.................... /* 
.................... /* Summary: Configure EP0 to receive setup packets 
.................... /* 
.................... /*****************************************************************************/ 
.................... void usb_init_ep0_setup(void) { 
....................     EP_BDxCNT_O(0) = USB_MAX_EP0_PACKET_LENGTH; 
*
1AC8:  MOVLW  40
1ACA:  MOVLB  4
1ACC:  MOVWF  x01
....................     EP_BDxADR_O(0) = USB_BUFFER; 
1ACE:  MOVLW  05
1AD0:  MOVWF  x03
1AD2:  CLRF   x02
....................    #if USB_IGNORE_RX_DTS 
....................     EP_BDxST_O(0) = 0x80; //give control to SIE, data toggle synch off 
....................    #else 
....................     EP_BDxST_O(0) = 0x88; //give control to SIE, DATA0, data toggle synch on 
1AD4:  MOVLW  88
1AD6:  MOVWF  x00
....................    #endif 
....................  
....................     EP_BDxST_I(0) = 0; 
1AD8:  CLRF   x04
....................     EP_BDxADR_I(0) = USB_BUFFER + (int16)USB_MAX_EP0_PACKET_LENGTH; 
1ADA:  MOVLW  05
1ADC:  MOVWF  x07
1ADE:  MOVLW  40
1AE0:  MOVWF  x06
.................... } 
1AE2:  MOVLB  0
1AE4:  RETLW  00
....................  
.................... /******************************************************************************* 
.................... /* usb_isr_uerr() 
.................... /* 
.................... /* Summary: The USB peripheral had an error.  If user specified, error counter 
.................... /*          will incerement.  If having problems check the status of these 8 bytes. 
.................... /* 
.................... /* NOTE: This code is not enabled by default. 
.................... /********************************************************************************/ 
.................... void usb_isr_uerr() { 
.................... #if USB_USE_ERROR_COUNTER 
....................    int ints; 
.................... #endif 
....................  
....................    debug_usb(debug_putc,"E %X ",UEIR); 
....................  
.................... #if USB_USE_ERROR_COUNTER 
....................  
....................    ints=UEIR & UEIE; //mask off the flags with the ones that are enabled 
....................  
....................    if ( bit_test(ints,0) ) { //increment pid_error counter 
....................       debug_usb(debug_putc,"PID "); 
....................       ERROR_COUNTER[0]++; 
....................    } 
....................  
....................    if ( bit_test(ints,1) ) {  //increment crc5 error counter 
....................       debug_usbdebug_putc,"CRC5 "); 
....................       ERROR_COUNTER[1]++; 
....................    } 
....................  
....................    if ( bit_test(ints,2) ) {  //increment crc16 error counter 
....................       debug_usb(debug_putc,"CRC16 "); 
....................       ERROR_COUNTER[2]++; 
....................    } 
....................  
....................    if ( bit_test(ints,3) ) {  //increment dfn8 error counter 
....................       debug_usb(debug_putc,"DFN8 "); 
....................       ERROR_COUNTER[3]++; 
....................    } 
....................  
....................    if ( bit_test(ints,4) ) {  //increment bto error counter 
....................       debug_usb(debug_putc,"BTO "); 
....................       ERROR_COUNTER[4]++; 
....................    } 
....................  
....................    if ( bit_test(ints,7) ) { //increment bts error counter 
....................       debug_usb(debug_putc,"BTS "); 
....................       ERROR_COUNTER[5]++; 
....................    } 
.................... #endif 
....................  
....................    UEIR=0; 
*
1A40:  CLRF   F6A
....................    UIR_UERR=0; 
1A42:  BCF    F68.1
.................... } 
1A44:  GOTO   26E8 (RETURN)
....................  
.................... /******************************************************************************* 
.................... /* usb_isr_uidle() 
.................... /* 
.................... /* Summary: USB peripheral detected IDLE.  Put the USB peripheral to sleep. 
.................... /* 
.................... /********************************************************************************/ 
.................... void usb_isr_uidle() { 
....................    debug_usb(debug_putc,"I"); 
....................  
....................    UIE_ACTV=1;   //enable activity interrupt flag. (we are now suspended until we get an activity interrupt. nice) 
*
1B10:  BSF    F69.2
....................    UIR_IDLE=0; //clear idle interrupt flag 
1B12:  BCF    F68.4
....................    UCON_SUSPND=1; //set suspend. we are now suspended 
1B14:  BSF    F6D.1
.................... } 
1B16:  GOTO   2700 (RETURN)
....................  
....................  
.................... /******************************************************************************* 
.................... /* usb_isr_activity() 
.................... /* 
.................... /* Summary: USB peripheral detected activity on the USB device.  Wake-up the USB 
.................... /*          peripheral. 
.................... /* 
.................... /********************************************************************************/ 
.................... void usb_isr_activity() { 
....................    debug_usb(debug_putc,"A"); 
....................  
....................    UCON_SUSPND=0; //turn off low power suspending 
*
1A36:  BCF    F6D.1
....................    UIE_ACTV=0; //clear activity interupt enabling 
1A38:  BCF    F69.2
....................    UIR_ACTV=0; 
1A3A:  BCF    F68.2
.................... } 
1A3C:  GOTO   26D6 (RETURN)
....................  
.................... /******************************************************************************* 
.................... /* usb_isr_stall() 
.................... /* 
.................... /* Summary: Stall handshake detected. 
.................... /* 
.................... /********************************************************************************/ 
.................... void usb_isr_stall(void) { 
....................    debug_usb(debug_putc,"S"); 
....................  
....................    if (bit_test(UEP(0),0)) { 
*
1B20:  BTFSS  F70.0
1B22:  BRA    1B28
....................       usb_init_ep0_setup(); 
1B24:  RCALL  1AC8
....................       bit_clear(UEP(0),0); 
1B26:  BCF    F70.0
....................    } 
....................    UIR_STALL=0; 
1B28:  BCF    F68.5
.................... } 
1B2A:  GOTO   2718 (RETURN)
....................  
....................  
.................... /******************************************************************************* 
.................... /* usb_isr_tok_dne() 
.................... /* 
.................... /* Summary: A Token (IN/OUT/SETUP) has been received by the USB peripheral. 
.................... /*          If a setup token on EP0 was received, run the chapter 9 code and 
.................... /*          handle the request. 
.................... /*          If an IN token on EP0 was received, continue transmitting any 
.................... /*          unfinished requests that may take more than one packet to transmit 
.................... /*          (if necessary). 
.................... /*          If an OUT token on any other EP was received, mark that EP as ready 
.................... /*          for a usb_get_packet(). 
.................... /*          Does not handle any IN or OUT tokens on EP0. 
.................... /* 
.................... /********************************************************************************/ 
.................... void usb_isr_tok_dne() { 
....................    int8 en; 
....................  
....................    en=USTAT>>3; 
*
25D0:  RRCF   F6C,W
25D2:  MOVLB  2
25D4:  MOVWF  x99
25D6:  RRCF   x99,F
25D8:  RRCF   x99,F
25DA:  MOVLW  1F
25DC:  ANDWF  x99,F
....................  
....................          debug_usb(debug_putc,"T "); 
....................          debug_usb(debug_putc,"%X ", USTAT); 
....................  
....................       if (USTAT==USTAT_OUT_SETUP_E0) {   //new out or setup token in the buffer 
25DE:  MOVF   F6C,F
25E0:  BNZ   266E
....................          debug_usb(debug_putc,"%X ", EP_BDxST_O(0)); 
....................          if ((EP_BDxST_O(0) & 0x3C)==USB_PIC_PID_SETUP) { 
25E2:  MOVLB  4
25E4:  MOVF   x00,W
25E6:  ANDLW  3C
25E8:  SUBLW  34
25EA:  BNZ   262E
....................             EP_BDxST_I(0)=0;   // return the in buffer to us (dequeue any pending requests) 
25EC:  CLRF   x04
....................  
....................             debug_usb(debug_putc,"(%U) ", EP_BDxCNT_O(0)); 
....................             debug_display_ram(EP_BDxCNT_O(0), usb_ep0_rx_buffer); 
....................  
....................             usb_isr_tok_setup_dne(); 
25EE:  MOVLB  0
25F0:  BRA    21B8
....................  
....................             //if setup_0_tx_size==0xFF - stall ep0 (unhandled request) 
....................             //if setup_0_tx_size==0xFE - get EP0OUT ready for a data packet, leave EP0IN alone 
....................             //else setup_0_tx_size=size of response, get EP0OUT ready for a setup packet, mark EPOIN ready for transmit 
....................             if (__setup_0_tx_size==0xFF) 
25F2:  INCFSZ 27,W
25F4:  BRA    2604
....................                usb_flush_out(0,USB_DTS_STALL); 
25F6:  MOVLB  2
25F8:  CLRF   x9A
25FA:  MOVLW  03
25FC:  MOVWF  x9B
25FE:  MOVLB  0
2600:  RCALL  21E2
....................             else { 
2602:  BRA    2628
....................                usb_flush_out(0,USB_DTS_TOGGLE); 
2604:  MOVLB  2
2606:  CLRF   x9A
2608:  MOVLW  02
260A:  MOVWF  x9B
260C:  MOVLB  0
260E:  RCALL  21E2
....................                if (__setup_0_tx_size!=0xFE) { 
2610:  MOVF   27,W
2612:  SUBLW  FE
2614:  BZ    2628
....................                   usb_flush_in(0,__setup_0_tx_size,USB_DTS_USERX); 
2616:  MOVLB  2
2618:  CLRF   xA6
261A:  CLRF   xA8
261C:  MOVFF  27,2A7
2620:  MOVLW  04
2622:  MOVWF  xA9
2624:  MOVLB  0
2626:  RCALL  22D0
....................                } 
....................             } 
....................             UCON_PKTDIS=0;       // UCON,PKT_DIS ; Assuming there is nothing to dequeue, clear the packet disable bit 
2628:  BCF    F6D.4
....................          } 
....................          else if ((EP_BDxST_O(0) & 0x3C)==USB_PIC_PID_OUT) { 
262A:  BRA    2668
262C:  MOVLB  4
262E:  MOVF   x00,W
2630:  ANDLW  3C
2632:  SUBLW  04
2634:  BNZ   266A
....................             usb_isr_tok_out_dne(0); 
2636:  MOVLB  2
2638:  CLRF   x9A
263A:  MOVLB  0
263C:  RCALL  2458
....................             usb_flush_out(0,USB_DTS_TOGGLE); 
263E:  MOVLB  2
2640:  CLRF   x9A
2642:  MOVLW  02
2644:  MOVWF  x9B
2646:  MOVLB  0
2648:  RCALL  21E2
....................             if ((__setup_0_tx_size!=0xFE)&&(__setup_0_tx_size!=0xFF)) { 
264A:  MOVF   27,W
264C:  SUBLW  FE
264E:  BZ    2668
2650:  INCFSZ 27,W
2652:  BRA    2656
2654:  BRA    2668
....................                usb_flush_in(0,__setup_0_tx_size,USB_DTS_DATA1);   //send response (usually a 0len) 
2656:  MOVLB  2
2658:  CLRF   xA6
265A:  CLRF   xA8
265C:  MOVFF  27,2A7
2660:  MOVLW  01
2662:  MOVWF  xA9
2664:  MOVLB  0
2666:  RCALL  22D0
2668:  MOVLB  4
....................             } 
....................          } 
....................       } 
....................  
....................       else if (USTAT==USTAT_IN_E0) {   //pic -> host transfer completed 
266A:  BRA    26BA
266C:  MOVLB  2
266E:  MOVF   F6C,W
2670:  SUBLW  04
2672:  BNZ   26A0
....................          __setup_0_tx_size=0xFF; 
2674:  MOVLW  FF
2676:  MOVWF  27
....................          usb_isr_tok_in_dne(0); 
2678:  CLRF   x9A
267A:  MOVLB  0
267C:  RCALL  259E
....................          if (__setup_0_tx_size!=0xFF) 
267E:  INCFSZ 27,W
2680:  BRA    2684
2682:  BRA    2698
....................             usb_flush_in(0,__setup_0_tx_size,USB_DTS_TOGGLE); 
2684:  MOVLB  2
2686:  CLRF   xA6
2688:  CLRF   xA8
268A:  MOVFF  27,2A7
268E:  MOVLW  02
2690:  MOVWF  xA9
2692:  MOVLB  0
2694:  RCALL  22D0
....................          else 
2696:  BRA    269C
....................             usb_init_ep0_setup(); 
2698:  CALL   1AC8
....................       } 
....................  
....................       else { 
269C:  BRA    26B8
269E:  MOVLB  2
....................          if (!bit_test(USTAT,2)) { 
26A0:  BTFSC  F6C.2
26A2:  BRA    26B0
....................             usb_isr_tok_out_dne(en); 
26A4:  MOVFF  299,29A
26A8:  MOVLB  0
26AA:  RCALL  2458
....................          } 
....................          else { 
26AC:  BRA    26B8
26AE:  MOVLB  2
....................             usb_isr_tok_in_dne(en); 
26B0:  MOVFF  299,29A
26B4:  MOVLB  0
26B6:  RCALL  259E
26B8:  MOVLB  4
....................          } 
....................       } 
.................... } 
26BA:  MOVLB  0
26BC:  GOTO   2722 (RETURN)
....................  
.................... /************************************************************** 
.................... /* usb_request_send_response(len) 
.................... /* usb_request_get_data() 
.................... /* usb_request_stall() 
.................... /* 
.................... /* Input: len - size of packet to send 
.................... /* 
.................... /* Summary: After we process a SETUP request, we have 1 of three responses: 
.................... /*            1.) send a response IN packet 
.................... /*            2.) wait for followup OUT packet(s) with data 
.................... /*            3.) stall because we don't support that SETUP request 
.................... /* 
.................... /*          If we are sending data, the array usb_ep0_tx_buffer[] will hold 
.................... /*          the response and the USB Request handler code will call 
.................... /*          usb_request_send_response() to let us know how big the packet is. 
.................... /* 
.................... /*          If we are waiting for more data, usb_request_get_data() will 
.................... /*          be called by the USB request handler code to configure the EP0 OUT 
.................... /*          endpoint to be ready for more data 
.................... /* 
.................... /*          If we don't support a request, usb_request_stall() will be called 
.................... /*          by the USB request handler code to stall the endpoint 0. 
.................... /* 
.................... /***************************************************************/ 
.................... void usb_request_send_response(int len) { 
....................    __setup_0_tx_size=len; 
*
1B2E:  MOVFF  29D,27
.................... } 
1B32:  RETLW  00
....................  
.................... void usb_request_get_data(void) { 
....................    __setup_0_tx_size=0xFE; 
*
2104:  MOVLW  FE
2106:  MOVWF  27
.................... } 
2108:  RETLW  00
....................  
.................... void usb_request_stall(void) { 
....................    __setup_0_tx_size=0xFF; 
*
1B34:  MOVLW  FF
1B36:  MOVWF  27
.................... } 
1B38:  RETLW  00
....................  
.................... /// END USB Interrupt Service Routine 
....................  
.................... #ENDIF 
....................  
....................  #endif 
.................... #else 
....................  #include <usbn960x.c>   //National 960x hardware layer for usb.c 
.................... #endif 
.................... #include "usb_desc_cdc.h"	//USB Configuration and Device descriptors for this UBS device 
.................... /* 
....................  * Copylight (C) 2009, Shunichi Yamamoto, tkrworks.net 
....................  * 
....................  * This file is part of PICnome. 
....................  * 
....................  * PICnome is free software: you can redistribute it and/or modify 
....................  * it under the terms of the GNU General Public License as published by 
....................  * the Free Software Foundation, either version 3 of the License, or 
....................  * (at your option ) any later version. 
....................  * 
....................  * PICnome is distributed in the hope that it will be useful, 
....................  * but WITHIOUT ANY WARRANTY; without even the implied warranty of 
....................  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.   See the 
....................  * GNU General Public License for more details. 
....................  * 
....................  * You should have received a copy of the GNU General Public License 
....................  * along with PICnome. if not, see <http:/www.gnu.org/licenses/>. 
....................  * 
....................  * usb_desc_cdc.h,v.1.0.22 2010/06/25 
....................  */ 
....................  
.................... #IFNDEF __USB_DESCRIPTORS__ 
.................... #DEFINE __USB_DESCRIPTORS__ 
....................  
.................... #include <usb.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                              usb.h                                //// 
.................... ////                                                                   //// 
.................... //// Function protypes, defintions and globals used by CCS USB driver  //// 
.................... ////                                                                   //// 
.................... //// This file is part of CCS's PIC USB driver code, which includes:   //// 
.................... ////   usb_desc_*.h - an example set of config and device descriptor   //// 
.................... ////   usb.c - USB token and request handler code                      //// 
.................... ////   usb.h - definitions, prototypes and global variables            //// 
.................... ////                                                                   //// 
.................... //// The following examples are provided by CCS:                       //// 
.................... ////   ex_usb_mouse.c - A HID Mouse.                                   //// 
.................... ////   ex_usb_hid.c - A custom application using HID protocol.         //// 
.................... ////   ex_usb_kbmouse.c - A HID Mouse/Keyboard combo using multiple    //// 
.................... ////                      interfaces.                                  //// 
.................... ////   ex_usb_kbmouse.c - A HID Mouse/Keyboard combo using multiple    //// 
.................... ////                      HID Reports.                                 //// 
.................... ////   ex_usb_scope.c - A digital oscilloscope using a custom          //// 
.................... ////                    protocol requiring custom Windows drivers.     //// 
.................... ////                                                                   //// 
.................... ////                   **** DEFINITIONS *****                          //// 
.................... //// The following definitions are declared here, but can be           //// 
.................... //// overwritten in your code.  Unless needed otherwise, leave         //// 
.................... //// to default value.  If confused about a definition read the        //// 
.................... //// comments at each defintion                                        //// 
.................... ////                                                                   //// 
.................... //// USB_HID_IDLE (FALSE) - Set to TRUE if your device supports        //// 
.................... ////                            Set_Idle HID class request.  Set to    //// 
.................... ////                            False if you do not (device will       //// 
.................... ////                            send a Wrong-state if computer         //// 
.................... ////                            sends a Set_Idle / Get_Idle command)   //// 
.................... ////                            NOTE: If you set to TRUE you must      //// 
.................... ////                            provide your own code.  See            //// 
.................... ////                            usb_isr_tkn_setup_ClassInterface() in  //// 
.................... ////                            usb.c                                  //// 
.................... ////                                                                   //// 
.................... //// USB_HID_BOOT_PROTOCOL (FALSE) - Set to TRUE if your device supports   //// 
.................... ////                            Set_Protocl HID class request. Set to  //// 
.................... ////                            False if you do not (device will       //// 
.................... ////                            send a Wrong-state if computer         //// 
.................... ////                            sends a Set_Protocl / Get_Protocol     //// 
.................... ////                            command).                              //// 
.................... ////                            NOTE: If you set to TRUE you must      //// 
.................... ////                            provide your own code in the           //// 
.................... ////                            application that properly send boot    //// 
.................... ////                            or HID packets.                        //// 
.................... ////                                                                   //// 
.................... //// USB_MAX_EP0_PACKET_LENGTH (8) - Max Packet size for Endpoint 0.   //// 
.................... ////                            Only the 18Fxx5x USB peripheral can    //// 
.................... ////                            have a value larger than 8.            //// 
.................... ////                                                                   //// 
.................... //// USB_EPx_RX_ENABLE (USB_ENABLE_DISABLED) - Where x is the          //// 
.................... ////                         endpoint number. Change this define       //// 
.................... ////                         to specify what kind of transfer method   //// 
.................... ////                         this RX (PC to device) endpoint uses.     //// 
.................... ////                       Here is the list of valid transfer methods: //// 
.................... ////                             USB_ENABLE_CONTROL                    //// 
.................... ////                             USB_ENABLE_ISOCHRONOUS                //// 
.................... ////                             USB_ENABLE_BULK                       //// 
.................... ////                             USB_ENABLE_INTERRUPT                  //// 
.................... ////                             USB_ENABLE_DISABLED                   //// 
.................... ////                        Don't forget that you must specify the     //// 
.................... ////                        transfer method properly in your endpoint  //// 
.................... ////                        descriptor, too.                           //// 
.................... ////                                                                   //// 
.................... //// USB_EPx_RX_SIZE (0) - For some hardware it is important to know   //// 
.................... ////                       how much memory to reserve for receiving    //// 
.................... ////                       packets.                                    //// 
.................... ////                                                                   //// 
.................... ////  *** NOTE *** You must have both USB_EPx_RX_ENABLE defined and    //// 
.................... ////               USB_EPx_RX_SIZE defined (non 0) to enable a RX      //// 
.................... ////               endpoint.                                           //// 
.................... ////  *** NOTE *** Endpoint 0 is always enabled.                       //// 
.................... ////                                                                   //// 
.................... //// USB_EPx_TX_ENABLE (USB_ENABLE_DISABLED) - Where x is the          //// 
.................... ////                         endpoint number. Change this define       //// 
.................... ////                         to specify what kind of transfer method   //// 
.................... ////                         this TX (device to PC) endpoint uses.     //// 
.................... ////                       Here is the list of valid transfer methods: //// 
.................... ////                             USB_ENABLE_CONTROL                    //// 
.................... ////                             USB_ENABLE_ISOCHRONOUS                //// 
.................... ////                             USB_ENABLE_BULK                       //// 
.................... ////                             USB_ENABLE_INTERRUPT                  //// 
.................... ////                             USB_ENABLE_DISABLED                   //// 
.................... ////                        Don't forget that you must specify the     //// 
.................... ////                        transfer method properly in your endpoint  //// 
.................... ////                        descriptor, too.                           //// 
.................... ////                                                                   //// 
.................... //// USB_EPx_TX_SIZE (0) - For some hardware it is important to know   //// 
.................... ////                       how much memory to reserve for transmitting //// 
.................... ////                       packets.                                    //// 
.................... ////                                                                   //// 
.................... ////  *** NOTE *** You must have both USB_EPx_TX_ENABLE defined and    //// 
.................... ////               USB_EPx_TX_SIZE defined (non 0) to enable a TX      //// 
.................... ////               endpoint.                                           //// 
.................... ////                                                                   //// 
.................... ////                                                                   //// 
.................... //// USB_HID_DEVICE (TRUE) - HID devices require extra code to handle  //// 
.................... ////                         HID requests.  You can disable to save    //// 
.................... ////                         ROM space if you are not using a HID      //// 
.................... ////                         device.  If you are not using a HID       //// 
.................... ////                         device you must provide your own O/S      //// 
.................... ////                         (Windows) driver.                         //// 
.................... ////                                                                   //// 
.................... //// The other definitions should not be changed.                      //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... //// Version History:                                                  //// 
.................... ////                                                                   //// 
.................... //// July 13th, 2005:                                                  //// 
.................... ////  usb_ep_tx_size[] and usb_ep_rx_size[] changed to 16bits          //// 
.................... ////                                                                   //// 
.................... //// June 20th, 2005:                                                  //// 
.................... ////  Initial 18fxx5x release                                          //// 
.................... ////                                                                   //// 
.................... //// May 13th, 2005:                                                   //// 
.................... ////  Beta release, only works with 18Fxx5x hardware layer.            //// 
.................... ////  Now supports multiple interfaces (many defines in descriptors    //// 
.................... ////   will have to be changed, see examples)                          //// 
.................... ////                                                                   //// 
.................... //// Mar 21st, 2005:                                                   //// 
.................... ////  Initial Alpha Release with PIC18Fxx5x support.  (ONLY TESTED     //// 
.................... ////   WITH 18F4550)                                                   //// 
.................... ////  usb_gets() and usb_puts() changed (see usb.c)                    //// 
.................... ////                                                                   //// 
.................... //// June 24th, 2004:                                                  //// 
.................... ////  Optimization and cleanup.                                        //// 
.................... ////                The following definitions changed:                 //// 
.................... ////  USB_EPx_TX_ENABLE and USB_EPx_RX_ENABLE have changed. See usb.h  //// 
.................... ////  USB_CONFIG_DESCRIPTORS[] removed                                 //// 
.................... ////  USB_CONFIG_DESC_LEN changed to USB_DESC_CONFIG_LEN               //// 
.................... ////  USB_INTERFACE_DESC_LEN changed to USB_DESC_INTERFACE_LEN         //// 
.................... ////  USB_CLASS_DESC_LEN changed to USB_DESC_CLASS_LEN                 //// 
.................... ////  USB_ENDPOINT_DESC_LEN changed to USB_DESC_ENDPOINT_LEN           //// 
.................... ////  USB_CONFIG_DESC_KEY changed to USB_DESC_CONFIG_TYPE              //// 
.................... ////  USB_INTERFACE_DESC_KEY changed to USB_DESC_INTERFACE_TYPE        //// 
.................... ////  USB_CLASS_DESC_KEY changed to USB_DESC_CLASS_TYPE                //// 
.................... ////  USB_ENDPOINT_DESC_KEY changed to USB_DESC_ENDPOINT_TYPE          //// 
.................... ////  USB_STRING_X[] arrays removed, see USB_STRING_DESC[] and         //// 
.................... ////                                 USB_STRING_DESC_OFFSET[]          //// 
.................... ////  dev_req, curr_config, status_device and getdesc_type global      //// 
.................... ////        variables moved into struct USB_stack_status               //// 
.................... ////                                                                   //// 
.................... //// October 15th, 2003: Support for boot protocol added.              //// 
.................... ////         Set USB_HID_BOOT_PROTOCOL to TRUE to support this.        //// 
.................... ////         The array hid_protocol[] saves which protocol mode each   //// 
.................... ////         interface is in.  It is your applications job to send     //// 
.................... ////         data that either fit the boot protocol or HID protocol.   //// 
.................... ////                                                                   //// 
.................... //// May 6th, 2003: Fixed a potential stack overflow using PCM         //// 
.................... ////                                                                   //// 
.................... //// October 29th, 2002: New definition added to USB_STATES            //// 
.................... ////                                                                   //// 
.................... //// August 2nd, 2002: Initial Public Release                          //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2005 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS    //// 
.................... //// C compiler.  This source code may only be distributed to other    //// 
.................... //// licensed users of the CCS C compiler.  No other use,              //// 
.................... //// reproduction or distribution is permitted without written         //// 
.................... //// permission.  Derivative programs created using this software      //// 
.................... //// in object code form are not restricted in any way.                //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
....................  
.................... #IFNDEF __USB_PROTOTYPES__ 
.................... #DEFINE __USB_PROTOTYPES__ 
....................  
.................... #IFNDEF USB_HID_BOOT_PROTOCOL 
....................    #DEFINE USB_HID_BOOT_PROTOCOL FALSE 
.................... #ENDIF 
....................  
.................... #IFNDEF USB_HID_IDLE 
....................    #DEFINE USB_HID_IDLE FALSE 
.................... #ENDIF 
....................  
.................... //should the compiler add the extra HID handler code?  Defaults to yes. 
.................... #IFNDEF USB_HID_DEVICE 
....................    #DEFINE USB_HID_DEVICE TRUE 
.................... #ENDIF 
....................  
.................... #IFNDEF USB_CDC_DEVICE 
....................    #DEFINE USB_CDC_DEVICE FALSE 
.................... #ENDIF 
....................  
.................... #ifndef USB_OPT_FOR_ROM 
....................    #define USB_OPT_FOR_ROM TRUE  //set to false to opt for less RAM, true to opt for less ROM 
.................... #endif 
....................  
.................... #IFNDEF USB_MAX_EP0_PACKET_LENGTH 
....................   #DEFINE USB_MAX_EP0_PACKET_LENGTH 8 
.................... #ENDIF 
....................  
.................... //CCS only supports one configuration at this time 
.................... #DEFINE USB_NUM_CONFIGURATIONS 1 //DO NOT CHANGE 
....................  
.................... //PID values for tokens (see page 48 of USB Complete ed.1) 
.................... #define PID_IN       0x09  //device to host transactions 
.................... #define PID_OUT      0x01  //host to device transactions 
.................... #define PID_SETUP    0x0D  //host to device setup transaction 
.................... #define PID_ACK      0x02  //receiver accepts error-free data packet 
.................... #define PID_DATA0    0x03  //data packet with even sync bit 
.................... #define PID_SOF      0x05  //start of framer marker and frame number 
.................... #define PID_NAK      0x0A  //receiver can't accept data or sender cant send data or has no data to transmit 
.................... #define PID_DATA1    0x0B  //data packet with odd sync bit 
.................... #define PID_PRE      0x0C  //preamble issued by host.  enables downstream traffic to low-speed device 
.................... #define PID_STALL    0x0E  //a control request isnt supported or the endpoint is halted 
....................  
.................... //Key which identifies descritpors 
.................... #DEFINE USB_DESC_DEVICE_TYPE     0x01  //#DEFINE USB_DEVICE_DESC_KEY      0x01 
.................... #DEFINE USB_DESC_CONFIG_TYPE     0x02  //#DEFINE USB_CONFIG_DESC_KEY      0x02 
.................... #DEFINE USB_DESC_STRING_TYPE     0x03  //#DEFINE USB_STRING_DESC_KEY      0x03 
.................... #DEFINE USB_DESC_INTERFACE_TYPE  0x04  //#DEFINE USB_INTERFACE_DESC_KEY   0x04 
.................... #DEFINE USB_DESC_ENDPOINT_TYPE   0x05  //#DEFINE USB_ENDPOINT_DESC_KEY    0x05 
.................... #DEFINE USB_DESC_CLASS_TYPE      0x21  //#DEFINE USB_CLASS_DESC_KEY       0x21 
.................... #DEFINE USB_DESC_HIDREPORT_TYPE  0x22 
....................  
.................... //The length of each descriptor 
.................... #DEFINE USB_DESC_DEVICE_LEN      18 //#DEFINE USB_DEVICE_DESC_LEN      18 
.................... #DEFINE USB_DESC_CONFIG_LEN      9  //#DEFINE USB_CONFIG_DESC_LEN      9 
.................... #DEFINE USB_DESC_INTERFACE_LEN   9  //#DEFINE USB_INTERFACE_DESC_LEN   9 
.................... #DEFINE USB_DESC_CLASS_LEN       9  //#DEFINE USB_CLASS_DESC_LEN       9 
.................... #DEFINE USB_DESC_ENDPOINT_LEN    7  //#DEFINE USB_ENDPOINT_DESC_LEN    7 
....................  
.................... //Standard USB Setup bRequest Codes 
.................... #define USB_STANDARD_REQUEST_GET_STATUS         0x00 
.................... #define USB_STANDARD_REQUEST_CLEAR_FEATURE      0x01 
.................... #define USB_STANDARD_REQUEST_SET_FEATURE        0x03 
.................... #define USB_STANDARD_REQUEST_SET_ADDRESS        0x05 
.................... #define USB_STANDARD_REQUEST_GET_DESCRIPTOR     0x06 
.................... #define USB_STANDARD_REQUEST_SET_DESCRIPTOR     0x07 
.................... #define USB_STANDARD_REQUEST_GET_CONFIGURATION  0x08 
.................... #define USB_STANDARD_REQUEST_SET_CONFIGURATION  0x09 
.................... #define USB_STANDARD_REQUEST_GET_INTERFACE      0x0A 
.................... #define USB_STANDARD_REQUEST_SET_INTERFACE      0x0B 
.................... #define USB_STANDARD_REQUEST_SYNCH_FRAME        0x0C 
....................  
.................... //HID Class Setup bRequest Codes 
.................... #define USB_HID_REQUEST_GET_REPORT     0x01 
.................... #define USB_HID_REQUEST_GET_IDLE       0x02 
.................... #define USB_HID_REQUEST_GET_PROTOCOL   0x03 
.................... #define USB_HID_REQUEST_SET_REPORT     0x09 
.................... #define USB_HID_REQUEST_SET_IDLE       0x0A 
.................... #define USB_HID_REQUEST_SET_PROTOCOL   0x0B 
....................  
.................... //types of endpoints as defined in the descriptor 
.................... #define USB_ENDPOINT_TYPE_CONTROL      0x00 
.................... #define USB_ENDPOINT_TYPE_ISOCHRONOUS  0x01 
.................... #define USB_ENDPOINT_TYPE_BULK         0x02 
.................... #define USB_ENDPOINT_TYPE_INTERRUPT    0x03 
....................  
.................... //types of endpoints used internally in this api 
.................... #define USB_ENABLE_DISABLED     0 
.................... #define USB_ENABLE_BULK         0x01 
.................... #define USB_ENABLE_ISOCHRONOUS  0x02 
.................... #define USB_ENABLE_INTERRUPT    0x03 
.................... #define USB_ENABLE_CONTROL      0x04 
....................  
.................... //// DO NOT CHANGE THE FOLLOWING VALUES: 
....................  
.................... enum USB_STATES {GET_DESCRIPTOR=1,SET_ADDRESS=2,NONE=0}; 
....................  
.................... enum USB_DTS_BIT {USB_DTS_DATA1=1, USB_DTS_TOGGLE=2, USB_DTS_DATA0=0, 
....................                    USB_DTS_STALL=3, USB_DTS_USERX=4}; 
....................  
.................... enum USB_GETDESC_TYPES {USB_GETDESC_CONFIG_TYPE=0,USB_GETDESC_HIDREPORT_TYPE=1,USB_GETDESC_STRING_TYPE=2,USB_GETDESC_DEVICE_TYPE=3}; 
....................  
.................... #if USB_OPT_FOR_ROM 
.................... struct { 
....................    USB_STATES dev_req;   //what did the last setup token set us up to do?.  init at none 
....................    int  curr_config;  //our current config.  start at none/powered (NOT THAT THIS LIMITS US TO 3 CONFIGURATIONS) 
....................    int status_device; //Holds our state for Set_Feature and Clear_Feature 
....................    USB_GETDESC_TYPES getdesc_type;   //which get_descriptor() we are handling 
.................... } USB_stack_status; 
.................... #else 
.................... struct { 
....................    USB_STATES dev_req:2;   //what did the last setup token set us up to do?.  init at none 
....................    int  Curr_config:2;  //our current config.  start at none/powered (NOT THAT THIS LIMITS US TO 3 CONFIGURATIONS) 
....................    int status_device:2; //Holds our state for Set_Feature and Clear_Feature 
....................    USB_GETDESC_TYPES getdesc_type:2;   //which get_descriptor() we are handling 
.................... } USB_stack_status; 
.................... #endif 
....................  
.................... int16 __usb_kbhit_status; 
....................  
.................... /// *** User function prototypes 
.................... void usb_wait_for_enumeration(void); 
.................... int1 usb_unermated(void); 
.................... int8 usb_gets(int8 endpoint, int8 * ptr, int16 max, int16 timeout); 
.................... int1 usb_puts(int8 endpoint, int8 * ptr, int16 len, int8 timeout); 
....................  
.................... /// *** Token and request hanlder function prototypes 
.................... void usb_token_reset(); 
....................  
.................... void usb_put_0len_0(void); 
.................... void usb_request_send_response(int len);   //always sends usb_ep0_rx_buffer[] to endpoint 0 with a toggle of DATA 
....................  
.................... void usb_match_registers(int8 endpoint, int16 *status, int16 *buffer, int8 *size); 
....................  
.................... void usb_isr_tok_in_dne(int8 endpoint); 
.................... void usb_isr_tok_out_dne(int8 endpoint); 
.................... void usb_isr_tok_setup_dne(void); 
....................  
.................... void usb_isr_tkn_setup_StandardEndpoint(void); 
.................... void usb_isr_tkn_setup_StandardDevice(void); 
.................... void usb_isr_tkn_setup_StandardInterface(void); 
....................  
.................... #IF USB_HID_DEVICE 
....................    void usb_isr_tkn_setup_ClassInterface(void); 
.................... #ENDIF 
....................  
.................... void usb_Get_Descriptor(void); 
.................... void usb_copy_desc_seg_to_ep(void); 
....................  
.................... void usb_finish_set_address(void); 
....................  
.................... //*** ENABLE RX ENDPOINTS AND BUFFERS 
....................  
.................... //--------- endpoint 0 defines ---------- 
.................... #define USB_EP0_TX_ENABLE  USB_ENABLE_CONTROL 
.................... #define USB_EP0_RX_ENABLE  USB_ENABLE_CONTROL 
.................... #define USB_EP0_RX_SIZE    USB_MAX_EP0_PACKET_LENGTH  //endpoint 0 is setup, and should always be the MAX_PACKET_LENGTH.  Slow speed specifies 8 
.................... #define USB_EP0_TX_SIZE    USB_MAX_EP0_PACKET_LENGTH  //endpoint 0 is setup, and should always be the MAX_PACKET_LENGTH.  Slow speed specifies 8 
....................  
.................... //--------- endpoint 1 defines ---------- 
.................... #ifndef USB_EP1_TX_ENABLE 
....................  #define USB_EP1_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP1_RX_ENABLE 
....................  #define USB_EP1_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP1_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP1_RX_SIZE 
....................   #undef USB_EP1_RX_SIZE 
....................  #endif 
....................  #define USB_EP1_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP1_RX_SIZE 
....................   #error You enabled EP1 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP1_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP1_TX_SIZE 
....................   #undef USB_EP1_TX_SIZE 
....................  #endif 
....................  #define USB_EP1_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP1_TX_SIZE 
....................   #error You enabled EP1 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 2 defines ---------- 
.................... #ifndef USB_EP2_TX_ENABLE 
....................  #define USB_EP2_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP2_RX_ENABLE 
....................  #define USB_EP2_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP2_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP2_RX_SIZE 
....................   #undef USB_EP2_RX_SIZE 
....................  #endif 
....................  #define USB_EP2_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP2_RX_SIZE 
....................   #error You enabled EP2 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP2_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP2_TX_SIZE 
....................   #undef USB_EP2_TX_SIZE 
....................  #endif 
....................  #define USB_EP2_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP2_TX_SIZE 
....................   #error You enabled EP2 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 3 defines ---------- 
.................... #ifndef USB_EP3_TX_ENABLE 
....................  #define USB_EP3_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP3_RX_ENABLE 
....................  #define USB_EP3_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP3_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP3_RX_SIZE 
....................   #undef USB_EP3_RX_SIZE 
....................  #endif 
....................  #define USB_EP3_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP3_RX_SIZE 
....................   #error You enabled EP3 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP3_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP3_TX_SIZE 
....................   #undef USB_EP3_TX_SIZE 
....................  #endif 
....................  #define USB_EP3_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP3_TX_SIZE 
....................   #error You enabled EP3 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 4 defines ---------- 
.................... #ifndef USB_EP4_TX_ENABLE 
....................  #define USB_EP4_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP4_RX_ENABLE 
....................  #define USB_EP4_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP4_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP4_RX_SIZE 
....................   #undef USB_EP4_RX_SIZE 
....................  #endif 
....................  #define USB_EP4_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP4_RX_SIZE 
....................   #error You enabled EP4 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP4_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP4_TX_SIZE 
....................   #undef USB_EP4_TX_SIZE 
....................  #endif 
....................  #define USB_EP4_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP4_TX_SIZE 
....................   #error You enabled EP4 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 5 defines ---------- 
.................... #ifndef USB_EP5_TX_ENABLE 
....................  #define USB_EP5_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP5_RX_ENABLE 
....................  #define USB_EP5_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP5_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP5_RX_SIZE 
....................   #undef USB_EP5_RX_SIZE 
....................  #endif 
....................  #define USB_EP5_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP5_RX_SIZE 
....................   #error You enabled EP5 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP5_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP5_TX_SIZE 
....................   #undef USB_EP5_TX_SIZE 
....................  #endif 
....................  #define USB_EP5_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP5_TX_SIZE 
....................   #error You enabled EP5 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 6 defines ---------- 
.................... #ifndef USB_EP6_TX_ENABLE 
....................  #define USB_EP6_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP6_RX_ENABLE 
....................  #define USB_EP6_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP6_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP6_RX_SIZE 
....................   #undef USB_EP6_RX_SIZE 
....................  #endif 
....................  #define USB_EP6_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP6_RX_SIZE 
....................   #error You enabled EP6 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP6_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP6_TX_SIZE 
....................   #undef USB_EP6_TX_SIZE 
....................  #endif 
....................  #define USB_EP6_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP6_TX_SIZE 
....................   #error You enabled EP6 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 7 defines ---------- 
.................... #ifndef USB_EP7_TX_ENABLE 
....................  #define USB_EP7_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP7_RX_ENABLE 
....................  #define USB_EP7_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP7_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP7_RX_SIZE 
....................   #undef USB_EP7_RX_SIZE 
....................  #endif 
....................  #define USB_EP7_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP7_RX_SIZE 
....................   #error You enabled EP7 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP7_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP7_TX_SIZE 
....................   #undef USB_EP7_TX_SIZE 
....................  #endif 
....................  #define USB_EP7_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP7_TX_SIZE 
....................   #error You enabled EP7 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 8 defines ---------- 
.................... #ifndef USB_EP8_TX_ENABLE 
....................  #define USB_EP8_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP8_RX_ENABLE 
....................  #define USB_EP8_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP8_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP8_RX_SIZE 
....................   #undef USB_EP8_RX_SIZE 
....................  #endif 
....................  #define USB_EP8_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP8_RX_SIZE 
....................   #error You enabled EP8 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP8_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP8_TX_SIZE 
....................   #undef USB_EP8_TX_SIZE 
....................  #endif 
....................  #define USB_EP8_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP8_TX_SIZE 
....................   #error You enabled EP8 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 9 defines ---------- 
.................... #ifndef USB_EP9_TX_ENABLE 
....................  #define USB_EP9_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP9_RX_ENABLE 
....................  #define USB_EP9_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP9_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP9_RX_SIZE 
....................   #undef USB_EP9_RX_SIZE 
....................  #endif 
....................  #define USB_EP9_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP9_RX_SIZE 
....................   #error You enabled EP9 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP9_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP9_TX_SIZE 
....................   #undef USB_EP9_TX_SIZE 
....................  #endif 
....................  #define USB_EP9_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP9_TX_SIZE 
....................   #error You enabled EP9 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 10 defines ---------- 
.................... #ifndef USB_EP10_TX_ENABLE 
....................  #define USB_EP10_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP10_RX_ENABLE 
....................  #define USB_EP10_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP10_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP10_RX_SIZE 
....................   #undef USB_EP10_RX_SIZE 
....................  #endif 
....................  #define USB_EP10_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP10_RX_SIZE 
....................   #error You enabled EP10 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP10_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP10_TX_SIZE 
....................   #undef USB_EP10_TX_SIZE 
....................  #endif 
....................  #define USB_EP10_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP10_TX_SIZE 
....................   #error You enabled EP10 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 11 defines ---------- 
.................... #ifndef USB_EP11_TX_ENABLE 
....................  #define USB_EP11_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP11_RX_ENABLE 
....................  #define USB_EP11_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP11_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP11_RX_SIZE 
....................   #undef USB_EP11_RX_SIZE 
....................  #endif 
....................  #define USB_EP11_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP11_RX_SIZE 
....................   #error You enabled EP11 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP11_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP11_TX_SIZE 
....................   #undef USB_EP11_TX_SIZE 
....................  #endif 
....................  #define USB_EP11_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP11_TX_SIZE 
....................   #error You enabled EP11 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 12 defines ---------- 
.................... #ifndef USB_EP12_TX_ENABLE 
....................  #define USB_EP12_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP12_RX_ENABLE 
....................  #define USB_EP12_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP12_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP12_RX_SIZE 
....................   #undef USB_EP12_RX_SIZE 
....................  #endif 
....................  #define USB_EP12_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP12_RX_SIZE 
....................   #error You enabled EP12 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP12_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP12_TX_SIZE 
....................   #undef USB_EP12_TX_SIZE 
....................  #endif 
....................  #define USB_EP12_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP12_TX_SIZE 
....................   #error You enabled EP12 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 13 defines ---------- 
.................... #ifndef USB_EP13_TX_ENABLE 
....................  #define USB_EP13_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP13_RX_ENABLE 
....................  #define USB_EP13_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP13_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP13_RX_SIZE 
....................   #undef USB_EP13_RX_SIZE 
....................  #endif 
....................  #define USB_EP13_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP13_RX_SIZE 
....................   #error You enabled EP13 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP13_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP13_TX_SIZE 
....................   #undef USB_EP13_TX_SIZE 
....................  #endif 
....................  #define USB_EP13_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP13_TX_SIZE 
....................   #error You enabled EP13 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 14 defines ---------- 
.................... #ifndef USB_EP14_TX_ENABLE 
....................  #define USB_EP14_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP14_RX_ENABLE 
....................  #define USB_EP14_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP14_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP14_RX_SIZE 
....................   #undef USB_EP14_RX_SIZE 
....................  #endif 
....................  #define USB_EP14_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP14_RX_SIZE 
....................   #error You enabled EP14 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP14_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP14_TX_SIZE 
....................   #undef USB_EP14_TX_SIZE 
....................  #endif 
....................  #define USB_EP14_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP14_TX_SIZE 
....................   #error You enabled EP14 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 15 defines ---------- 
.................... #ifndef USB_EP15_TX_ENABLE 
....................  #define USB_EP15_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP15_RX_ENABLE 
....................  #define USB_EP15_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP15_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP15_RX_SIZE 
....................   #undef USB_EP15_RX_SIZE 
....................  #endif 
....................  #define USB_EP15_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP15_RX_SIZE 
....................   #error You enabled EP15 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP15_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP15_TX_SIZE 
....................   #undef USB_EP15_TX_SIZE 
....................  #endif 
....................  #define USB_EP15_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP15_TX_SIZE 
....................   #error You enabled EP15 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... const int8 usb_ep_tx_type[16]={ 
....................   USB_EP0_TX_ENABLE, USB_EP1_TX_ENABLE, USB_EP2_TX_ENABLE, 
....................   USB_EP3_TX_ENABLE, USB_EP4_TX_ENABLE, USB_EP5_TX_ENABLE, 
....................   USB_EP6_TX_ENABLE, USB_EP7_TX_ENABLE, USB_EP8_TX_ENABLE, 
....................   USB_EP9_TX_ENABLE, USB_EP10_TX_ENABLE, USB_EP11_TX_ENABLE, 
....................   USB_EP12_TX_ENABLE, USB_EP13_TX_ENABLE, USB_EP14_TX_ENABLE, 
....................   USB_EP15_TX_ENABLE 
.................... }; 
....................  
.................... const int8 usb_ep_rx_type[16]={ 
....................   USB_EP0_RX_ENABLE, USB_EP1_RX_ENABLE, USB_EP2_RX_ENABLE, 
....................   USB_EP3_RX_ENABLE, USB_EP4_RX_ENABLE, USB_EP5_RX_ENABLE, 
....................   USB_EP6_RX_ENABLE, USB_EP7_RX_ENABLE, USB_EP8_RX_ENABLE, 
....................   USB_EP9_RX_ENABLE, USB_EP10_RX_ENABLE, USB_EP11_RX_ENABLE, 
....................   USB_EP12_RX_ENABLE, USB_EP13_RX_ENABLE, USB_EP14_RX_ENABLE, 
....................   USB_EP15_RX_ENABLE 
.................... }; 
....................  
.................... const int16 usb_ep_tx_size[16]={ 
....................   USB_EP0_TX_SIZE, USB_EP1_TX_SIZE, USB_EP2_TX_SIZE, 
....................   USB_EP3_TX_SIZE, USB_EP4_TX_SIZE, USB_EP5_TX_SIZE, 
....................   USB_EP6_TX_SIZE, USB_EP7_TX_SIZE, USB_EP8_TX_SIZE, 
....................   USB_EP9_TX_SIZE, USB_EP10_TX_SIZE, USB_EP11_TX_SIZE, 
....................   USB_EP12_TX_SIZE, USB_EP13_TX_SIZE, USB_EP14_TX_SIZE, 
....................   USB_EP15_TX_SIZE 
.................... }; 
....................  
.................... const int16 usb_ep_rx_size[16]={ 
....................   USB_EP0_RX_SIZE, USB_EP1_RX_SIZE, USB_EP2_RX_SIZE, 
....................   USB_EP3_RX_SIZE, USB_EP4_RX_SIZE, USB_EP5_RX_SIZE, 
....................   USB_EP6_RX_SIZE, USB_EP7_RX_SIZE, USB_EP8_RX_SIZE, 
....................   USB_EP9_RX_SIZE, USB_EP10_RX_SIZE, USB_EP11_RX_SIZE, 
....................   USB_EP12_RX_SIZE, USB_EP13_RX_SIZE, USB_EP14_RX_SIZE, 
....................   USB_EP15_RX_SIZE 
.................... }; 
....................  
.................... #ENDIF 
....................  
....................  
....................  
.................... ////////////////////////////////////////////////////////////////// 
.................... /// 
.................... ///   start config descriptor 
.................... ///   right now we only support one configuration descriptor. 
.................... ///   the config, interface, class, and endpoint goes into this array. 
.................... /// 
.................... ////////////////////////////////////////////////////////////////// 
....................  
....................    #DEFINE USB_TOTAL_CONFIG_LEN      67  //config+interface+class+endpoint+endpoint (2 endpoints) 
....................  
....................    const char USB_CONFIG_DESC[] = { 
....................    //IN ORDER TO COMPLY WITH WINDOWS HOSTS, THE ORDER OF THIS ARRAY MUST BE: 
....................       //    config(s) 
....................       //    interface(s) 
....................       //    class(es) 
....................       //    endpoint(s) 
....................  
....................    //config_descriptor for config index 1 
....................          USB_DESC_CONFIG_LEN, //length of descriptor size          ==0 
....................          USB_DESC_CONFIG_TYPE, //constant CONFIGURATION (CONFIGURATION 0x02)     ==1 
....................          USB_TOTAL_CONFIG_LEN,0, //size of all data returned for this config      ==2,3 
....................          2, //number of interfaces this device supports       ==4 
....................          0x01, //identifier for this configuration.  (IF we had more than one configurations)      ==5 
....................          0x00, //index of string descriptor for this configuration      ==6 
....................          0xC0, //bit 6=1 if self powered, bit 5=1 if supports remote wakeup (we don't), bits 0-4 unused and bit7=1         ==7 
....................          0xFA, //sy 500mA 0x32, //maximum bus power required (maximum milliamperes/2)  (0x32 = 100mA)  ==8 
....................  
....................    //interface descriptor 0 (comm class interface) 
....................          USB_DESC_INTERFACE_LEN, //length of descriptor      =9 
....................          USB_DESC_INTERFACE_TYPE, //constant INTERFACE (INTERFACE 0x04)       =10 
....................          0x00, //number defining this interface (IF we had more than one interface)    ==11 
....................          0x00, //alternate setting     ==12 
....................          1, //number of endpoints   ==13 
....................          0x02, //class code, 02 = Comm Interface Class     ==14 
....................          0x02, //subclass code, 2 = Abstract     ==15 
....................          0x01, //protocol code, 1 = v.25ter      ==16 
....................          0x00, //index of string descriptor for interface      ==17 
....................  
....................    //class descriptor [functional header] 
....................          5, //length of descriptor    ==18 
....................          0x24, //dscriptor type (0x24 == )      ==19 
....................          0, //sub type (0=functional header) ==20 
....................          0x10,0x01, //      ==21,22 //cdc version 
....................  
....................    //class descriptor [acm header] 
....................          4, //length of descriptor    ==23 
....................          0x24, //dscriptor type (0x24 == )      ==24 
....................          2, //sub type (2=ACM)   ==25 
....................          2, //capabilities    ==26  //we support Set_Line_Coding, Set_Control_Line_State, Get_Line_Coding, and the notification Serial_State. 
....................  
....................    //class descriptor [union header] 
....................          5, //length of descriptor    ==27 
....................          0x24, //dscriptor type (0x24 == )      ==28 
....................          6, //sub type (6=union)    ==29 
....................          0, //master intf     ==30  //The interface number of the Communication or Dat a Cl ass interface, designated as the masteror controlling interface for the union. 
....................          1, //save intf0      ==31  //Interface number of first slave or associated interface in the union. * 
....................  
....................    //class descriptor [call mgmt header] 
....................          5, //length of descriptor    ==32 
....................          0x24, //dscriptor type (0x24 == )      ==33 
....................          1, //sub type (1=call mgmt)   ==34 
....................          0, //capabilities          ==35  //device does not handle call management itself 
....................          1, //data interface        ==36  //interface number of data class interface 
....................  
....................    //endpoint descriptor 
....................          USB_DESC_ENDPOINT_LEN, //length of descriptor                   ==37 
....................          USB_DESC_ENDPOINT_TYPE, //constant ENDPOINT (ENDPOINT 0x05)          ==38 
....................          USB_CDC_COMM_IN_ENDPOINT | 0x80, //endpoint number and direction 
....................          0x03, //transfer type supported (0x03 is interrupt)         ==40 
....................          USB_CDC_COMM_IN_SIZE,0x00, //maximum packet size supported                  ==41,42 
....................          250,  //polling interval, in ms.  (cant be smaller than 10)      ==43 
....................  
....................    //interface descriptor 1 (data class interface) 
....................          USB_DESC_INTERFACE_LEN, //length of descriptor      =44 
....................          USB_DESC_INTERFACE_TYPE, //constant INTERFACE (INTERFACE 0x04)       =45 
....................          0x01, //number defining this interface (IF we had more than one interface)    ==46 
....................          0x00, //alternate setting     ==47 
....................          2, //number of endpoints   ==48 
....................          0x0A, //class code, 0A = Data Interface Class     ==49 
....................          0x00, //subclass code      ==50 
....................          0x00, //protocol code      ==51 
....................          0x00, //index of string descriptor for interface      ==52 
....................  
....................    //endpoint descriptor 
....................          USB_DESC_ENDPOINT_LEN, //length of descriptor                   ==60 
....................          USB_DESC_ENDPOINT_TYPE, //constant ENDPOINT (ENDPOINT 0x05)          ==61 
....................          USB_CDC_DATA_OUT_ENDPOINT, //endpoint number and direction (0x02 = EP2 OUT)       ==62 
....................          0x02, //transfer type supported (0x02 is bulk)         ==63 
.................... //         make8(USB_CDC_DATA_OUT_SIZE,0),make8(USB_CDC_DATA_OUT_SIZE,1), //maximum packet size supported                  ==64, 65 
....................          USB_CDC_DATA_OUT_SIZE & 0xFF, (USB_CDC_DATA_OUT_SIZE >> 8) & 0xFF, //maximum packet size supported                  ==64, 65 
....................          250,  //polling interval, in ms.  (cant be smaller than 10)      ==66 
....................  
....................    //endpoint descriptor 
....................          USB_DESC_ENDPOINT_LEN, //length of descriptor                   ==53 
....................          USB_DESC_ENDPOINT_TYPE, //constant ENDPOINT (ENDPOINT 0x05)          ==54 
....................          USB_CDC_DATA_IN_ENDPOINT | 0x80, //endpoint number and direction (0x82 = EP2 IN)       ==55 
....................          0x02, //transfer type supported (0x02 is bulk)         ==56 
.................... //         make8(USB_CDC_DATA_IN_SIZE,0),make8(USB_CDC_DATA_IN_SIZE,1), //maximum packet size supported                  ==57, 58 
....................          USB_CDC_DATA_IN_SIZE & 0xFF, (USB_CDC_DATA_IN_SIZE >> 8) & 0xFF, //maximum packet size supported                  ==64, 65 
....................          250,  //polling interval, in ms.  (cant be smaller than 10)      ==59 
....................    }; 
....................  
....................    /****** BEGIN CONFIG DESCRIPTOR LOOKUP TABLES ********/ 
....................    //since we can't make pointers to constants in certain pic16s, this is an offset table to find 
....................    //  a specific descriptor in the above table. 
....................  
....................    //the maximum number of interfaces seen on any config 
....................    //for example, if config 1 has 1 interface and config 2 has 2 interfaces you must define this as 2 
....................    #define USB_MAX_NUM_INTERFACES   2 
....................  
....................    //define how many interfaces there are per config.  [0] is the first config, etc. 
....................    const char USB_NUM_INTERFACES[USB_NUM_CONFIGURATIONS]={2}; 
....................  
....................    //define where to find class descriptors 
....................    //first dimension is the config number 
....................    //second dimension specifies which interface 
....................    //last dimension specifies which class in this interface to get, but most will only have 1 class per interface 
....................    //if a class descriptor is not valid, set the value to 0xFFFF 
....................    const int16 USB_CLASS_DESCRIPTORS[1/*USB_NUM_CONFIGURATIONS*/][USB_MAX_NUM_INTERFACES][4]= 
....................    { 
....................    //config 1 
....................       //interface 0 
....................          //class 1-4 
....................          18,23,27,32, 
....................       //interface 1 
....................          //no classes for this interface 
....................          0xFFFF,0xFFFF,0xFFFF,0xFFFF 
....................    }; 
....................  
....................    #if (sizeof(USB_CONFIG_DESC) != USB_TOTAL_CONFIG_LEN) 
....................       #error USB_TOTAL_CONFIG_LEN not defined correctly 
....................    #endif 
....................  
....................  
.................... ////////////////////////////////////////////////////////////////// 
.................... /// 
.................... ///   start device descriptors 
.................... /// 
.................... ////////////////////////////////////////////////////////////////// 
....................  
....................    const char USB_DEVICE_DESC[USB_DESC_DEVICE_LEN] ={ 
....................       //starts of with device configuration. only one possible 
....................          USB_DESC_DEVICE_LEN, //the length of this report   ==0 
....................          0x01, //the constant DEVICE (DEVICE 0x01)  ==1 
....................          0x10,0x01, //usb version in bcd  ==2,3 
....................          0x02, //class code. 0x02=Communication Device Class ==4 
....................          0x00, //subclass code ==5 
....................          0x00, //protocol code ==6 
....................          USB_MAX_EP0_PACKET_LENGTH, //max packet size for endpoint 0. (SLOW SPEED SPECIFIES 8) ==7 
....................          0xD8,0x04, //vendor id (0x04D8 is Microchip, or is it 0x0461 ??)  ==8,9 
.................... #ifndef ONE_TWENTY_EIGHT 
....................          0xC5,0xFF, //product id   ==10,11 
.................... #else 
....................          0x00,0xFD, //product id   ==10,11 
.................... #endif 
....................          0x02,0x00, //device release number  ==12,13 
....................          0x01, //index of string description of manufacturer. therefore we point to string_1 array (see below)  ==14 
....................          0x02, //index of string descriptor of the product  ==15 
....................          0x00, //index of string descriptor of serial number  ==16 
....................          USB_NUM_CONFIGURATIONS  //number of possible configurations  ==17 
....................    }; 
....................  
....................  
.................... ////////////////////////////////////////////////////////////////// 
.................... /// 
.................... ///   start string descriptors 
.................... ///   String 0 is a special language string, and must be defined.  People in U.S.A. can leave this alone. 
.................... /// 
.................... ///   You must define the length else get_next_string_character() will not see the string 
.................... ///   Current code only supports 10 strings (0 thru 9) 
.................... /// 
.................... ////////////////////////////////////////////////////////////////// 
....................  
.................... //the offset of the starting location of each string.  offset[0] is the start of string 0, offset[1] is the start of string 1, etc. 
.................... char USB_STRING_DESC_OFFSET[]={0,4,22}; 
....................  
.................... char const USB_STRING_DESC[]={ 
....................    //string 0 
....................          4, //length of string index 
....................          USB_DESC_STRING_TYPE, //descriptor type 0x03 (STRING) 
....................          0x09,0x04,   //Microsoft Defined for US-English 
....................    //string 1 
....................          18, //length of string index 
....................          USB_DESC_STRING_TYPE, //descriptor type 0x03 (STRING) 
....................          't',0, 
....................          'k',0, 
....................          'r',0, 
....................          'w',0, 
....................          'o',0, 
....................          'r',0, 
....................          'k',0, 
....................          's',0, 
....................    //string 2 
.................... #ifndef ONE_TWENTY_EIGHT 
....................          16, //length of string index 
.................... #else 
....................          22, //length of string index 
.................... #endif 
....................          USB_DESC_STRING_TYPE, //descriptor type 0x03 (STRING) 
....................          'P',0, 
....................          'I',0, 
....................          'C',0, 
....................          'n',0, 
....................          'o',0, 
....................          'm',0, 
....................          'e',0, 
.................... #ifdef ONE_TWENTY_EIGHT 
....................          '1',0, 
....................          '2',0, 
....................          '8',0, 
.................... #endif 
.................... }; 
....................  
.................... //sy #ENDIF 
....................  
.................... #include <usb.c>        //handles usb setup tokens and get descriptor reports 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                             usb.c                                 //// 
.................... ////                                                                   //// 
.................... //// Standard USB request and token handler code.                      //// 
.................... ////                                                                   //// 
.................... //// This file is part of CCS's PIC USB driver code, which includes:   //// 
.................... ////   usb_desc_*.h - an example set of config and device descriptor   //// 
.................... ////   usb.c - USB token and request handler code                      //// 
.................... ////   usb.h - definitions, prototypes and global variables            //// 
.................... ////                                                                   //// 
.................... //// The following examples are provided by CCS:                       //// 
.................... ////   ex_usb_mouse.c - A HID Mouse.                                   //// 
.................... ////   ex_usb_hid.c - A custom application using HID protocol.         //// 
.................... ////   ex_usb_kbmouse.c - A HID Mouse/Keyboard combo using multiple    //// 
.................... ////                      interfaces.                                  //// 
.................... ////   ex_usb_kbmouse.c - A HID Mouse/Keyboard combo using multiple    //// 
.................... ////                      HID Reports.                                 //// 
.................... ////   ex_usb_scope.c - A digital oscilloscope using a custom          //// 
.................... ////                    protocol requiring custom Windows drivers.     //// 
.................... ////                                                                   //// 
.................... //// Many settings important to the USB API are defined in usb.h.      //// 
.................... //// See the documentation in usb.h about these settings.              //// 
.................... ////                                                                   //// 
.................... //// The majority of this code is called and used by the interrupt     //// 
.................... //// generated by the hardware level, and therefore it is not meant    //// 
.................... //// to be called by the user.  The following functions are of use to  //// 
.................... //// the user (for more docs on the functions, read the comments at    //// 
.................... //// each function):                                                   //// 
.................... ////                                                                   //// 
.................... ////    **********************  FUNCTIONS  ***********************     //// 
.................... ////                                                                   //// 
.................... //// usb_enumerated() - returns TRUE if device has been enumerated     //// 
.................... ////                    (configured) by host, FALSE if it has not.     //// 
.................... ////                    Do not try to use the USB peripheral until you //// 
.................... ////                    are enumerated.                                //// 
.................... ////                                                                   //// 
.................... //// usb_wait_for_enumeration() - Sits in an infinte loop until device //// 
.................... ////                              is enumerated.                       //// 
.................... ////                                                                   //// 
.................... //// usb_kbhit() - Returns true if OUT endpoint contains data from     //// 
.................... ////               host.                                               //// 
.................... ////                                                                   //// 
.................... //// usb_puts() - Sends a multiple packet message to the host          //// 
.................... ////                                                                   //// 
.................... //// usb_gets() - Gets multiple packets from the host                  //// 
.................... ////                                                                   //// 
.................... //// The rest of the functions in this file are part of the USB        //// 
.................... //// interrupt service routine and are not meant to be called by the   //// 
.................... //// user.                                                             //// 
.................... ////                                                                   //// 
.................... ////   *************************  NOTE  **************************     //// 
.................... ////    This code will not create a multiple configuration device.     //// 
.................... ////    If you wish to create a multiple configuration device then you //// 
.................... ////    will have to modify these drivers.                             //// 
.................... ////                                                                   //// 
.................... ////   *************************  NOTE  **************************     //// 
.................... ////   This code does not support Get_Idle or Set_Idle HID-specific    //// 
.................... ////   requests.  These requests are optional.  If you want to support //// 
.................... ////   these requests you must provide the code yourself.  See         //// 
.................... ////   usb_isr_tkn_setup_ClassInterface() if you wish to add this      //// 
.................... ////   support.                                                        //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... //// If you wish to provide your own USB peripheral hardware layer, it //// 
.................... //// must include the following functions:                             //// 
.................... ////                                                                   //// 
.................... //// void usb_stall_ep(int8 endpoint);                                 //// 
.................... //// void usb_unstall_ep(int8 endpoint);                               //// 
.................... //// int1 usb_endpoint_stalled(int8 endpoint);                         //// 
.................... //// void usb_set_address(int8 address);                               //// 
.................... //// void usb_set_configured(int config);                              //// 
.................... //// int8 usb_get_packet(int8 endpoint, int8 * ptr, int8 max);         //// 
.................... //// int1 usb_put_packet(int endpoint, int * ptr, int len, USB_DTS_BIT toggle); //// 
.................... //// void usb_request_send_response(int8 len);                                //// 
.................... //// int1 usb_kbhit(int8 endpoint);                                    //// 
.................... ////                                                                   //// 
.................... //// CCS provides a USB peripheral hardware layer for PIC16C7x5        //// 
.................... //// (pic_usb.h), 18Fxx5x (pic18_usb.h) and National's USBN960x        //// 
.................... //// (usbn960x.c).  See these files for more documentation.            //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... //// Version History:                                                  //// 
.................... ////                                                                   //// 
.................... //// July 13th, 2005:                                                  //// 
.................... ////  usb_puts() packet_size and this_packet_len changed to 16bits.    //// 
.................... ////  usb_gets() len, packet_size and this_packet_len to 16bits.       //// 
.................... ////                                                                   //// 
.................... //// June 20th, 2005:                                                  //// 
.................... ////  Initial 18fxx5x release.                                         //// 
.................... ////  usb_kbhit() removed, usb_kbhit() now implemented in hardware     //// 
.................... ////    layer.                                                         //// 
.................... ////                                                                   //// 
.................... //// May 13th, 2005:                                                   //// 
.................... ////  Beta release, only works with 18Fxx5x hardware layer.            //// 
.................... ////  Now supports multiple interfaces (many defines in descriptors    //// 
.................... ////   will have to be changed, see examples)                          //// 
.................... ////  TODO: alot of indexing and length handling for descriptors is    //// 
.................... ////   only 8bit, so make sure all descriptor tables are less than     //// 
.................... ////   256 bytes long.                                                 //// 
.................... ////                                                                   //// 
.................... //// Apr 21st, 2005:                                                   //// 
.................... ////  Initial Alpha Release with PIC18Fxx5x support.  (ONLY TESTED     //// 
.................... ////   WITH 18F4550)                                                   //// 
.................... ////  usb_puts() doesn't need max packet size as a paremeter, uses     //// 
.................... ////   usb_ep_tx_size[] defined in usb.h                               //// 
.................... ////  usb_puts() timeout parameter now in ms, not seconds.             //// 
.................... ////  USB Stack no longer buffers incoming data.  If there is data to  //// 
.................... ////   get usb_kbhit(en) will return TRUE and the data will sit in     //// 
.................... ////   the endpoint buffer until you usb_get_packet(), which will      //// 
.................... ////   then free the endpoint buffer for more data.  This affects      //// 
.................... ////   routines such as usb_gets() and usb_kbhit().                    //// 
.................... ////  usb_gets() no longer reads buffered data (see above note),       //// 
.................... ////   now it reads multiple packets in the same way usb_puts()        //// 
.................... ////   writes multiple packets                                         //// 
.................... ////  usb_kbhit() is hardware specific, so has been moved to hardware  //// 
.................... ////   layer.                                                          //// 
.................... ////                                                                   //// 
.................... //// Nov 11th, 2004:                                                   //// 
.................... ////  No longer includes wrong descriptor header.                      //// 
.................... ////                                                                   //// 
.................... //// June 24th, 2004:                                                  //// 
.................... ////  Optimization and cleanup.                                        //// 
.................... ////                The following definitions changed:                 //// 
.................... ////  USB_EPx_TX_ENABLE and USB_EPx_RX_ENABLE have changed. See usb.h  //// 
.................... ////  USB_CONFIG_DESCRIPTORS[] removed                                 //// 
.................... ////  USB_CONFIG_DESC_LEN changed to USB_DESC_CONFIG_LEN               //// 
.................... ////  USB_INTERFACE_DESC_LEN changed to USB_DESC_INTERFACE_LEN         //// 
.................... ////  USB_CLASS_DESC_LEN changed to USB_DESC_CLASS_LEN                 //// 
.................... ////  USB_ENDPOINT_DESC_LEN changed to USB_DESC_ENDPOINT_LEN           //// 
.................... ////  USB_CONFIG_DESC_KEY changed to USB_DESC_CONFIG_TYPE              //// 
.................... ////  USB_INTERFACE_DESC_KEY changed to USB_DESC_INTERFACE_TYPE        //// 
.................... ////  USB_CLASS_DESC_KEY changed to USB_DESC_CLASS_TYPE                //// 
.................... ////  USB_ENDPOINT_DESC_KEY changed to USB_DESC_ENDPOINT_TYPE          //// 
.................... ////  USB_STRING_X[] arrays removed, see USB_STRING_DESC[] and         //// 
.................... ////                                 USB_STRING_DESC_OFFSET[]          //// 
.................... ////  dev_req, curr_config, status_device and getdesc_type global      //// 
.................... ////        variables moved into struct USB_stack_status               //// 
.................... ////                                                                   //// 
.................... //// December 5th, 2003: Fixed a potential bug where descriptors are   //// 
.................... ////         evenly dividable by 8 (MAX_EP0_PACKET_SIZE)               //// 
.................... ////                                                                   //// 
.................... //// October 15th, 2003: Support for boot protocol added.              //// 
.................... ////         Set USB_HID_BOOT_PROTOCOL to TRUE to support this.        //// 
.................... ////         The array hid_protocol[] saves which protocol mode each   //// 
.................... ////         interface is in.  It is your applications job to send     //// 
.................... ////         data that either fit the boot protocol or HID protocol.   //// 
.................... ////                                                                   //// 
.................... //// May 6th, 2003: Fixed a potential stack overflow using PCM         //// 
.................... ////                                                                   //// 
.................... //// October 28th, 2002: Problem with usb_puts and timeout fixed.      //// 
.................... ////                                                                   //// 
.................... //// October 28th, 2002: Typo fixed in get_next_string_character(),    //// 
.................... ////                     although it didn't cause any serious problems //// 
.................... ////                                                                   //// 
.................... //// October 25th, 2002: Another change to usb_puts() was made to fix  //// 
.................... ////                     problems with multiple packet messages        //// 
.................... //// October 29th, 2002: Fixed a problem with multiple packet string   //// 
.................... ////                     descriptors that require a 0 len packet to    //// 
.................... ////                     end message.                                  //// 
.................... ////                                                                   //// 
.................... //// October 23rd, 2002: usb_puts() will bomb out of error quicker     //// 
.................... ////                                                                   //// 
.................... //// August 2nd, 2002: Initial Public Release                          //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2005 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS    //// 
.................... //// C compiler.  This source code may only be distributed to other    //// 
.................... //// licensed users of the CCS C compiler.  No other use,              //// 
.................... //// reproduction or distribution is permitted without written         //// 
.................... //// permission.  Derivative programs created using this software      //// 
.................... //// in object code form are not restricted in any way.                //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #IFNDEF __USB_DRIVER__ 
.................... #DEFINE __USB_DRIVER__ 
....................  
.................... #include <usb.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                              usb.h                                //// 
.................... ////                                                                   //// 
.................... //// Function protypes, defintions and globals used by CCS USB driver  //// 
.................... ////                                                                   //// 
.................... //// This file is part of CCS's PIC USB driver code, which includes:   //// 
.................... ////   usb_desc_*.h - an example set of config and device descriptor   //// 
.................... ////   usb.c - USB token and request handler code                      //// 
.................... ////   usb.h - definitions, prototypes and global variables            //// 
.................... ////                                                                   //// 
.................... //// The following examples are provided by CCS:                       //// 
.................... ////   ex_usb_mouse.c - A HID Mouse.                                   //// 
.................... ////   ex_usb_hid.c - A custom application using HID protocol.         //// 
.................... ////   ex_usb_kbmouse.c - A HID Mouse/Keyboard combo using multiple    //// 
.................... ////                      interfaces.                                  //// 
.................... ////   ex_usb_kbmouse.c - A HID Mouse/Keyboard combo using multiple    //// 
.................... ////                      HID Reports.                                 //// 
.................... ////   ex_usb_scope.c - A digital oscilloscope using a custom          //// 
.................... ////                    protocol requiring custom Windows drivers.     //// 
.................... ////                                                                   //// 
.................... ////                   **** DEFINITIONS *****                          //// 
.................... //// The following definitions are declared here, but can be           //// 
.................... //// overwritten in your code.  Unless needed otherwise, leave         //// 
.................... //// to default value.  If confused about a definition read the        //// 
.................... //// comments at each defintion                                        //// 
.................... ////                                                                   //// 
.................... //// USB_HID_IDLE (FALSE) - Set to TRUE if your device supports        //// 
.................... ////                            Set_Idle HID class request.  Set to    //// 
.................... ////                            False if you do not (device will       //// 
.................... ////                            send a Wrong-state if computer         //// 
.................... ////                            sends a Set_Idle / Get_Idle command)   //// 
.................... ////                            NOTE: If you set to TRUE you must      //// 
.................... ////                            provide your own code.  See            //// 
.................... ////                            usb_isr_tkn_setup_ClassInterface() in  //// 
.................... ////                            usb.c                                  //// 
.................... ////                                                                   //// 
.................... //// USB_HID_BOOT_PROTOCOL (FALSE) - Set to TRUE if your device supports   //// 
.................... ////                            Set_Protocl HID class request. Set to  //// 
.................... ////                            False if you do not (device will       //// 
.................... ////                            send a Wrong-state if computer         //// 
.................... ////                            sends a Set_Protocl / Get_Protocol     //// 
.................... ////                            command).                              //// 
.................... ////                            NOTE: If you set to TRUE you must      //// 
.................... ////                            provide your own code in the           //// 
.................... ////                            application that properly send boot    //// 
.................... ////                            or HID packets.                        //// 
.................... ////                                                                   //// 
.................... //// USB_MAX_EP0_PACKET_LENGTH (8) - Max Packet size for Endpoint 0.   //// 
.................... ////                            Only the 18Fxx5x USB peripheral can    //// 
.................... ////                            have a value larger than 8.            //// 
.................... ////                                                                   //// 
.................... //// USB_EPx_RX_ENABLE (USB_ENABLE_DISABLED) - Where x is the          //// 
.................... ////                         endpoint number. Change this define       //// 
.................... ////                         to specify what kind of transfer method   //// 
.................... ////                         this RX (PC to device) endpoint uses.     //// 
.................... ////                       Here is the list of valid transfer methods: //// 
.................... ////                             USB_ENABLE_CONTROL                    //// 
.................... ////                             USB_ENABLE_ISOCHRONOUS                //// 
.................... ////                             USB_ENABLE_BULK                       //// 
.................... ////                             USB_ENABLE_INTERRUPT                  //// 
.................... ////                             USB_ENABLE_DISABLED                   //// 
.................... ////                        Don't forget that you must specify the     //// 
.................... ////                        transfer method properly in your endpoint  //// 
.................... ////                        descriptor, too.                           //// 
.................... ////                                                                   //// 
.................... //// USB_EPx_RX_SIZE (0) - For some hardware it is important to know   //// 
.................... ////                       how much memory to reserve for receiving    //// 
.................... ////                       packets.                                    //// 
.................... ////                                                                   //// 
.................... ////  *** NOTE *** You must have both USB_EPx_RX_ENABLE defined and    //// 
.................... ////               USB_EPx_RX_SIZE defined (non 0) to enable a RX      //// 
.................... ////               endpoint.                                           //// 
.................... ////  *** NOTE *** Endpoint 0 is always enabled.                       //// 
.................... ////                                                                   //// 
.................... //// USB_EPx_TX_ENABLE (USB_ENABLE_DISABLED) - Where x is the          //// 
.................... ////                         endpoint number. Change this define       //// 
.................... ////                         to specify what kind of transfer method   //// 
.................... ////                         this TX (device to PC) endpoint uses.     //// 
.................... ////                       Here is the list of valid transfer methods: //// 
.................... ////                             USB_ENABLE_CONTROL                    //// 
.................... ////                             USB_ENABLE_ISOCHRONOUS                //// 
.................... ////                             USB_ENABLE_BULK                       //// 
.................... ////                             USB_ENABLE_INTERRUPT                  //// 
.................... ////                             USB_ENABLE_DISABLED                   //// 
.................... ////                        Don't forget that you must specify the     //// 
.................... ////                        transfer method properly in your endpoint  //// 
.................... ////                        descriptor, too.                           //// 
.................... ////                                                                   //// 
.................... //// USB_EPx_TX_SIZE (0) - For some hardware it is important to know   //// 
.................... ////                       how much memory to reserve for transmitting //// 
.................... ////                       packets.                                    //// 
.................... ////                                                                   //// 
.................... ////  *** NOTE *** You must have both USB_EPx_TX_ENABLE defined and    //// 
.................... ////               USB_EPx_TX_SIZE defined (non 0) to enable a TX      //// 
.................... ////               endpoint.                                           //// 
.................... ////                                                                   //// 
.................... ////                                                                   //// 
.................... //// USB_HID_DEVICE (TRUE) - HID devices require extra code to handle  //// 
.................... ////                         HID requests.  You can disable to save    //// 
.................... ////                         ROM space if you are not using a HID      //// 
.................... ////                         device.  If you are not using a HID       //// 
.................... ////                         device you must provide your own O/S      //// 
.................... ////                         (Windows) driver.                         //// 
.................... ////                                                                   //// 
.................... //// The other definitions should not be changed.                      //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... //// Version History:                                                  //// 
.................... ////                                                                   //// 
.................... //// July 13th, 2005:                                                  //// 
.................... ////  usb_ep_tx_size[] and usb_ep_rx_size[] changed to 16bits          //// 
.................... ////                                                                   //// 
.................... //// June 20th, 2005:                                                  //// 
.................... ////  Initial 18fxx5x release                                          //// 
.................... ////                                                                   //// 
.................... //// May 13th, 2005:                                                   //// 
.................... ////  Beta release, only works with 18Fxx5x hardware layer.            //// 
.................... ////  Now supports multiple interfaces (many defines in descriptors    //// 
.................... ////   will have to be changed, see examples)                          //// 
.................... ////                                                                   //// 
.................... //// Mar 21st, 2005:                                                   //// 
.................... ////  Initial Alpha Release with PIC18Fxx5x support.  (ONLY TESTED     //// 
.................... ////   WITH 18F4550)                                                   //// 
.................... ////  usb_gets() and usb_puts() changed (see usb.c)                    //// 
.................... ////                                                                   //// 
.................... //// June 24th, 2004:                                                  //// 
.................... ////  Optimization and cleanup.                                        //// 
.................... ////                The following definitions changed:                 //// 
.................... ////  USB_EPx_TX_ENABLE and USB_EPx_RX_ENABLE have changed. See usb.h  //// 
.................... ////  USB_CONFIG_DESCRIPTORS[] removed                                 //// 
.................... ////  USB_CONFIG_DESC_LEN changed to USB_DESC_CONFIG_LEN               //// 
.................... ////  USB_INTERFACE_DESC_LEN changed to USB_DESC_INTERFACE_LEN         //// 
.................... ////  USB_CLASS_DESC_LEN changed to USB_DESC_CLASS_LEN                 //// 
.................... ////  USB_ENDPOINT_DESC_LEN changed to USB_DESC_ENDPOINT_LEN           //// 
.................... ////  USB_CONFIG_DESC_KEY changed to USB_DESC_CONFIG_TYPE              //// 
.................... ////  USB_INTERFACE_DESC_KEY changed to USB_DESC_INTERFACE_TYPE        //// 
.................... ////  USB_CLASS_DESC_KEY changed to USB_DESC_CLASS_TYPE                //// 
.................... ////  USB_ENDPOINT_DESC_KEY changed to USB_DESC_ENDPOINT_TYPE          //// 
.................... ////  USB_STRING_X[] arrays removed, see USB_STRING_DESC[] and         //// 
.................... ////                                 USB_STRING_DESC_OFFSET[]          //// 
.................... ////  dev_req, curr_config, status_device and getdesc_type global      //// 
.................... ////        variables moved into struct USB_stack_status               //// 
.................... ////                                                                   //// 
.................... //// October 15th, 2003: Support for boot protocol added.              //// 
.................... ////         Set USB_HID_BOOT_PROTOCOL to TRUE to support this.        //// 
.................... ////         The array hid_protocol[] saves which protocol mode each   //// 
.................... ////         interface is in.  It is your applications job to send     //// 
.................... ////         data that either fit the boot protocol or HID protocol.   //// 
.................... ////                                                                   //// 
.................... //// May 6th, 2003: Fixed a potential stack overflow using PCM         //// 
.................... ////                                                                   //// 
.................... //// October 29th, 2002: New definition added to USB_STATES            //// 
.................... ////                                                                   //// 
.................... //// August 2nd, 2002: Initial Public Release                          //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2005 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS    //// 
.................... //// C compiler.  This source code may only be distributed to other    //// 
.................... //// licensed users of the CCS C compiler.  No other use,              //// 
.................... //// reproduction or distribution is permitted without written         //// 
.................... //// permission.  Derivative programs created using this software      //// 
.................... //// in object code form are not restricted in any way.                //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
....................  
.................... #IFNDEF __USB_PROTOTYPES__ 
.................... #DEFINE __USB_PROTOTYPES__ 
....................  
.................... #IFNDEF USB_HID_BOOT_PROTOCOL 
....................    #DEFINE USB_HID_BOOT_PROTOCOL FALSE 
.................... #ENDIF 
....................  
.................... #IFNDEF USB_HID_IDLE 
....................    #DEFINE USB_HID_IDLE FALSE 
.................... #ENDIF 
....................  
.................... //should the compiler add the extra HID handler code?  Defaults to yes. 
.................... #IFNDEF USB_HID_DEVICE 
....................    #DEFINE USB_HID_DEVICE TRUE 
.................... #ENDIF 
....................  
.................... #IFNDEF USB_CDC_DEVICE 
....................    #DEFINE USB_CDC_DEVICE FALSE 
.................... #ENDIF 
....................  
.................... #ifndef USB_OPT_FOR_ROM 
....................    #define USB_OPT_FOR_ROM TRUE  //set to false to opt for less RAM, true to opt for less ROM 
.................... #endif 
....................  
.................... #IFNDEF USB_MAX_EP0_PACKET_LENGTH 
....................   #DEFINE USB_MAX_EP0_PACKET_LENGTH 8 
.................... #ENDIF 
....................  
.................... //CCS only supports one configuration at this time 
.................... #DEFINE USB_NUM_CONFIGURATIONS 1 //DO NOT CHANGE 
....................  
.................... //PID values for tokens (see page 48 of USB Complete ed.1) 
.................... #define PID_IN       0x09  //device to host transactions 
.................... #define PID_OUT      0x01  //host to device transactions 
.................... #define PID_SETUP    0x0D  //host to device setup transaction 
.................... #define PID_ACK      0x02  //receiver accepts error-free data packet 
.................... #define PID_DATA0    0x03  //data packet with even sync bit 
.................... #define PID_SOF      0x05  //start of framer marker and frame number 
.................... #define PID_NAK      0x0A  //receiver can't accept data or sender cant send data or has no data to transmit 
.................... #define PID_DATA1    0x0B  //data packet with odd sync bit 
.................... #define PID_PRE      0x0C  //preamble issued by host.  enables downstream traffic to low-speed device 
.................... #define PID_STALL    0x0E  //a control request isnt supported or the endpoint is halted 
....................  
.................... //Key which identifies descritpors 
.................... #DEFINE USB_DESC_DEVICE_TYPE     0x01  //#DEFINE USB_DEVICE_DESC_KEY      0x01 
.................... #DEFINE USB_DESC_CONFIG_TYPE     0x02  //#DEFINE USB_CONFIG_DESC_KEY      0x02 
.................... #DEFINE USB_DESC_STRING_TYPE     0x03  //#DEFINE USB_STRING_DESC_KEY      0x03 
.................... #DEFINE USB_DESC_INTERFACE_TYPE  0x04  //#DEFINE USB_INTERFACE_DESC_KEY   0x04 
.................... #DEFINE USB_DESC_ENDPOINT_TYPE   0x05  //#DEFINE USB_ENDPOINT_DESC_KEY    0x05 
.................... #DEFINE USB_DESC_CLASS_TYPE      0x21  //#DEFINE USB_CLASS_DESC_KEY       0x21 
.................... #DEFINE USB_DESC_HIDREPORT_TYPE  0x22 
....................  
.................... //The length of each descriptor 
.................... #DEFINE USB_DESC_DEVICE_LEN      18 //#DEFINE USB_DEVICE_DESC_LEN      18 
.................... #DEFINE USB_DESC_CONFIG_LEN      9  //#DEFINE USB_CONFIG_DESC_LEN      9 
.................... #DEFINE USB_DESC_INTERFACE_LEN   9  //#DEFINE USB_INTERFACE_DESC_LEN   9 
.................... #DEFINE USB_DESC_CLASS_LEN       9  //#DEFINE USB_CLASS_DESC_LEN       9 
.................... #DEFINE USB_DESC_ENDPOINT_LEN    7  //#DEFINE USB_ENDPOINT_DESC_LEN    7 
....................  
.................... //Standard USB Setup bRequest Codes 
.................... #define USB_STANDARD_REQUEST_GET_STATUS         0x00 
.................... #define USB_STANDARD_REQUEST_CLEAR_FEATURE      0x01 
.................... #define USB_STANDARD_REQUEST_SET_FEATURE        0x03 
.................... #define USB_STANDARD_REQUEST_SET_ADDRESS        0x05 
.................... #define USB_STANDARD_REQUEST_GET_DESCRIPTOR     0x06 
.................... #define USB_STANDARD_REQUEST_SET_DESCRIPTOR     0x07 
.................... #define USB_STANDARD_REQUEST_GET_CONFIGURATION  0x08 
.................... #define USB_STANDARD_REQUEST_SET_CONFIGURATION  0x09 
.................... #define USB_STANDARD_REQUEST_GET_INTERFACE      0x0A 
.................... #define USB_STANDARD_REQUEST_SET_INTERFACE      0x0B 
.................... #define USB_STANDARD_REQUEST_SYNCH_FRAME        0x0C 
....................  
.................... //HID Class Setup bRequest Codes 
.................... #define USB_HID_REQUEST_GET_REPORT     0x01 
.................... #define USB_HID_REQUEST_GET_IDLE       0x02 
.................... #define USB_HID_REQUEST_GET_PROTOCOL   0x03 
.................... #define USB_HID_REQUEST_SET_REPORT     0x09 
.................... #define USB_HID_REQUEST_SET_IDLE       0x0A 
.................... #define USB_HID_REQUEST_SET_PROTOCOL   0x0B 
....................  
.................... //types of endpoints as defined in the descriptor 
.................... #define USB_ENDPOINT_TYPE_CONTROL      0x00 
.................... #define USB_ENDPOINT_TYPE_ISOCHRONOUS  0x01 
.................... #define USB_ENDPOINT_TYPE_BULK         0x02 
.................... #define USB_ENDPOINT_TYPE_INTERRUPT    0x03 
....................  
.................... //types of endpoints used internally in this api 
.................... #define USB_ENABLE_DISABLED     0 
.................... #define USB_ENABLE_BULK         0x01 
.................... #define USB_ENABLE_ISOCHRONOUS  0x02 
.................... #define USB_ENABLE_INTERRUPT    0x03 
.................... #define USB_ENABLE_CONTROL      0x04 
....................  
.................... //// DO NOT CHANGE THE FOLLOWING VALUES: 
....................  
.................... enum USB_STATES {GET_DESCRIPTOR=1,SET_ADDRESS=2,NONE=0}; 
....................  
.................... enum USB_DTS_BIT {USB_DTS_DATA1=1, USB_DTS_TOGGLE=2, USB_DTS_DATA0=0, 
....................                    USB_DTS_STALL=3, USB_DTS_USERX=4}; 
....................  
.................... enum USB_GETDESC_TYPES {USB_GETDESC_CONFIG_TYPE=0,USB_GETDESC_HIDREPORT_TYPE=1,USB_GETDESC_STRING_TYPE=2,USB_GETDESC_DEVICE_TYPE=3}; 
....................  
.................... #if USB_OPT_FOR_ROM 
.................... struct { 
....................    USB_STATES dev_req;   //what did the last setup token set us up to do?.  init at none 
....................    int  curr_config;  //our current config.  start at none/powered (NOT THAT THIS LIMITS US TO 3 CONFIGURATIONS) 
....................    int status_device; //Holds our state for Set_Feature and Clear_Feature 
....................    USB_GETDESC_TYPES getdesc_type;   //which get_descriptor() we are handling 
.................... } USB_stack_status; 
.................... #else 
.................... struct { 
....................    USB_STATES dev_req:2;   //what did the last setup token set us up to do?.  init at none 
....................    int  Curr_config:2;  //our current config.  start at none/powered (NOT THAT THIS LIMITS US TO 3 CONFIGURATIONS) 
....................    int status_device:2; //Holds our state for Set_Feature and Clear_Feature 
....................    USB_GETDESC_TYPES getdesc_type:2;   //which get_descriptor() we are handling 
.................... } USB_stack_status; 
.................... #endif 
....................  
.................... int16 __usb_kbhit_status; 
....................  
.................... /// *** User function prototypes 
.................... void usb_wait_for_enumeration(void); 
.................... int1 usb_unermated(void); 
.................... int8 usb_gets(int8 endpoint, int8 * ptr, int16 max, int16 timeout); 
.................... int1 usb_puts(int8 endpoint, int8 * ptr, int16 len, int8 timeout); 
....................  
.................... /// *** Token and request hanlder function prototypes 
.................... void usb_token_reset(); 
....................  
.................... void usb_put_0len_0(void); 
.................... void usb_request_send_response(int len);   //always sends usb_ep0_rx_buffer[] to endpoint 0 with a toggle of DATA 
....................  
.................... void usb_match_registers(int8 endpoint, int16 *status, int16 *buffer, int8 *size); 
....................  
.................... void usb_isr_tok_in_dne(int8 endpoint); 
.................... void usb_isr_tok_out_dne(int8 endpoint); 
.................... void usb_isr_tok_setup_dne(void); 
....................  
.................... void usb_isr_tkn_setup_StandardEndpoint(void); 
.................... void usb_isr_tkn_setup_StandardDevice(void); 
.................... void usb_isr_tkn_setup_StandardInterface(void); 
....................  
.................... #IF USB_HID_DEVICE 
....................    void usb_isr_tkn_setup_ClassInterface(void); 
.................... #ENDIF 
....................  
.................... void usb_Get_Descriptor(void); 
.................... void usb_copy_desc_seg_to_ep(void); 
....................  
.................... void usb_finish_set_address(void); 
....................  
.................... //*** ENABLE RX ENDPOINTS AND BUFFERS 
....................  
.................... //--------- endpoint 0 defines ---------- 
.................... #define USB_EP0_TX_ENABLE  USB_ENABLE_CONTROL 
.................... #define USB_EP0_RX_ENABLE  USB_ENABLE_CONTROL 
.................... #define USB_EP0_RX_SIZE    USB_MAX_EP0_PACKET_LENGTH  //endpoint 0 is setup, and should always be the MAX_PACKET_LENGTH.  Slow speed specifies 8 
.................... #define USB_EP0_TX_SIZE    USB_MAX_EP0_PACKET_LENGTH  //endpoint 0 is setup, and should always be the MAX_PACKET_LENGTH.  Slow speed specifies 8 
....................  
.................... //--------- endpoint 1 defines ---------- 
.................... #ifndef USB_EP1_TX_ENABLE 
....................  #define USB_EP1_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP1_RX_ENABLE 
....................  #define USB_EP1_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP1_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP1_RX_SIZE 
....................   #undef USB_EP1_RX_SIZE 
....................  #endif 
....................  #define USB_EP1_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP1_RX_SIZE 
....................   #error You enabled EP1 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP1_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP1_TX_SIZE 
....................   #undef USB_EP1_TX_SIZE 
....................  #endif 
....................  #define USB_EP1_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP1_TX_SIZE 
....................   #error You enabled EP1 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 2 defines ---------- 
.................... #ifndef USB_EP2_TX_ENABLE 
....................  #define USB_EP2_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP2_RX_ENABLE 
....................  #define USB_EP2_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP2_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP2_RX_SIZE 
....................   #undef USB_EP2_RX_SIZE 
....................  #endif 
....................  #define USB_EP2_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP2_RX_SIZE 
....................   #error You enabled EP2 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP2_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP2_TX_SIZE 
....................   #undef USB_EP2_TX_SIZE 
....................  #endif 
....................  #define USB_EP2_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP2_TX_SIZE 
....................   #error You enabled EP2 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 3 defines ---------- 
.................... #ifndef USB_EP3_TX_ENABLE 
....................  #define USB_EP3_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP3_RX_ENABLE 
....................  #define USB_EP3_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP3_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP3_RX_SIZE 
....................   #undef USB_EP3_RX_SIZE 
....................  #endif 
....................  #define USB_EP3_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP3_RX_SIZE 
....................   #error You enabled EP3 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP3_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP3_TX_SIZE 
....................   #undef USB_EP3_TX_SIZE 
....................  #endif 
....................  #define USB_EP3_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP3_TX_SIZE 
....................   #error You enabled EP3 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 4 defines ---------- 
.................... #ifndef USB_EP4_TX_ENABLE 
....................  #define USB_EP4_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP4_RX_ENABLE 
....................  #define USB_EP4_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP4_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP4_RX_SIZE 
....................   #undef USB_EP4_RX_SIZE 
....................  #endif 
....................  #define USB_EP4_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP4_RX_SIZE 
....................   #error You enabled EP4 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP4_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP4_TX_SIZE 
....................   #undef USB_EP4_TX_SIZE 
....................  #endif 
....................  #define USB_EP4_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP4_TX_SIZE 
....................   #error You enabled EP4 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 5 defines ---------- 
.................... #ifndef USB_EP5_TX_ENABLE 
....................  #define USB_EP5_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP5_RX_ENABLE 
....................  #define USB_EP5_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP5_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP5_RX_SIZE 
....................   #undef USB_EP5_RX_SIZE 
....................  #endif 
....................  #define USB_EP5_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP5_RX_SIZE 
....................   #error You enabled EP5 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP5_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP5_TX_SIZE 
....................   #undef USB_EP5_TX_SIZE 
....................  #endif 
....................  #define USB_EP5_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP5_TX_SIZE 
....................   #error You enabled EP5 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 6 defines ---------- 
.................... #ifndef USB_EP6_TX_ENABLE 
....................  #define USB_EP6_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP6_RX_ENABLE 
....................  #define USB_EP6_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP6_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP6_RX_SIZE 
....................   #undef USB_EP6_RX_SIZE 
....................  #endif 
....................  #define USB_EP6_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP6_RX_SIZE 
....................   #error You enabled EP6 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP6_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP6_TX_SIZE 
....................   #undef USB_EP6_TX_SIZE 
....................  #endif 
....................  #define USB_EP6_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP6_TX_SIZE 
....................   #error You enabled EP6 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 7 defines ---------- 
.................... #ifndef USB_EP7_TX_ENABLE 
....................  #define USB_EP7_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP7_RX_ENABLE 
....................  #define USB_EP7_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP7_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP7_RX_SIZE 
....................   #undef USB_EP7_RX_SIZE 
....................  #endif 
....................  #define USB_EP7_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP7_RX_SIZE 
....................   #error You enabled EP7 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP7_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP7_TX_SIZE 
....................   #undef USB_EP7_TX_SIZE 
....................  #endif 
....................  #define USB_EP7_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP7_TX_SIZE 
....................   #error You enabled EP7 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 8 defines ---------- 
.................... #ifndef USB_EP8_TX_ENABLE 
....................  #define USB_EP8_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP8_RX_ENABLE 
....................  #define USB_EP8_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP8_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP8_RX_SIZE 
....................   #undef USB_EP8_RX_SIZE 
....................  #endif 
....................  #define USB_EP8_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP8_RX_SIZE 
....................   #error You enabled EP8 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP8_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP8_TX_SIZE 
....................   #undef USB_EP8_TX_SIZE 
....................  #endif 
....................  #define USB_EP8_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP8_TX_SIZE 
....................   #error You enabled EP8 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 9 defines ---------- 
.................... #ifndef USB_EP9_TX_ENABLE 
....................  #define USB_EP9_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP9_RX_ENABLE 
....................  #define USB_EP9_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP9_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP9_RX_SIZE 
....................   #undef USB_EP9_RX_SIZE 
....................  #endif 
....................  #define USB_EP9_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP9_RX_SIZE 
....................   #error You enabled EP9 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP9_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP9_TX_SIZE 
....................   #undef USB_EP9_TX_SIZE 
....................  #endif 
....................  #define USB_EP9_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP9_TX_SIZE 
....................   #error You enabled EP9 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 10 defines ---------- 
.................... #ifndef USB_EP10_TX_ENABLE 
....................  #define USB_EP10_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP10_RX_ENABLE 
....................  #define USB_EP10_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP10_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP10_RX_SIZE 
....................   #undef USB_EP10_RX_SIZE 
....................  #endif 
....................  #define USB_EP10_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP10_RX_SIZE 
....................   #error You enabled EP10 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP10_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP10_TX_SIZE 
....................   #undef USB_EP10_TX_SIZE 
....................  #endif 
....................  #define USB_EP10_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP10_TX_SIZE 
....................   #error You enabled EP10 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 11 defines ---------- 
.................... #ifndef USB_EP11_TX_ENABLE 
....................  #define USB_EP11_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP11_RX_ENABLE 
....................  #define USB_EP11_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP11_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP11_RX_SIZE 
....................   #undef USB_EP11_RX_SIZE 
....................  #endif 
....................  #define USB_EP11_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP11_RX_SIZE 
....................   #error You enabled EP11 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP11_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP11_TX_SIZE 
....................   #undef USB_EP11_TX_SIZE 
....................  #endif 
....................  #define USB_EP11_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP11_TX_SIZE 
....................   #error You enabled EP11 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 12 defines ---------- 
.................... #ifndef USB_EP12_TX_ENABLE 
....................  #define USB_EP12_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP12_RX_ENABLE 
....................  #define USB_EP12_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP12_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP12_RX_SIZE 
....................   #undef USB_EP12_RX_SIZE 
....................  #endif 
....................  #define USB_EP12_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP12_RX_SIZE 
....................   #error You enabled EP12 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP12_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP12_TX_SIZE 
....................   #undef USB_EP12_TX_SIZE 
....................  #endif 
....................  #define USB_EP12_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP12_TX_SIZE 
....................   #error You enabled EP12 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 13 defines ---------- 
.................... #ifndef USB_EP13_TX_ENABLE 
....................  #define USB_EP13_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP13_RX_ENABLE 
....................  #define USB_EP13_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP13_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP13_RX_SIZE 
....................   #undef USB_EP13_RX_SIZE 
....................  #endif 
....................  #define USB_EP13_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP13_RX_SIZE 
....................   #error You enabled EP13 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP13_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP13_TX_SIZE 
....................   #undef USB_EP13_TX_SIZE 
....................  #endif 
....................  #define USB_EP13_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP13_TX_SIZE 
....................   #error You enabled EP13 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 14 defines ---------- 
.................... #ifndef USB_EP14_TX_ENABLE 
....................  #define USB_EP14_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP14_RX_ENABLE 
....................  #define USB_EP14_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP14_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP14_RX_SIZE 
....................   #undef USB_EP14_RX_SIZE 
....................  #endif 
....................  #define USB_EP14_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP14_RX_SIZE 
....................   #error You enabled EP14 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP14_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP14_TX_SIZE 
....................   #undef USB_EP14_TX_SIZE 
....................  #endif 
....................  #define USB_EP14_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP14_TX_SIZE 
....................   #error You enabled EP14 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 15 defines ---------- 
.................... #ifndef USB_EP15_TX_ENABLE 
....................  #define USB_EP15_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP15_RX_ENABLE 
....................  #define USB_EP15_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP15_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP15_RX_SIZE 
....................   #undef USB_EP15_RX_SIZE 
....................  #endif 
....................  #define USB_EP15_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP15_RX_SIZE 
....................   #error You enabled EP15 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP15_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP15_TX_SIZE 
....................   #undef USB_EP15_TX_SIZE 
....................  #endif 
....................  #define USB_EP15_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP15_TX_SIZE 
....................   #error You enabled EP15 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... const int8 usb_ep_tx_type[16]={ 
....................   USB_EP0_TX_ENABLE, USB_EP1_TX_ENABLE, USB_EP2_TX_ENABLE, 
....................   USB_EP3_TX_ENABLE, USB_EP4_TX_ENABLE, USB_EP5_TX_ENABLE, 
....................   USB_EP6_TX_ENABLE, USB_EP7_TX_ENABLE, USB_EP8_TX_ENABLE, 
....................   USB_EP9_TX_ENABLE, USB_EP10_TX_ENABLE, USB_EP11_TX_ENABLE, 
....................   USB_EP12_TX_ENABLE, USB_EP13_TX_ENABLE, USB_EP14_TX_ENABLE, 
....................   USB_EP15_TX_ENABLE 
.................... }; 
....................  
.................... const int8 usb_ep_rx_type[16]={ 
....................   USB_EP0_RX_ENABLE, USB_EP1_RX_ENABLE, USB_EP2_RX_ENABLE, 
....................   USB_EP3_RX_ENABLE, USB_EP4_RX_ENABLE, USB_EP5_RX_ENABLE, 
....................   USB_EP6_RX_ENABLE, USB_EP7_RX_ENABLE, USB_EP8_RX_ENABLE, 
....................   USB_EP9_RX_ENABLE, USB_EP10_RX_ENABLE, USB_EP11_RX_ENABLE, 
....................   USB_EP12_RX_ENABLE, USB_EP13_RX_ENABLE, USB_EP14_RX_ENABLE, 
....................   USB_EP15_RX_ENABLE 
.................... }; 
....................  
.................... const int16 usb_ep_tx_size[16]={ 
....................   USB_EP0_TX_SIZE, USB_EP1_TX_SIZE, USB_EP2_TX_SIZE, 
....................   USB_EP3_TX_SIZE, USB_EP4_TX_SIZE, USB_EP5_TX_SIZE, 
....................   USB_EP6_TX_SIZE, USB_EP7_TX_SIZE, USB_EP8_TX_SIZE, 
....................   USB_EP9_TX_SIZE, USB_EP10_TX_SIZE, USB_EP11_TX_SIZE, 
....................   USB_EP12_TX_SIZE, USB_EP13_TX_SIZE, USB_EP14_TX_SIZE, 
....................   USB_EP15_TX_SIZE 
.................... }; 
....................  
.................... const int16 usb_ep_rx_size[16]={ 
....................   USB_EP0_RX_SIZE, USB_EP1_RX_SIZE, USB_EP2_RX_SIZE, 
....................   USB_EP3_RX_SIZE, USB_EP4_RX_SIZE, USB_EP5_RX_SIZE, 
....................   USB_EP6_RX_SIZE, USB_EP7_RX_SIZE, USB_EP8_RX_SIZE, 
....................   USB_EP9_RX_SIZE, USB_EP10_RX_SIZE, USB_EP11_RX_SIZE, 
....................   USB_EP12_RX_SIZE, USB_EP13_RX_SIZE, USB_EP14_RX_SIZE, 
....................   USB_EP15_RX_SIZE 
.................... }; 
....................  
.................... #ENDIF 
....................  
....................  
.................... #IFNDEF __USB_HARDWARE__ 
....................    #ERROR You must include USB hardware driver. 
.................... #ENDIF 
....................  
.................... #IFNDEF __USB_DESCRIPTORS__ 
....................    #ERROR You must include USB descriptors. 
.................... #ENDIF 
....................  
.................... int8 USB_address_pending;                        //save previous state because packets can take several isrs 
.................... int8 usb_getdesc_ptr; int8 usb_getdesc_len=0;             //for reading string and config descriptors 
....................  
.................... #IF USB_HID_BOOT_PROTOCOL 
.................... int8 hid_protocol[USB_NUM_HID_INTERFACES]; 
.................... #ENDIF 
....................  
.................... int8 USB_Interface[USB_MAX_NUM_INTERFACES];              //config state for all of our interfaces, NUM_INTERFACES defined with descriptors 
....................  
.................... /// BEGIN User Functions 
....................  
.................... /**************************************************************************** 
.................... /* usb_kbhit(endpoint) 
.................... /* 
.................... /* Input: endpoint - endpoint to check 
.................... /* 
.................... /* Output: TRUE if there is new data in RX buffer, FALSE if there is not. 
.................... /* 
.................... /* Summary: Similar to kbhit(), sees if there is new data in the RX USB buffers. 
.................... /* 
.................... /*****************************************************************************/ 
.................... #define usb_kbhit(x) bit_test(__usb_kbhit_status,x) 
....................  
.................... /************************************************************** 
.................... /* usb_enumerated() 
.................... /* 
.................... /* Input: Global variable USB_Curr_Config 
.................... /* Returns: Returns a 1 if device is configured / enumerated, 
.................... /*          Returns a 0 if device is un-configured / not enumerated. 
.................... /* 
.................... /* Summary: Use this to see if device is configured / enumerated. 
.................... /***************************************************************/ 
.................... #define usb_enumerated() (USB_stack_status.curr_config) 
....................  
.................... /************************************************************** 
.................... /* usb_wait_for_enumeration() 
.................... /* 
.................... /* Input: Global variable USB_Curr_Config 
.................... /* 
.................... /* Summary: Waits in-definately until device is configured / enumerated. 
.................... /***************************************************************/ 
.................... void usb_wait_for_enumeration(void) { 
....................    while (USB_stack_status.curr_config == 0) {restart_wdt();} 
.................... } 
....................  
.................... /**************************************************************************** 
.................... /* usb_puts(endpoint, *ptr, len, timeout) 
.................... /* 
.................... /* Inputs: endpoint - endpoint to send data out 
.................... /*         ptr - points to array of data to send 
.................... /*         len - amount of data to send 
.................... /*         timeout - time in milli-seconds, for each packet, to wait before timeout. 
.................... /*                   set to 0 for no timeout. 
.................... /* 
.................... /* Summary: Used for sending multiple packets of data as one message.  If sending 
.................... /*          only one packet it is more effecient to use only usb_put_packet() 
.................... /* 
.................... /*****************************************************************************/ 
.................... int1 usb_puts(int8 endpoint, int8 * ptr, int16 len, int8 timeout) { 
....................    int16 i=0; 
....................    int1 res; 
....................    int16 this_packet_len; 
....................    int16 packet_size; 
....................    int32 timeout_1us; 
....................  
....................    packet_size=usb_ep_tx_size[endpoint]; 
....................  
....................    //send data packets until timeout or no more packets to send 
....................    while (i < len) { 
....................       timeout_1us=(int32)timeout*1000; 
....................       if ((len - i) > packet_size) {this_packet_len=packet_size;} 
....................       else {this_packet_len=len-i;} 
....................       do { 
....................          res=usb_put_packet(endpoint,ptr + i,this_packet_len,USB_DTS_TOGGLE);   //send 64 byte packets 
....................          if (!res) { 
....................             delay_us(1); 
....................             timeout_1us--; 
....................          } 
....................       } while (!res && timeout_1us); 
....................       i+=packet_size; 
....................    } 
....................  
....................  
....................    //send 0len packet if needed 
....................    if (i==len) { 
....................       timeout_1us=(int32)timeout*1000; 
....................       do { 
....................          res=usb_put_packet(endpoint,0,0,USB_DTS_TOGGLE);   //indicate end of message 
....................          if (!res) { 
....................             delay_us(1); 
....................             timeout_1us--; 
....................          } 
....................       } while (!res && timeout_1us); 
....................    } 
....................  
....................    return(res); 
.................... } 
....................  
.................... /**************************************************************************** 
.................... /* usb_gets(endpoint, ptr, max, timeout) 
.................... /* 
.................... /* Input: endpoint - endpoint to get data from 
.................... /*        ptr - place / array to store data to 
.................... /*        max - max amount of data to get from USB and store into ptr 
.................... /*         timeout - time in milliseconds, for each packet, to wait before timeout. 
.................... /*                   set to 0 for no timeout. 
.................... /* 
.................... /* Output: Amount of data returned.  It may be less than max. 
.................... /* 
.................... /* Summary: Gets data from the host.  Will get multiple-packet messages 
.................... /*          and finish when either it receives a 0-len packet or a packet 
.................... /*          of less size than maximum. 
.................... /* 
.................... /* NOTE: NOT THOUROUGHLY TESTED.  I AM NOT EVEN SURE IF THIS IS A GOOD IDEA 
.................... /* 
.................... /*****************************************************************************/ 
.................... int8 usb_gets(int8 endpoint, int8 * ptr, int16 max, int16 timeout) { 
....................    int16 ret=0; 
....................    int16 to; 
....................    int16 len; 
....................    int16 packet_size; 
....................    int16 this_packet_max; 
....................  
....................    packet_size=usb_ep_rx_size[endpoint]; 
....................  
....................    do { 
....................       if (packet_size < max) {this_packet_max=packet_size;} else {this_packet_max=max;} 
....................       to=0; 
....................       do { 
....................          if (usb_kbhit(endpoint)) { 
....................             len=usb_get_packet(endpoint,ptr,this_packet_max); 
....................             ptr+=len; 
....................             max-=len; 
....................             ret+=len; 
....................             break; 
....................          } 
....................          else { 
....................             to++; 
....................             delay_ms(1); 
....................          } 
....................       } while (to!=timeout); 
....................    } while ((len == packet_size) && (to!=timeout) && max); 
....................  
....................    return(ret); 
.................... } 
....................  
.................... /// END User Functions 
....................  
....................  
.................... /// BEGIN USB Token, standard and HID request handler (part of ISR) 
....................  
.................... /************************************************************** 
.................... /* usb_token_reset() 
.................... /* 
.................... /* Output: modifies global variables USB_Interface[], in[], usb_getdesc_ptr, 
.................... /*         usb_getdesc_len, USB_status_device, USB_dev_req 
.................... /* 
.................... /* Summary: Resets the token handler to initial (unconfigured) state. 
.................... /***************************************************************/ 
.................... void usb_token_reset() { 
....................    int i; 
....................  
....................  
....................  
....................       for (i=0;i<USB_MAX_NUM_INTERFACES;i++) { 
*
1A6C:  MOVLB  2
1A6E:  CLRF   x99
1A70:  MOVF   x99,W
1A72:  SUBLW  01
1A74:  BNC   1A8A
....................          USB_Interface[i]=0;   //reset each interface to default 
1A76:  CLRF   03
1A78:  MOVF   x99,W
1A7A:  ADDLW  2E
1A7C:  MOVWF  FE9
1A7E:  MOVLW  00
1A80:  ADDWFC 03,W
1A82:  MOVWF  FEA
1A84:  CLRF   FEF
....................       } 
....................  
....................   #IF USB_HID_BOOT_PROTOCOL 
....................    for (i=0;i<USB_NUM_HID_INTERFACES; i++) { 
....................        hid_protocol[i]=1; 
....................    } 
....................   #endif 
....................  
....................   #if USB_CDC_DEVICE 
1A86:  INCF   x99,F
1A88:  BRA    1A70
....................    usb_cdc_init(); 
1A8A:  MOVLB  0
1A8C:  RCALL  1A48
....................   #endif 
....................  
....................     USB_stack_status.curr_config=0;      //unconfigured device 
1A8E:  CLRF   20
....................  
....................     USB_stack_status.status_device=1;    //previous state.  init at none 
1A90:  MOVLW  01
1A92:  MOVWF  21
....................     USB_stack_status.dev_req=NONE;       //previous token request state.  init at none 
1A94:  CLRF   1F
.................... } 
1A96:  RETLW  00
....................  
.................... //send a 0len packet to endpoint 0 (optimization) 
.................... //notice that this doesnt return the status 
.................... #define usb_put_0len_0() usb_request_send_response(0) 
....................  
.................... /************************************************************** 
.................... /* usb_endpoint_is_valid(endpoint) 
.................... /* 
.................... /* Input: endpoint - endpoint to check. 
.................... /*                   bit 7 is direction (set is IN, clear is OUT) 
.................... /* 
.................... /* Output: TRUE if endpoint is valid, FALSE if not 
.................... /* 
.................... /* Summary: Checks the dynamic configuration to see if requested 
.................... /*          endpoint is a valid endpoint. 
.................... /***************************************************************/ 
.................... // 
.................... int1 usb_endpoint_is_valid(int8 endpoint) { 
....................    int1 direction; 
....................    direction = bit_test(endpoint,7); 
*
1F5A:  MOVLB  2
1F5C:  BCF    x9B.0
1F5E:  BTFSC  x9A.7
1F60:  BSF    x9B.0
....................    endpoint &= 0x7F; 
1F62:  BCF    x9A.7
....................    if (direction) { //IN 
1F64:  BTFSS  x9B.0
1F66:  BRA    1F8C
....................       return(usb_ep_tx_type[endpoint] != USB_ENABLE_DISABLED); 
1F68:  CLRF   03
1F6A:  MOVF   x9A,W
1F6C:  MOVFF  FF2,29C
1F70:  BCF    FF2.7
1F72:  MOVLB  0
1F74:  RCALL  189E
1F76:  MOVLB  2
1F78:  BTFSC  x9C.7
1F7A:  BSF    FF2.7
1F7C:  XORLW  00
1F7E:  BNZ   1F84
1F80:  MOVLW  00
1F82:  BRA    1F86
1F84:  MOVLW  01
1F86:  MOVWF  01
1F88:  BRA    1FAE
....................    } 
....................    else {   //OUT 
1F8A:  BRA    1FAE
....................       return(usb_ep_rx_type[endpoint] != USB_ENABLE_DISABLED); 
1F8C:  CLRF   03
1F8E:  MOVF   x9A,W
1F90:  MOVFF  FF2,29C
1F94:  BCF    FF2.7
1F96:  MOVLB  0
1F98:  RCALL  18BE
1F9A:  MOVLB  2
1F9C:  BTFSC  x9C.7
1F9E:  BSF    FF2.7
1FA0:  XORLW  00
1FA2:  BNZ   1FA8
1FA4:  MOVLW  00
1FA6:  BRA    1FAA
1FA8:  MOVLW  01
1FAA:  MOVWF  01
1FAC:  BRA    1FAE
....................    } 
.................... } 
1FAE:  MOVLB  0
1FB0:  GOTO   20A0 (RETURN)
....................  
.................... ///---------------------------------------------------------------/// 
.................... /// Processing Message stages is the biggest portion of the ISR   /// 
.................... ///---------------------------------------------------------------/// 
....................  
.................... /************************************************************** 
.................... /* usb_isr_tok_in_dne(endpoint) 
.................... /* 
.................... /* Input: endpoint - which endpoint we are processing a setup token.  Should be 0. 
.................... /* 
.................... /* Summary: When receiving an IN token from the PC on endpoint 0 that means the 
.................... /*          host is asking for a response from a setup token, or the next packet 
.................... /*          from a currently processing token.  (For example, a 24 byte descriptor 
.................... /*          would require 3 IN tokens if the packet size is 8 bytes.)  USB_dev_req 
.................... /*          is a global variable that defines what setup token we are currently processing. 
.................... /* 
.................... /* Part of USB interrupt service routine. 
.................... /* Only checks endpoint 0. 
.................... /***************************************************************/ 
.................... void usb_isr_tok_in_dne(int8 endpoint) { 
....................    if (endpoint==0) { 
*
259E:  MOVLB  2
25A0:  MOVF   x9A,F
25A2:  BNZ   25C0
....................       if (USB_stack_status.dev_req == GET_DESCRIPTOR) {usb_copy_desc_seg_to_ep();} //check this, we are missing report descriptor? 
25A4:  DECFSZ 1F,W
25A6:  BRA    25B2
25A8:  MOVLB  0
25AA:  CALL   1B3A
....................       else if (USB_stack_status.dev_req == SET_ADDRESS) {usb_finish_set_address();} 
25AE:  BRA    25BC
25B0:  MOVLB  2
25B2:  MOVF   1F,W
25B4:  SUBLW  02
25B6:  BNZ   25BE
25B8:  MOVLB  0
25BA:  BRA    24B0
25BC:  MOVLB  2
....................    } 
....................   #if USB_CDC_DEVICE 
....................   else if (endpoint==USB_CDC_DATA_IN_ENDPOINT) { //see ex_usb_serial.c example and usb_cdc.h driver 
25BE:  BRA    25CC
25C0:  MOVF   x9A,W
25C2:  SUBLW  02
25C4:  BNZ   25CC
....................       usb_isr_tok_in_cdc_data_dne(); 
25C6:  MOVLB  0
25C8:  BRA    2590
25CA:  MOVLB  2
....................   } 
....................   #endif 
.................... } 
25CC:  MOVLB  0
25CE:  RETLW  00
....................  
.................... /************************************************************** 
.................... /* usb_isr_tok_out_dne(endpoint) 
.................... /* 
.................... /* Input: endpoint contains which endpoint we are receiving data. 
.................... /*        This code doesn't allow reception of data from EP0. (Add later) 
.................... /* 
.................... /* Summary: Processes out tokens (out is respective of the host, so actualy incoming 
.................... /*          to the pic), but not out setup tokens.  Data is placed into a 
.................... /*          a buffer if it is empty, and the rx flag is set.  If the buffer 
.................... /*          is not empty then the overrun bit of that EP status byte is set it. 
.................... /***************************************************************/ 
.................... void usb_isr_tok_out_dne(int8 endpoint) { 
....................    //TODO: 
....................    if (endpoint==0) { 
*
2458:  MOVLB  2
245A:  MOVF   x9A,F
245C:  BNZ   2466
....................      debug_usb(debug_putc,"TOUT 0 "); 
....................      #if USB_CDC_DEVICE 
....................       usb_isr_tok_out_cdc_control_dne(); 
245E:  MOVLB  0
2460:  BRA    23B2
....................      #else 
....................       usb_init_ep0_setup(); 
....................      #endif 
....................    } 
....................   #if USB_CDC_DEVICE 
....................    else if (endpoint==USB_CDC_DATA_OUT_ENDPOINT) { //see ex_usb_serial.c example and usb_cdc.h driver 
2462:  BRA    2492
2464:  MOVLB  2
2466:  MOVF   x9A,W
2468:  SUBLW  02
246A:  BNZ   2474
....................       usb_isr_tok_out_cdc_data_dne(); 
246C:  MOVLB  0
246E:  BRA    2442
....................    } 
....................   #endif 
....................    else { 
2470:  BRA    2492
2472:  MOVLB  2
....................       bit_set(__usb_kbhit_status,endpoint); 
2474:  CLRF   03
2476:  MOVLW  01
2478:  MOVWF  02
247A:  MOVF   x9A,W
247C:  MOVWF  00
247E:  BZ    248A
2480:  BCF    FD8.0
2482:  RLCF   02,F
2484:  RLCF   03,F
2486:  DECFSZ 00,F
2488:  BRA    2480
248A:  MOVF   02,W
248C:  IORWF  23,F
248E:  MOVF   03,W
2490:  IORWF  24,F
2492:  MOVLB  0
....................    } 
.................... } 
2494:  RETLW  00
....................  
....................  
.................... //---- process setup message stage -----------// 
.................... ////// HUGE - most of our code is to read setup messages //// 
....................  
.................... /************************************************************** 
.................... /* usb_isr_tok_setup_dne() 
.................... /* 
.................... /* Input: usb_ep0_rx_buffer[] contains the 8 bytes of the setup packet. 
.................... /* 
.................... /* Output: The DTS we expect for the next packet on OUT 0. 
.................... /* 
.................... /* Summary: This function is the start of code that handles the setup token. 
.................... /*          We must handle all relevant requests, such as Set_Configuration, Get_Descriptor, etc. 
.................... /* 
.................... /*  usb_ep0_rx_buffer[8] now contains setup data packet, which has the following records 
.................... /*  ------------------------------------------------------------------------------------------- 
.................... /*  usb_ep0_rx_buffer[ 0 ]=bmRequestType; Where the setup packet goes 
.................... /*                              bit7   (0) host-to-device 
.................... /*                                     (1) device-to-host 
.................... /*                              bit6-5 (00) usb standard request; 
.................... /*                                     (01) class request; 
.................... /*                                     (10) vendor request 
....................                                        (11) reserved 
.................... /*                              bit4-0 (0000) device 
.................... /*                                     (0001) interface 
.................... /*                                     (0010) endpoint 
.................... /*                                     (0011) other element 
.................... /*                                     (0100) to (1111) reserved 
.................... /*  usb_ep0_rx_buffer[ 1 ]=bRequest ; the request 
.................... /*  usb_ep0_rx_buffer[2,3]=wValue ; a value which corresponds to request 
.................... /*  usb_ep0_rx_buffer[4,5]=wIndex ; could correspond to interface or endpoint... 
.................... /*  usb_ep0_rx_buffer[6,7]=wLength ; number of bytes in next data packet 
.................... /*                        for host-to-device, this exactly how many bytes in data packet 
.................... /*                        for device-to-host, this is the maximum bytes that can fit one packet 
.................... /***************************************************************/ 
.................... void usb_isr_tok_setup_dne(void) { 
....................    USB_stack_status.dev_req=NONE; // clear the device request.. 
*
21B8:  CLRF   1F
....................  
....................    switch(usb_ep0_rx_buffer[0] & 0x7F) { 
21BA:  MOVLB  5
21BC:  MOVF   x00,W
21BE:  ANDLW  7F
21C0:  MOVLB  0
21C2:  BZ    21D2
21C4:  XORLW  01
21C6:  BZ    21D4
21C8:  XORLW  03
21CA:  BZ    21D6
21CC:  XORLW  23
21CE:  BZ    21D8
21D0:  BRA    21DA
....................  
....................       case 0x00:  //standard to device 
....................          debug_usb(debug_putc," d"); 
....................          usb_isr_tkn_setup_StandardDevice(); 
21D2:  BRA    1DFE
....................          break; 
....................  
....................       case 0x01:  //standard to interface 
....................          debug_usb(debug_putc," i"); 
....................          usb_isr_tkn_setup_StandardInterface(); 
21D4:  BRA    1EB2
....................          break; 
....................  
....................       case 0x02:  //standard to endpoint 
....................          debug_usb(debug_putc," e"); 
....................          usb_isr_tkn_setup_StandardEndpoint(); 
21D6:  BRA    209A
....................          break; 
....................  
.................... #IF USB_HID_DEVICE 
....................       case 0x21:  //class specific request.  the only class this driver supports is HID 
....................          debug_usb(debug_putc," hid"); 
....................          usb_isr_tkn_setup_ClassInterface(); 
....................          break; 
.................... #endif 
....................  
.................... #if USB_CDC_DEVICE 
....................       case 0x21: 
....................          debug_usb(debug_putc," cdc"); 
....................          usb_isr_tkn_cdc(); 
21D8:  BRA    210A
....................          break; 
.................... #endif 
....................       //TODO: IF YOU WANT VENDOR SPECIFC REQUEST SUPPORT YOU MUST ADD IT HERE 
....................  
....................       default: 
....................          usb_request_stall(); 
21DA:  RCALL  1B34
....................          break; 
21DC:  BRA    21DE
....................    } 
.................... } 
21DE:  GOTO   25F2 (RETURN)
....................  
.................... /************************************************************** 
.................... /* usb_isr_tkn_setup_StandardDevice() 
.................... /* 
.................... /* Input: usb_ep0_rx_buffer[1] == bRequest 
.................... /* 
.................... /* Summary: bmRequestType told us it was a Standard Device request. 
.................... /*          bRequest says which request.  Only certain requests are valid, 
.................... /*          if a non-valid request was made then return with an Wrong-Statue (IDLE) 
.................... /* 
.................... /* Part of usb_isr_tok_setup_dne() 
.................... /***************************************************************/ 
.................... void usb_isr_tkn_setup_StandardDevice(void) { 
....................    switch(usb_ep0_rx_buffer[1]) { 
*
1DFE:  MOVLB  5
1E00:  MOVF   x01,W
1E02:  MOVLB  0
1E04:  BZ    1E20
1E06:  XORLW  01
1E08:  BZ    1E34
1E0A:  XORLW  02
1E0C:  BZ    1E4E
1E0E:  XORLW  06
1E10:  BZ    1E66
1E12:  XORLW  03
1E14:  BZ    1E78
1E16:  XORLW  0E
1E18:  BZ    1E7A
1E1A:  XORLW  01
1E1C:  BZ    1E8A
1E1E:  BRA    1EAA
....................  
....................       case USB_STANDARD_REQUEST_GET_STATUS:  //0 
....................             debug_usb(debug_putc,"GS"); 
....................             usb_ep0_tx_buffer[0]=USB_stack_status.status_device; 
1E20:  MOVFF  21,540
....................             usb_ep0_tx_buffer[1]=0; 
1E24:  MOVLB  5
1E26:  CLRF   x41
....................             usb_request_send_response(2); 
1E28:  MOVLW  02
1E2A:  MOVLB  2
1E2C:  MOVWF  x9D
1E2E:  MOVLB  0
1E30:  RCALL  1B2E
....................             break; 
1E32:  BRA    1EAE
....................  
....................       case USB_STANDARD_REQUEST_CLEAR_FEATURE:  //1 
....................             if (usb_ep0_rx_buffer[2] == 1) { 
1E34:  MOVLB  5
1E36:  DECFSZ x02,W
1E38:  BRA    1E48
....................                debug_usb(debug_putc,"CF"); 
....................                USB_stack_status.status_device &= 1; 
1E3A:  MOVLW  01
1E3C:  ANDWF  21,F
....................                usb_put_0len_0(); 
1E3E:  MOVLB  2
1E40:  CLRF   x9D
1E42:  MOVLB  0
1E44:  RCALL  1B2E
....................             } 
....................             else 
1E46:  BRA    1E4C
....................                usb_request_stall(); 
1E48:  MOVLB  0
1E4A:  RCALL  1B34
....................             break; 
1E4C:  BRA    1EAE
....................  
....................       case USB_STANDARD_REQUEST_SET_FEATURE: //3 
....................             if (usb_ep0_rx_buffer[2] == 1) { 
1E4E:  MOVLB  5
1E50:  DECFSZ x02,W
1E52:  BRA    1E60
....................                debug_usb(debug_putc,"SF"); 
....................                USB_stack_status.status_device |= 2; 
1E54:  BSF    21.1
....................                usb_put_0len_0(); 
1E56:  MOVLB  2
1E58:  CLRF   x9D
1E5A:  MOVLB  0
1E5C:  RCALL  1B2E
....................             } 
....................             else 
1E5E:  BRA    1E64
....................                usb_request_stall(); 
1E60:  MOVLB  0
1E62:  RCALL  1B34
....................             break; 
1E64:  BRA    1EAE
....................  
....................       case USB_STANDARD_REQUEST_SET_ADDRESS: //5 
....................             debug_usb(debug_putc,"SA"); 
....................             USB_stack_status.dev_req=SET_ADDRESS; //currently processing set_address request 
1E66:  MOVLW  02
1E68:  MOVWF  1F
....................             USB_address_pending=usb_ep0_rx_buffer[2]; 
1E6A:  MOVFF  502,2B
....................             #ifdef __USBN__   //NATIONAL part handles this differently than pic16c7x5 
....................             USB_stack_status.dev_req=NONE; //currently processing set_address request 
....................             usb_set_address(USB_address_pending); 
....................          	USB_stack_status.curr_config=0;	// make sure current configuration is 0 
....................             #endif 
....................             usb_put_0len_0(); 
1E6E:  MOVLB  2
1E70:  CLRF   x9D
1E72:  MOVLB  0
1E74:  RCALL  1B2E
....................             break; 
1E76:  BRA    1EAE
....................  
....................       case USB_STANDARD_REQUEST_GET_DESCRIPTOR: //6 
....................             debug_usb(debug_putc,"GD"); 
....................             usb_Get_Descriptor(); 
1E78:  BRA    1BD2
....................             break; 
....................  
....................       case USB_STANDARD_REQUEST_GET_CONFIGURATION: //8 
....................             debug_usb(debug_putc,"GC"); 
....................             usb_ep0_tx_buffer[0]=USB_stack_status.curr_config; 
1E7A:  MOVFF  20,540
....................             usb_request_send_response(1); 
1E7E:  MOVLW  01
1E80:  MOVLB  2
1E82:  MOVWF  x9D
1E84:  MOVLB  0
1E86:  RCALL  1B2E
....................             break; 
1E88:  BRA    1EAE
....................  
....................       case USB_STANDARD_REQUEST_SET_CONFIGURATION: //9 
....................             if (usb_ep0_rx_buffer[2] <= USB_NUM_CONFIGURATIONS) { 
1E8A:  MOVLB  5
1E8C:  MOVF   x02,W
1E8E:  SUBLW  01
1E90:  BNC   1EA6
....................                debug_usb(debug_putc,"SC"); 
....................                USB_stack_status.curr_config=usb_ep0_rx_buffer[2]; 
1E92:  MOVFF  502,20
....................                usb_set_configured(usb_ep0_rx_buffer[2]); 
1E96:  MOVFF  502,29A
1E9A:  MOVLB  0
1E9C:  BRA    1C4C
....................                usb_put_0len_0(); 
1E9E:  MOVLB  2
1EA0:  CLRF   x9D
1EA2:  MOVLB  0
1EA4:  RCALL  1B2E
....................             } 
....................             break; 
1EA6:  MOVLB  0
1EA8:  BRA    1EAE
....................  
....................       default: 
....................             usb_request_stall(); 
1EAA:  RCALL  1B34
....................             break; 
1EAC:  BRA    1EAE
....................    } 
.................... } 
1EAE:  GOTO   21DE (RETURN)
....................  
.................... /************************************************************** 
.................... /* usb_isr_tkn_setup_StandardInterface() 
.................... /* 
.................... /* Input: usb_ep0_rx_buffer[1] == bRequest 
.................... /* 
.................... /* Summary: bmRequestType told us it was a Standard Interface request. 
.................... /*          bRequest says which request.  Only certain requests are valid, 
.................... /*          if a non-valid request was made then return with an Wrong-Statue (IDLE) 
.................... /* 
.................... /* Part of usb_isr_tok_setup_dne() 
.................... /***************************************************************/ 
.................... void usb_isr_tkn_setup_StandardInterface(void) { 
....................    int8 curr_config; 
....................  
....................    curr_config=USB_stack_status.curr_config; 
1EB2:  MOVFF  20,29A
....................  
....................    switch (usb_ep0_rx_buffer[1]) { 
1EB6:  MOVLB  5
1EB8:  MOVF   x01,W
1EBA:  MOVLB  0
1EBC:  BZ    1EC8
1EBE:  XORLW  0A
1EC0:  BZ    1EDA
1EC2:  XORLW  01
1EC4:  BZ    1F28
1EC6:  BRA    1F52
....................       case USB_STANDARD_REQUEST_GET_STATUS: 
....................             debug_usb(debug_putc,"GS"); 
....................             usb_ep0_tx_buffer[0]=0; 
1EC8:  MOVLB  5
1ECA:  CLRF   x40
....................             usb_ep0_tx_buffer[1]=0; 
1ECC:  CLRF   x41
....................             usb_request_send_response(2); 
1ECE:  MOVLW  02
1ED0:  MOVLB  2
1ED2:  MOVWF  x9D
1ED4:  MOVLB  0
1ED6:  RCALL  1B2E
....................             break; 
1ED8:  BRA    1F56
....................  
....................       case USB_STANDARD_REQUEST_GET_INTERFACE: 
....................             if ( curr_config && (usb_ep0_rx_buffer[4] < USB_NUM_INTERFACES[curr_config-1]) ) {   //book says only supports configed state 
1EDA:  MOVLB  2
1EDC:  MOVF   x9A,F
1EDE:  BZ    1F22
1EE0:  MOVLW  01
1EE2:  SUBWF  x9A,W
1EE4:  CLRF   03
1EE6:  MOVFF  FF2,29B
1EEA:  BCF    FF2.7
1EEC:  MOVLB  0
1EEE:  RCALL  19A4
1EF0:  MOVLB  2
1EF2:  BTFSC  x9B.7
1EF4:  BSF    FF2.7
1EF6:  MOVWF  01
1EF8:  MOVLB  5
1EFA:  SUBWF  x04,W
1EFC:  BTFSS  FD8.0
1EFE:  BRA    1F04
1F00:  MOVLB  2
1F02:  BRA    1F22
....................                debug_usb(debug_putc,"GI"); 
....................                usb_ep0_tx_buffer[0]=USB_Interface[usb_ep0_rx_buffer[4]];//our new outgoing byte 
1F04:  CLRF   03
1F06:  MOVF   x04,W
1F08:  ADDLW  2E
1F0A:  MOVWF  FE9
1F0C:  MOVLW  00
1F0E:  ADDWFC 03,W
1F10:  MOVWF  FEA
1F12:  MOVFF  FEF,540
....................                usb_request_send_response(1);; //send byte back 
1F16:  MOVLW  01
1F18:  MOVLB  2
1F1A:  MOVWF  x9D
1F1C:  MOVLB  0
1F1E:  RCALL  1B2E
....................             } 
....................             else 
1F20:  BRA    1F26
....................                usb_request_stall(); 
1F22:  MOVLB  0
1F24:  RCALL  1B34
....................             break; 
1F26:  BRA    1F56
....................  
....................       case USB_STANDARD_REQUEST_SET_INTERFACE: 
....................             if (curr_config) { //if configured state 
1F28:  MOVLB  2
1F2A:  MOVF   x9A,F
1F2C:  BZ    1F4C
....................                debug_usb(debug_putc,"SI"); 
....................                USB_Interface[usb_ep0_rx_buffer[4]]=usb_ep0_rx_buffer[2]; 
1F2E:  CLRF   03
1F30:  MOVLB  5
1F32:  MOVF   x04,W
1F34:  ADDLW  2E
1F36:  MOVWF  FE9
1F38:  MOVLW  00
1F3A:  ADDWFC 03,W
1F3C:  MOVWF  FEA
1F3E:  MOVFF  502,FEF
....................                usb_put_0len_0(); 
1F42:  MOVLB  2
1F44:  CLRF   x9D
1F46:  MOVLB  0
1F48:  RCALL  1B2E
....................             } 
....................             else 
1F4A:  BRA    1F50
....................                usb_request_stall(); 
1F4C:  MOVLB  0
1F4E:  RCALL  1B34
....................             break; 
1F50:  BRA    1F56
....................  
.................... #IF USB_HID_DEVICE 
....................       case USB_STANDARD_REQUEST_GET_DESCRIPTOR: 
....................             debug_usb(debug_putc,"GD"); 
....................             usb_Get_Descriptor(); 
....................             break; 
.................... #endif 
....................  
.................... //      case USB_STANDARD_REQUEST_CLEAR_FEATURE: 
.................... //      case USB_STANDARD_REQUEST_SET_FEATURE: 
.................... //                let default take care of these, goto wrongstate 
....................       default: 
....................             usb_request_stall(); 
1F52:  RCALL  1B34
....................             break; 
1F54:  BRA    1F56
....................    } 
.................... } 
1F56:  GOTO   21DE (RETURN)
....................  
.................... /************************************************************** 
.................... /* usb_isr_tkn_setup_StandardEndpoint() 
.................... /* 
.................... /* Input: usb_ep0_rx_buffer[1] == bRequest 
.................... /* 
.................... /* Summary: bmRequestType told us it was a Standard Endpoint request. 
.................... /*          bRequest says which request.  Only certain requests are valid, 
.................... /*          if a non-valid request was made then return with an Wrong-Statue (IDLE) 
.................... /* 
.................... /* Part of usb_isr_tok_setup_dne() 
.................... /***************************************************************/ 
.................... void usb_isr_tkn_setup_StandardEndpoint(void) { 
....................    if (usb_endpoint_is_valid(usb_ep0_rx_buffer[4])) { 
*
209A:  MOVFF  504,29A
209E:  BRA    1F5A
20A0:  MOVF   01,F
20A2:  BZ    2100
....................       switch(usb_ep0_rx_buffer[1]) { 
20A4:  MOVLB  5
20A6:  MOVF   x01,W
20A8:  XORLW  01
20AA:  MOVLB  0
20AC:  BZ    20B8
20AE:  XORLW  02
20B0:  BZ    20C8
20B2:  XORLW  03
20B4:  BZ    20D8
20B6:  BRA    20FC
....................  
....................          case USB_STANDARD_REQUEST_CLEAR_FEATURE: 
....................                debug_usb(debug_putc,"CF"); 
....................                usb_unstall_ep(usb_ep0_rx_buffer[4]); 
20B8:  MOVFF  504,29A
20BC:  BRA    1FB4
....................                usb_put_0len_0(); 
20BE:  MOVLB  2
20C0:  CLRF   x9D
20C2:  MOVLB  0
20C4:  RCALL  1B2E
....................                break; 
20C6:  BRA    2100
....................  
....................          case USB_STANDARD_REQUEST_SET_FEATURE: 
....................                      debug_usb(debug_putc,"SF"); 
....................                      usb_stall_ep(usb_ep0_rx_buffer[4]); 
20C8:  MOVFF  504,29A
20CC:  BRA    1FFA
....................                      usb_put_0len_0(); 
20CE:  MOVLB  2
20D0:  CLRF   x9D
20D2:  MOVLB  0
20D4:  RCALL  1B2E
....................                      break; 
20D6:  BRA    2100
....................  
....................          case USB_STANDARD_REQUEST_GET_STATUS: 
....................                debug_usb(debug_putc,"GS"); 
....................                usb_ep0_tx_buffer[0]=0; 
20D8:  MOVLB  5
20DA:  CLRF   x40
....................                usb_ep0_tx_buffer[1]=0; 
20DC:  CLRF   x41
....................                if (usb_endpoint_stalled(usb_ep0_rx_buffer[4])) { 
20DE:  MOVFF  504,29A
20E2:  MOVLB  0
20E4:  BRA    2042
20E6:  MOVF   01,F
20E8:  BZ    20F0
....................                   usb_ep0_tx_buffer[0]=1; 
20EA:  MOVLW  01
20EC:  MOVLB  5
20EE:  MOVWF  x40
....................                } 
....................                usb_request_send_response(2); 
20F0:  MOVLW  02
20F2:  MOVLB  2
20F4:  MOVWF  x9D
20F6:  MOVLB  0
20F8:  RCALL  1B2E
....................                break; 
20FA:  BRA    2100
....................  
....................          default: 
....................             usb_request_stall(); 
20FC:  RCALL  1B34
....................             break; 
20FE:  BRA    2100
....................       } 
....................    } 
.................... } 
2100:  GOTO   21DE (RETURN)
....................  
.................... /************************************************************** 
.................... /* usb_isr_tkn_setup_ClassInterface() 
.................... /* 
.................... /* Input: usb_ep0_rx_buffer[1] == bRequest 
.................... /* 
.................... /* Summary: bmRequestType told us it was a Class request.  The only Class this drivers supports is HID. 
.................... /*          bRequest says which request.  Only certain requests are valid, 
.................... /*          if a non-valid request was made then return with an Wrong-Statue (IDLE) 
.................... /* 
.................... /* Part of usb_isr_tok_setup_dne() 
.................... /* Only compiled if HID_DEVICE is TRUE 
.................... /***************************************************************/ 
.................... #IF USB_HID_DEVICE 
.................... void usb_isr_tkn_setup_ClassInterface(void) { 
....................    switch(usb_ep0_rx_buffer[1]) { 
....................  
....................     #IF USB_HID_BOOT_PROTOCOL 
....................       case USB_HID_REQUEST_GET_PROTOCOL:  //03 
....................             debug_usb(debug_putc,"GP"); 
....................             usb_ep0_tx_buffer[0]=hid_protocol[usb_ep0_rx_buffer[4]]; 
....................             usb_request_send_response(1); 
....................             break; 
....................     #ENDIF 
....................  
....................     #IF USB_HID_BOOT_PROTOCOL 
....................       case USB_HID_REQUEST_SET_PROTOCOL:  //0b 
....................             debug_usb(debug_putc,"SP"); 
....................             hid_protocol[usb_ep0_rx_buffer[4]]=usb_ep0_rx_buffer[2]; 
....................             usb_put_0len_0(); //send 0len packet69 
....................             break; 
....................     #ENDIF 
....................  
....................    #IF USB_HID_IDLE 
....................       case USB_HID_REQUEST_SET_IDLE:   //0a 
....................          #error TODO: if you want to support SET_IDLE, add code here 
....................    #ENDIF 
....................  
....................    #IF USB_HID_IDLE 
....................       case USB_HID_REQUEST_GET_IDLE:   //02 
....................          #error TODO: if you want to support GET_IDLE, add code here 
....................    #ENDIF 
....................  
....................       default: 
....................             usb_request_stall(); 
....................             break; 
....................    } 
.................... } 
.................... #ENDIF 
....................  
.................... /************************************************************** 
.................... /* usb_Get_Descriptor() 
.................... /* 
.................... /* Input: usb_ep0_rx_buffer[3] == wValue, which descriptor we want 
.................... /*        usb_ep0_rx_buffer[6,7] == Max length the host will accept 
.................... /* 
.................... /* Summary: Checks to see if we want a standard descriptor (Interface, Endpoint, Config, Device, String, etc.), 
.................... /*          or a class specific (HID) descriptor.  Since some pics (especially the PIC167x5) doesn't have 
.................... /*          pointers to constants we must simulate or own by setting up global registers that say 
.................... /*          which constant array to deal with, which position to start in this array, and the length. 
.................... /*          Once these globals are setup the first packet is sent.  If a descriptor takes more than one packet 
.................... /*          the PC will send an IN request to endpoint 0, and this will be handled by usb_isr_tok_in_dne() 
.................... /*          which will send the rest of the data. 
.................... /* 
.................... /* Part of usb_isr_tok_setup_dne() 
.................... /***************************************************************/ 
.................... void usb_Get_Descriptor() { 
....................    usb_getdesc_ptr=0; 
*
1BD2:  CLRF   2C
....................    USB_stack_status.getdesc_type=USB_GETDESC_CONFIG_TYPE; 
1BD4:  CLRF   22
....................  
....................    switch(usb_ep0_rx_buffer[3]) { 
1BD6:  MOVLB  5
1BD8:  MOVF   x03,W
1BDA:  XORLW  01
1BDC:  MOVLB  0
1BDE:  BZ    1BEA
1BE0:  XORLW  03
1BE2:  BZ    1BF4
1BE4:  XORLW  01
1BE6:  BZ    1BFA
1BE8:  BRA    1C2C
....................       case USB_DESC_DEVICE_TYPE:    //1 
....................             usb_getdesc_len=USB_DESC_DEVICE_LEN; 
1BEA:  MOVLW  12
1BEC:  MOVWF  2D
....................             USB_stack_status.getdesc_type=USB_GETDESC_DEVICE_TYPE; 
1BEE:  MOVLW  03
1BF0:  MOVWF  22
....................             break; 
1BF2:  BRA    1C30
....................  
....................       //windows hosts will send a FF max len and expect you to send all configs without asking for them individually. 
....................       case USB_DESC_CONFIG_TYPE:   //2 
....................             usb_getdesc_len=USB_TOTAL_CONFIG_LEN; 
1BF4:  MOVLW  43
1BF6:  MOVWF  2D
....................             break; 
1BF8:  BRA    1C30
....................  
....................       case USB_DESC_STRING_TYPE: //3 
....................             USB_stack_status.getdesc_type=USB_GETDESC_STRING_TYPE; 
1BFA:  MOVLW  02
1BFC:  MOVWF  22
....................             usb_getdesc_ptr=USB_STRING_DESC_OFFSET[usb_ep0_rx_buffer[2]]; 
1BFE:  CLRF   03
1C00:  MOVLB  5
1C02:  MOVF   x02,W
1C04:  ADDLW  28
1C06:  MOVWF  FE9
1C08:  MOVLW  00
1C0A:  ADDWFC 03,W
1C0C:  MOVWF  FEA
1C0E:  MOVFF  FEF,2C
....................             usb_getdesc_len=USB_STRING_DESC[usb_getdesc_ptr]; 
1C12:  CLRF   03
1C14:  MOVF   2C,W
1C16:  MOVFF  FF2,29A
1C1A:  BCF    FF2.7
1C1C:  MOVLB  0
1C1E:  RCALL  19D8
1C20:  MOVLB  2
1C22:  BTFSC  x9A.7
1C24:  BSF    FF2.7
1C26:  MOVWF  2D
....................             break; 
1C28:  MOVLB  0
1C2A:  BRA    1C30
....................  
.................... #IF USB_HID_DEVICE 
....................       case USB_DESC_CLASS_TYPE:  //0x21 
....................             usb_getdesc_ptr=USB_CLASS_DESCRIPTORS[0][0][0]; 
....................             if (usb_getdesc_ptr!=0xFF) { 
....................                usb_getdesc_len=USB_CONFIG_DESC[usb_getdesc_ptr]; 
....................                break; 
....................             } 
....................             else { 
....................                usb_request_stall(); 
....................                return; 
....................             } 
....................  
....................  
....................       case USB_DESC_HIDREPORT_TYPE: //0x22 
....................             usb_getdesc_ptr=USB_CLASS_SPECIFIC_DESC_LOOKUP[0][usb_ep0_rx_buffer[4]]; 
....................             if (usb_getdesc_ptr !=0xFF) { 
....................                USB_stack_status.getdesc_type=USB_GETDESC_HIDREPORT_TYPE; 
....................                usb_getdesc_len=USB_CLASS_SPECIFIC_DESC_LOOKUP_SIZE[0][usb_ep0_rx_buffer[4]]; 
....................                break; 
....................             } 
....................             else { 
....................                usb_request_stall(); 
....................                return; 
....................             } 
.................... #endif 
....................  
....................       default: 
....................             usb_request_stall(); 
1C2C:  RCALL  1B34
....................             return; 
1C2E:  BRA    1C48
....................    } 
....................    if (usb_ep0_rx_buffer[7]==0) { 
1C30:  MOVLB  5
1C32:  MOVF   x07,F
1C34:  BNZ   1C40
....................       if (usb_getdesc_len > usb_ep0_rx_buffer[6]) 
1C36:  MOVF   2D,W
1C38:  SUBWF  x06,W
1C3A:  BC    1C40
....................          usb_getdesc_len = usb_ep0_rx_buffer[6]; 
1C3C:  MOVFF  506,2D
....................    } 
....................    USB_stack_status.dev_req=GET_DESCRIPTOR; 
1C40:  MOVLW  01
1C42:  MOVWF  1F
....................    usb_copy_desc_seg_to_ep(); 
1C44:  MOVLB  0
1C46:  RCALL  1B3A
.................... } 
1C48:  GOTO   1EAE (RETURN)
....................  
.................... /************************************************************** 
.................... /* usb_finish_set_address() 
.................... /* 
.................... /* Input: USB_address_pending holds the address we were asked to set to. 
.................... /* 
.................... /* Summary: Sets the address. 
.................... /* 
.................... /* This code should only be run on the PIC USB peripheral, and not the 
.................... /* National peripheral. 
.................... /* 
.................... /* Part of usb_isr_tok_setup_dne() 
.................... /***************************************************************/ 
....................  void usb_finish_set_address() { 
....................    debug_usb(debug_putc," FSA "); 
.................... 	USB_stack_status.curr_config=0;	// make sure current configuration is 0 
*
24B0:  CLRF   20
....................  
....................    #ifdef __PIC__ 
.................... 	USB_stack_status.dev_req=NONE;  // no request pending 
24B2:  CLRF   1F
....................    usb_set_address(USB_address_pending); 
24B4:  MOVFF  2B,29B
24B8:  BRA    2496
....................    #endif 
.................... } 
24BA:  GOTO   25BC (RETURN)
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... /// 
.................... /// The following function retrieve data from constant arrays.  This may 
.................... /// look un-optimized, but remember that you can't create a pointer to 
.................... /// a constant array. 
.................... /// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... void usb_copy_desc_seg_to_ep(void) { 
....................    int i=0; 
*
1B3A:  MOVLB  2
1B3C:  CLRF   x9B
....................    char c; 
....................  
....................    while ((usb_getdesc_len)&&(i<USB_MAX_EP0_PACKET_LENGTH)) 
....................    { 
1B3E:  MOVF   2D,F
1B40:  BZ    1BBC
1B42:  MOVF   x9B,W
1B44:  SUBLW  3F
1B46:  BNC   1BBC
....................       switch(USB_stack_status.getdesc_type) { 
1B48:  MOVF   22,W
1B4A:  MOVLB  0
1B4C:  BZ    1B58
1B4E:  XORLW  02
1B50:  BZ    1B70
1B52:  XORLW  01
1B54:  BZ    1B88
1B56:  BRA    1BA0
....................          case USB_GETDESC_CONFIG_TYPE: 
....................             c=USB_CONFIG_DESC[usb_getdesc_ptr]; 
1B58:  CLRF   03
1B5A:  MOVF   2C,W
1B5C:  MOVFF  FF2,29D
1B60:  BCF    FF2.7
1B62:  RCALL  1950
1B64:  MOVLB  2
1B66:  BTFSC  x9D.7
1B68:  BSF    FF2.7
1B6A:  MOVWF  x9C
....................             break; 
1B6C:  MOVLB  0
1B6E:  BRA    1BA0
....................  
....................         #IF USB_HID_DEVICE 
....................          case USB_GETDESC_HIDREPORT_TYPE: 
....................             c=USB_CLASS_SPECIFIC_DESC[usb_getdesc_ptr]; 
....................             break; 
....................         #endif 
....................  
....................          case USB_GETDESC_STRING_TYPE: 
....................             c=USB_STRING_DESC[usb_getdesc_ptr]; 
1B70:  CLRF   03
1B72:  MOVF   2C,W
1B74:  MOVFF  FF2,29D
1B78:  BCF    FF2.7
1B7A:  RCALL  19D8
1B7C:  MOVLB  2
1B7E:  BTFSC  x9D.7
1B80:  BSF    FF2.7
1B82:  MOVWF  x9C
....................             break; 
1B84:  MOVLB  0
1B86:  BRA    1BA0
....................  
....................          case USB_GETDESC_DEVICE_TYPE: 
....................             c=USB_DEVICE_DESC[usb_getdesc_ptr]; 
1B88:  CLRF   03
1B8A:  MOVF   2C,W
1B8C:  MOVFF  FF2,29D
1B90:  BCF    FF2.7
1B92:  RCALL  19B6
1B94:  MOVLB  2
1B96:  BTFSC  x9D.7
1B98:  BSF    FF2.7
1B9A:  MOVWF  x9C
....................             break; 
1B9C:  MOVLB  0
1B9E:  BRA    1BA0
....................       } 
....................       usb_getdesc_ptr++; 
1BA0:  INCF   2C,F
....................       usb_getdesc_len--; 
1BA2:  DECF   2D,F
....................       usb_ep0_tx_buffer[i++]=c; 
1BA4:  MOVLB  2
1BA6:  MOVF   x9B,W
1BA8:  INCF   x9B,F
1BAA:  CLRF   03
1BAC:  ADDLW  40
1BAE:  MOVWF  FE9
1BB0:  MOVLW  05
1BB2:  ADDWFC 03,W
1BB4:  MOVWF  FEA
1BB6:  MOVFF  29C,FEF
....................    } 
1BBA:  BRA    1B3E
....................  
....................    if ((!usb_getdesc_len)&&(i!=USB_MAX_EP0_PACKET_LENGTH)) { 
1BBC:  MOVF   2D,F
1BBE:  BNZ   1BC8
1BC0:  MOVF   x9B,W
1BC2:  SUBLW  40
1BC4:  BZ    1BC8
....................          USB_stack_status.dev_req = NONE; 
1BC6:  CLRF   1F
....................    } 
....................  
....................    usb_request_send_response(i); 
1BC8:  MOVFF  29B,29D
1BCC:  MOVLB  0
1BCE:  RCALL  1B2E
.................... } 
1BD0:  RETLW  00
....................  
.................... #ENDIF 
....................  
....................  
.................... struct { 
....................         int32   dwDTERrate;   //data terminal rate, in bits per second 
....................         int8    bCharFormat;  //num of stop bits (0=1, 1=1.5, 2=2) 
....................         int8    bParityType;  //parity (0=none, 1=odd, 2=even, 3=mark, 4=space) 
....................         int8    bDataBits;    //data bits (5,6,7,8 or 16) 
.................... } usb_cdc_line_coding; 
....................  
.................... //length of time, in ms, of break signal as we received in a SendBreak message. 
.................... //if ==0xFFFF, send break signal until we receive a 0x0000. 
.................... int16 usb_cdc_break; 
....................  
.................... int8 usb_cdc_encapsulated_cmd[8]; 
....................  
.................... int8 usb_cdc_put_buffer[USB_CDC_DATA_IN_SIZE]; 
.................... int1 usb_cdc_put_buffer_free; 
.................... #if USB_CDC_DATA_IN_SIZE>=0x100 
....................  int16 usb_cdc_put_buffer_nextin=0; 
.................... // int16 usb_cdc_last_data_packet_size; 
.................... #else 
....................  int8 usb_cdc_put_buffer_nextin=0; 
.................... // int8 usb_cdc_last_data_packet_size; 
.................... #endif 
....................  
.................... struct { 
....................    int1 got; 
....................   #if USB_CDC_DATA_OUT_SIZE>=0x100 
....................    int16 len; 
....................    int16 index; 
....................   #else 
....................    int8 len; 
....................    int8 index; 
....................   #endif 
.................... } usb_cdc_get_buffer_status; 
....................  
.................... int8 usb_cdc_get_buffer_status_buffer[USB_CDC_DATA_OUT_SIZE]; 
.................... #if (defined(__PIC__)) 
....................  #if __PIC__ 
....................   //#locate usb_cdc_get_buffer_status_buffer=0x500+(2*USB_MAX_EP0_PACKET_LENGTH)+USB_CDC_COMM_IN_SIZE 
....................   #if USB_MAX_EP0_PACKET_LENGTH==8 
....................      #locate usb_cdc_get_buffer_status_buffer=0x500+24 
....................   #elif USB_MAX_EP0_PACKET_LENGTH==64 
....................      #locate usb_cdc_get_buffer_status_buffer=0x500+136 
....................   #else 
....................    #error CCS BUG WONT LET ME USE MATH IN LOCATE 
....................   #endif 
....................  #endif 
.................... #endif 
....................  
.................... int1 usb_cdc_got_set_line_coding; 
....................  
.................... struct  { 
....................    int1 dte_present; //1=DTE present, 0=DTE not present 
....................    int1 active;      //1=activate carrier, 0=deactivate carrier 
....................    int reserved:6; 
.................... } usb_cdc_carrier; 
....................  
.................... enum {USB_CDC_OUT_NOTHING=0, USB_CDC_OUT_COMMAND=1, USB_CDC_OUT_LINECODING=2, USB_CDC_WAIT_0LEN=3} __usb_cdc_state=0; 
....................  
.................... #byte INTCON=0xFF2 
.................... #bit INT_GIE=INTCON.7 
....................  
.................... //handle OUT token done interrupt on endpoint 0 [read encapsulated cmd and line coding data] 
.................... void usb_isr_tok_out_cdc_control_dne(void) { 
....................    debug_usb(debug_putc,"CDC %X ",__usb_cdc_state); 
....................  
....................    switch (__usb_cdc_state) { 
*
23B2:  MOVF   x87,W
23B4:  XORLW  01
23B6:  BZ    23BE
23B8:  XORLW  03
23BA:  BZ    23E4
23BC:  BRA    240A
....................       //printf(putc_tbe,"@%X@\r\n", __usb_cdc_state); 
....................       case USB_CDC_OUT_COMMAND: 
....................          //usb_get_packet(0, usb_cdc_encapsulated_cmd, 8); 
....................          memcpy(usb_cdc_encapsulated_cmd, usb_ep0_rx_buffer,8); 
23BE:  CLRF   FEA
23C0:  MOVLW  39
23C2:  MOVWF  FE9
23C4:  MOVLW  05
23C6:  MOVWF  FE2
23C8:  CLRF   FE1
23CA:  MOVLW  08
23CC:  MOVWF  01
23CE:  MOVFF  FE6,FEE
23D2:  DECFSZ 01,F
23D4:  BRA    23CE
....................         #if USB_MAX_EP0_PACKET_LENGTH==8 
....................          __usb_cdc_state=USB_CDC_WAIT_0LEN; 
....................          usb_request_get_data(); 
....................         #else 
....................          usb_put_0len_0(); 
23D6:  MOVLB  2
23D8:  CLRF   x9D
23DA:  MOVLB  0
23DC:  CALL   1B2E
....................          __usb_cdc_state=0; 
23E0:  CLRF   x87
....................         #endif 
....................          break; 
23E2:  BRA    2412
....................  
....................     #if USB_MAX_EP0_PACKET_LENGTH==8 
....................       case USB_CDC_WAIT_0LEN: 
....................          usb_put_0len_0(); 
....................          __usb_cdc_state=0; 
....................          break; 
....................     #endif 
....................  
....................       case USB_CDC_OUT_LINECODING: 
....................          //usb_get_packet(0, &usb_cdc_line_coding, 7); 
....................          //printf(putc_tbe,"\r\n!GSLC FIN!\r\n"); 
....................          memcpy(&usb_cdc_line_coding, usb_ep0_rx_buffer,7); 
23E4:  CLRF   FEA
23E6:  MOVLW  30
23E8:  MOVWF  FE9
23EA:  MOVLW  05
23EC:  MOVWF  FE2
23EE:  CLRF   FE1
23F0:  MOVLW  07
23F2:  MOVWF  01
23F4:  MOVFF  FE6,FEE
23F8:  DECFSZ 01,F
23FA:  BRA    23F4
....................          __usb_cdc_state=0; 
23FC:  CLRF   x87
....................          usb_put_0len_0(); 
23FE:  MOVLB  2
2400:  CLRF   x9D
2402:  MOVLB  0
2404:  CALL   1B2E
....................          break; 
2408:  BRA    2412
....................  
....................       default: 
....................          __usb_cdc_state=0; 
240A:  CLRF   x87
....................          usb_init_ep0_setup(); 
240C:  CALL   1AC8
....................          break; 
2410:  BRA    2412
....................    } 
.................... } 
2412:  GOTO   2462 (RETURN)
....................  
.................... //handle IN token on 0 (setup packet) 
.................... void usb_isr_tkn_cdc(void) { 
....................    //make sure the request goes to a CDC interface 
....................    if ((usb_ep0_rx_buffer[4] == 1) || (usb_ep0_rx_buffer[4] == 0)) { 
*
210A:  MOVLB  5
210C:  DECFSZ x04,W
210E:  BRA    2112
2110:  BRA    2116
2112:  MOVF   x04,F
2114:  BNZ   21B2
....................       //printf(putc_tbe,"!%X!\r\n", usb_ep0_rx_buffer[1]); 
....................       switch(usb_ep0_rx_buffer[1]) { 
2116:  MOVF   x01,W
2118:  MOVLB  0
211A:  BZ    2132
211C:  XORLW  01
211E:  BZ    213A
2120:  XORLW  21
2122:  BZ    215C
2124:  XORLW  01
2126:  BZ    2166
2128:  XORLW  03
212A:  BZ    218C
212C:  XORLW  01
212E:  BZ    219A
2130:  BRA    21AC
....................          case 0x00:  //send_encapsulated_command 
....................             __usb_cdc_state=USB_CDC_OUT_COMMAND; 
2132:  MOVLW  01
2134:  MOVWF  x87
....................             usb_request_get_data(); 
2136:  RCALL  2104
....................             break; 
2138:  BRA    21B0
....................  
....................          case 0x01:  //get_encapsulated_command 
....................             memcpy(usb_ep0_tx_buffer, usb_cdc_encapsulated_cmd, 8); 
213A:  MOVLW  05
213C:  MOVWF  FEA
213E:  MOVLW  40
2140:  MOVWF  FE9
2142:  CLRF   FE2
2144:  MOVLW  39
2146:  MOVWF  FE1
2148:  MOVLW  08
214A:  MOVWF  01
214C:  MOVFF  FE6,FEE
2150:  DECFSZ 01,F
2152:  BRA    214C
....................             usb_request_send_response(usb_ep0_rx_buffer[6]);  //send wLength bytes 
2154:  MOVFF  506,29D
2158:  RCALL  1B2E
....................             break; 
215A:  BRA    21B0
....................  
....................          case 0x20:  //set_line_coding 
....................             debug_usb(debug_putc,"!GSLC!"); 
....................             __usb_cdc_state=USB_CDC_OUT_LINECODING; 
215C:  MOVLW  02
215E:  MOVWF  x87
....................             usb_cdc_got_set_line_coding=TRUE; 
2160:  BSF    x81.1
....................             usb_request_get_data(); 
2162:  RCALL  2104
....................             break; 
2164:  BRA    21B0
....................  
....................          case 0x21:  //get_line_coding 
....................             memcpy(usb_ep0_tx_buffer, &usb_cdc_line_coding, sizeof(usb_cdc_line_coding)); 
2166:  MOVLW  05
2168:  MOVWF  FEA
216A:  MOVLW  40
216C:  MOVWF  FE9
216E:  CLRF   FE2
2170:  MOVLW  30
2172:  MOVWF  FE1
2174:  MOVLW  07
2176:  MOVWF  01
2178:  MOVFF  FE6,FEE
217C:  DECFSZ 01,F
217E:  BRA    2178
....................             usb_request_send_response(sizeof(usb_cdc_line_coding)); //send wLength bytes 
2180:  MOVLW  07
2182:  MOVLB  2
2184:  MOVWF  x9D
2186:  MOVLB  0
2188:  RCALL  1B2E
....................             break; 
218A:  BRA    21B0
....................  
....................          case 0x22:  //set_control_line_state 
....................             usb_cdc_carrier=usb_ep0_rx_buffer[2]; 
218C:  MOVFF  502,86
....................             usb_put_0len_0(); 
2190:  MOVLB  2
2192:  CLRF   x9D
2194:  MOVLB  0
2196:  RCALL  1B2E
....................             break; 
2198:  BRA    21B0
....................  
....................          case 0x23:  //send_break 
....................             usb_cdc_break=make16(usb_ep0_rx_buffer[2],usb_ep0_rx_buffer[3]); 
219A:  MOVFF  502,38
219E:  MOVFF  503,37
....................             usb_put_0len_0(); 
21A2:  MOVLB  2
21A4:  CLRF   x9D
21A6:  MOVLB  0
21A8:  RCALL  1B2E
....................             break; 
21AA:  BRA    21B0
....................  
....................          default: 
....................             usb_request_stall(); 
21AC:  RCALL  1B34
....................             break; 
21AE:  BRA    21B0
21B0:  MOVLB  5
....................       } 
....................    } 
.................... } 
21B2:  MOVLB  0
21B4:  GOTO   21DE (RETURN)
....................  
.................... //handle OUT token done interrupt on endpoint 3 [buffer incoming received chars] 
.................... void usb_isr_tok_out_cdc_data_dne(void) { 
....................    usb_cdc_get_buffer_status.got=TRUE; 
*
2442:  BSF    x83.0
....................    usb_cdc_get_buffer_status.index=0; 
2444:  CLRF   x85
.................... #if (defined(__PIC__)) 
....................    #if __PIC__ 
....................     usb_cdc_get_buffer_status.len=usb_rx_packet_size(USB_CDC_DATA_OUT_ENDPOINT); 
2446:  MOVLW  02
2448:  MOVLB  2
244A:  MOVWF  x9B
244C:  MOVLB  0
244E:  BRA    2416
2450:  MOVFF  01,84
....................    #else 
....................     usb_cdc_get_buffer_status.len=usb_get_packet_buffer( 
....................        USB_CDC_DATA_OUT_ENDPOINT,&usb_cdc_get_buffer_status_buffer[0],USB_CDC_DATA_OUT_SIZE); 
....................    #endif 
.................... #else 
....................    usb_cdc_get_buffer_status.len=usb_get_packet_buffer( 
....................       USB_CDC_DATA_OUT_ENDPOINT,&usb_cdc_get_buffer_status_buffer[0],USB_CDC_DATA_OUT_SIZE); 
.................... #endif 
.................... } 
2454:  GOTO   2470 (RETURN)
....................  
.................... //handle IN token done interrupt on endpoint 2 [transmit buffered characters] 
.................... void usb_isr_tok_in_cdc_data_dne(void) { 
....................    if (usb_cdc_put_buffer_nextin) { 
*
2590:  MOVF   x82,F
2592:  BZ    2598
....................       usb_cdc_flush_out_buffer(); 
2594:  RCALL  256C
....................    } 
....................    //send a 0len packet if needed 
.................... //   else if (usb_cdc_last_data_packet_size==USB_CDC_DATA_IN_SIZE) { 
.................... //      usb_cdc_last_data_packet_size=0; 
.................... //      printf(putc_tbe, "FL 0\r\n"); 
.................... //      usb_put_packet(USB_CDC_DATA_IN_ENDPOINT,0,0,USB_DTS_TOGGLE); 
.................... //   } 
....................    else { 
2596:  BRA    259A
....................       usb_cdc_put_buffer_free=TRUE; 
2598:  BSF    x81.0
....................       //printf(putc_tbe, "FL DONE\r\n"); 
....................    } 
.................... } 
259A:  GOTO   25CA (RETURN)
....................  
.................... void usb_cdc_flush_out_buffer(void) { 
....................    if (usb_cdc_put_buffer_nextin) { 
*
256C:  MOVF   x82,F
256E:  BZ    258E
....................       usb_cdc_put_buffer_free=FALSE; 
2570:  BCF    x81.0
....................       //usb_cdc_last_data_packet_size=usb_cdc_put_buffer_nextin; 
....................       //printf(putc_tbe, "FL %U\r\n", usb_cdc_put_buffer_nextin); 
....................       usb_put_packet(USB_CDC_DATA_IN_ENDPOINT,usb_cdc_put_buffer,usb_cdc_put_buffer_nextin,USB_DTS_TOGGLE); 
2572:  MOVLW  02
2574:  MOVLB  2
2576:  MOVWF  x9B
2578:  CLRF   x9D
257A:  MOVLW  41
257C:  MOVWF  x9C
257E:  CLRF   x9F
2580:  MOVFF  82,29E
2584:  MOVLW  02
2586:  MOVWF  xA0
2588:  MOVLB  0
258A:  RCALL  24BE
....................       usb_cdc_put_buffer_nextin=0; 
258C:  CLRF   x82
....................    } 
.................... } 
258E:  RETLW  00
....................  
.................... void usb_cdc_init(void) { 
....................    usb_cdc_line_coding.dwDTERrate=9600; 
*
1A48:  CLRF   33
1A4A:  CLRF   32
1A4C:  MOVLW  25
1A4E:  MOVWF  31
1A50:  MOVLW  80
1A52:  MOVWF  30
....................    usb_cdc_line_coding.bCharFormat=0; 
1A54:  CLRF   34
....................    usb_cdc_line_coding.bParityType=0; 
1A56:  CLRF   35
....................    usb_cdc_line_coding.bDataBits=8; 
1A58:  MOVLW  08
1A5A:  MOVWF  36
....................    (int8)usb_cdc_carrier=0; 
1A5C:  CLRF   x86
....................    usb_cdc_got_set_line_coding=FALSE; 
1A5E:  BCF    x81.1
....................    usb_cdc_break=0; 
1A60:  CLRF   38
1A62:  CLRF   37
....................    usb_cdc_put_buffer_nextin=0; 
1A64:  CLRF   x82
....................    usb_cdc_get_buffer_status.got=0; 
1A66:  BCF    x83.0
....................    usb_cdc_put_buffer_free=TRUE; 
1A68:  BSF    x81.0
.................... } 
1A6A:  RETLW  00
....................  
.................... ////////////////// END USB CONTROL HANDLING ////////////////////////////////// 
....................  
.................... ////////////////// BEGIN USB<->RS232 CDC LIBRARY ///////////////////////////// 
....................  
.................... char usb_cdc_getc(void) { 
....................    char c; 
....................  
....................    while (!usb_cdc_kbhit()) {} 
*
2BDE:  BTFSC  x83.0
2BE0:  BRA    2BE4
2BE2:  BRA    2BDE
....................  
....................    c=usb_cdc_get_buffer_status_buffer[usb_cdc_get_buffer_status.index++]; 
2BE4:  MOVF   x85,W
2BE6:  INCF   x85,F
2BE8:  CLRF   03
2BEA:  ADDLW  88
2BEC:  MOVWF  FE9
2BEE:  MOVLW  05
2BF0:  ADDWFC 03,W
2BF2:  MOVWF  FEA
2BF4:  MOVFF  FEF,289
2BF8:  MOVLB  2
....................    if (usb_cdc_get_buffer_status.index >= usb_cdc_get_buffer_status.len) { 
2BFA:  MOVLB  0
2BFC:  MOVF   x84,W
2BFE:  SUBWF  x85,W
2C00:  BNC   2C1E
....................       usb_cdc_get_buffer_status.got=FALSE; 
2C02:  BCF    x83.0
2C04:  CLRF   18
2C06:  BTFSC  FF2.7
2C08:  BSF    18.7
2C0A:  BCF    FF2.7
....................       usb_flush_out(USB_CDC_DATA_OUT_ENDPOINT, USB_DTS_TOGGLE); 
2C0C:  MOVLW  02
2C0E:  MOVLB  2
2C10:  MOVWF  x9A
2C12:  MOVWF  x9B
2C14:  MOVLB  0
2C16:  CALL   21E2
2C1A:  BTFSC  18.7
2C1C:  BSF    FF2.7
....................    } 
....................  
....................    return(c); 
2C1E:  MOVLB  2
2C20:  MOVFF  289,01
.................... } 
2C24:  MOVLB  0
2C26:  GOTO   2C34 (RETURN)
....................  
.................... void usb_cdc_putc_fast(char c) { 
....................    int1 old_gie; 
....................  
....................    //disable global interrupts 
....................    old_gie=INT_GIE; 
*
32F0:  MOVLB  2
32F2:  BCF    x86.0
32F4:  BTFSC  FF2.7
32F6:  BSF    x86.0
....................    INT_GIE=0; 
32F8:  BCF    FF2.7
....................  
....................    if (usb_cdc_put_buffer_nextin >= USB_CDC_DATA_IN_SIZE) { 
32FA:  MOVLB  0
32FC:  MOVF   x82,W
32FE:  SUBLW  3F
3300:  BC    3306
....................       usb_cdc_put_buffer_nextin=USB_CDC_DATA_IN_SIZE-1;  //we just overflowed the buffer! 
3302:  MOVLW  3F
3304:  MOVWF  x82
....................    } 
....................    usb_cdc_put_buffer[usb_cdc_put_buffer_nextin++]=c; 
3306:  MOVF   x82,W
3308:  INCF   x82,F
330A:  CLRF   03
330C:  ADDLW  41
330E:  MOVWF  FE9
3310:  MOVLW  00
3312:  ADDWFC 03,W
3314:  MOVWF  FEA
3316:  MOVFF  285,FEF
....................  
....................    //renable global interrupts 
....................    INT_GIE=old_gie; 
331A:  BCF    FF2.7
331C:  MOVLB  2
331E:  BTFSC  x86.0
3320:  BSF    FF2.7
....................  
....................    /* 
....................    if (usb_tbe(USB_CDC_DATA_IN_ENDPOINT)) { 
....................       if (usb_cdc_put_buffer_nextin) 
....................          usb_cdc_flush_out_buffer(); 
....................    } 
....................    */ 
....................    if (usb_cdc_put_buffer_free) { 
3322:  MOVLB  0
3324:  BTFSS  x81.0
3326:  BRA    3338
3328:  CLRF   18
332A:  BTFSC  FF2.7
332C:  BSF    18.7
332E:  BCF    FF2.7
....................       usb_cdc_flush_out_buffer(); 
3330:  CALL   256C
3334:  BTFSC  18.7
3336:  BSF    FF2.7
....................    } 
.................... } 
3338:  GOTO   335E (RETURN)
....................  
.................... void usb_cdc_putc(char c) { 
....................    while (!usb_cdc_putready()) { 
333C:  MOVF   x82,W
333E:  SUBLW  3F
3340:  BC    3358
....................       if (usb_cdc_put_buffer_free) { 
3342:  BTFSS  x81.0
3344:  BRA    3356
3346:  CLRF   18
3348:  BTFSC  FF2.7
334A:  BSF    18.7
334C:  BCF    FF2.7
....................          usb_cdc_flush_out_buffer(); 
334E:  CALL   256C
3352:  BTFSC  18.7
3354:  BSF    FF2.7
....................       } 
....................       //delay_ms(500); 
....................       //printf(putc_tbe,"TBE=%U CNT=%U LST=%U\r\n",usb_tbe(USB_CDC_DATA_IN_ENDPOINT), usb_cdc_put_buffer_nextin, usb_cdc_last_data_packet_size); 
....................    } 
3356:  BRA    333C
....................    usb_cdc_putc_fast(c); 
3358:  MOVFF  284,285
335C:  BRA    32F0
.................... } 
335E:  RETLW  00
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
.................... BYTE gethex1_usb() { 
....................    char digit; 
....................  
....................    digit = usb_cdc_getc(); 
....................  
....................    usb_cdc_putc(digit); 
....................  
....................    if(digit<='9') 
....................      return(digit-'0'); 
....................    else 
....................      return((toupper(digit)-'A')+10); 
.................... } 
....................  
.................... BYTE gethex_usb() { 
....................    int lo,hi; 
....................  
....................    hi = gethex1_usb(); 
....................    lo = gethex1_usb(); 
....................    if(lo==0xdd) 
....................      return(hi); 
....................    else 
....................      return( hi*16+lo ); 
.................... } 
....................  
.................... void get_string_usb(char* s, int max) { 
....................    int len; 
....................    char c; 
....................  
....................    --max; 
....................    len=0; 
....................    do { 
....................      c=usb_cdc_getc(); 
....................      if(c==8) {  // Backspace 
....................         if(len>0) { 
....................           len--; 
....................         } 
....................      } else if ((c>=' ')&&(c<='~')) 
....................        if(len<max) { 
....................          s[len++]=c; 
....................        } 
....................    } while(c!=13); 
....................    s[len]=0; 
.................... } 
....................  
....................  
.................... // stdlib.h is required for the ato_ conversions 
.................... // in the following functions 
.................... #ifdef _STDLIB 
....................  
.................... signed int get_int_usb() { 
....................   char s[5]; 
....................   signed int i; 
....................  
....................   get_string_usb(s, 5); 
....................  
....................   i=atoi(s); 
....................   return(i); 
.................... } 
....................  
.................... signed long get_long_usb() { 
....................   char s[7]; 
....................   signed long l; 
....................  
....................   get_string_usb(s, 7); 
....................   l=atol(s); 
....................   return(l); 
.................... } 
....................  
.................... float get_float_usb() { 
....................   char s[20]; 
....................   float f; 
....................  
....................   get_string_usb(s, 20); 
....................   f = atof(s); 
....................   return(f); 
.................... } 
....................  
.................... #endif 
....................  
....................  
.................... //TC74HC164 Setting 
.................... #define SR_CLK PIN_B6 
.................... #define SR_A   PIN_B7 
....................  
.................... //TC74HC165 Setting 
.................... #define SR_SL   PIN_C1 
.................... #define SR_CLK2 PIN_C0 
.................... #define SR_QH   PIN_C6 
....................  
.................... //MAX7219CNG Setting 
.................... #if 1//sy 
.................... #define LDD_LOAD PIN_B5 
.................... #else//sy 
.................... #define LDD_LOAD PIN_C2 
.................... #endif//sy 
....................  
.................... void initLedDriver(void); 
.................... #ifndef ONE_TWENTY_EIGHT//for sixty four 
.................... void sendSpiLED(int msb, int lsb); 
.................... #else//for one twenty eight 
.................... //sy void sendSpiLED(int id, int msb, int lsb); 
.................... void sendSpiLED2(int msb0, int lsb0, int msb1, int lsb1); 
.................... #endif//sy 
....................  
.................... //sy int i, j, k; 
.................... int i, j; 
.................... char *ch; 
.................... short flag; 
.................... int x, y, state; 
.................... #ifdef ONE_TWENTY_EIGHT//for sixty four 
.................... int x1, y1; 
.................... int lsb0, lsb1; 
.................... #endif 
....................  
.................... //OSC Messages Receive Setting 
.................... #ifndef ONE_TWENTY_EIGHT//for sixty four 
.................... int led_data[8]; 
.................... #else//for one twenty eight 
.................... long led_data[8]; 
.................... #endif//sy 
.................... int firstRun = TRUE; 
....................  
.................... char string[15]; 
.................... char space[] = " "; 
....................  
.................... void receiveOscMsgs(void); 
....................  
.................... //Button Settings 
.................... int start_row = 0; 
.................... #ifndef ONE_TWENTY_EIGHT//for sixty four 
.................... int btnCurrent[8], btnLast[8], btnState[8], btnDebounceCount[8][8]; 
.................... #else//for one twenty eight 
.................... long btnCurrent[8], btnLast[8], btnState[8], btnDebounceCount[8][16]; 
.................... #endif//sy 
....................  
.................... void buttonInit(void); 
.................... short buttonCheck(int row, int index); 
.................... void sendOscMsgPress(void); 
....................  
....................  
.................... //A/D Conversion Settings 
.................... #define kAdcFilterNumAdcs 7 
.................... const int adc_id[] = {0, 1, 2, 3, 4, 8, 9}; 
....................  
.................... int gAdcEnableState = 0; 
.................... short enableAdcFlag = FALSE; 
.................... int countAdc = 0, loopAdc = 0, enableAdcNum = 0; 
.................... int countAve[7]; 
.................... long lvalue = 0; 
.................... long adc_total[7]; 
.................... long adc_value[7][8]; 
....................  
.................... void enableAdc(int port); 
.................... void disableAdc(int port); 
.................... void sendOscMsgAdc(void); 
....................  
.................... //Digital Input Settings 
.................... int inCurrent, inLast, inState, inDebounceCount[2]; 
....................  
.................... void inputInit(void); 
.................... short inputCheck(int index); 
.................... void sendOscMsgInput(void); 
....................  
.................... //EEPROM 
.................... struct{ 
....................   int intensity; 
.................... }para; 
....................  
.................... void initAndSaveParaToEeprom(void); 
.................... void getParaFromEeprom(int *ptr, int num, int addr); 
.................... void putParaToEeprom(int *ptr, int num, int addr); 
....................  
.................... int my_atoi(char s); 
.................... void my_get_string_usb(char* s, int max); 
....................  
....................  
.................... void main() 
.................... { 
*
42EC:  CLRF   FF8
42EE:  BCF    FD0.7
42F0:  BSF    08.7
42F2:  CLRF   FEA
42F4:  CLRF   FE9
42F6:  MOVF   FC1,W
42F8:  ANDLW  C0
42FA:  IORLW  0F
42FC:  MOVWF  FC1
42FE:  MOVLW  07
4300:  MOVWF  FB4
4302:  CLRF   19
4304:  CLRF   1A
4306:  CLRF   26
4308:  CLRF   28
430A:  MOVLW  04
430C:  MOVWF  29
430E:  MOVLW  16
4310:  MOVWF  2A
4312:  CLRF   2D
4314:  CLRF   x82
4316:  CLRF   x87
4318:  MOVLW  01
431A:  MOVWF  xA3
431C:  MOVLW  20
431E:  MOVWF  xB3
4320:  CLRF   xB4
4322:  CLRF   xB5
4324:  MOVLB  1
4326:  CLRF   xE6
4328:  MOVLB  0
432A:  BCF    x81.3
432C:  MOVLB  1
432E:  CLRF   xE7
4330:  CLRF   xE8
4332:  CLRF   xE9
4334:  CLRF   xF1
4336:  CLRF   xF2
....................   setup_adc_ports(AN0_TO_AN9 || VSS_VDD); 
4338:  MOVF   FC1,W
433A:  ANDLW  C0
433C:  IORLW  05
433E:  MOVWF  FC1
....................   setup_adc(ADC_CLOCK_DIV_64); 
4340:  BCF    FC0.0
4342:  BSF    FC0.1
4344:  BSF    FC0.2
4346:  BSF    FC0.7
4348:  BSF    FC2.0
....................   setup_spi(SPI_MASTER | SPI_L_TO_H | SPI_XMIT_L_TO_H | SPI_CLK_DIV_16); 
434A:  BCF    FC6.5
434C:  BCF    F94.7
434E:  BSF    F93.0
4350:  BCF    F93.1
4352:  MOVLW  21
4354:  MOVWF  FC6
4356:  MOVLW  40
4358:  MOVWF  FC7
....................   setup_wdt(WDT_OFF); 
435A:  BCF    FD1.0
....................   setup_timer_0(RTCC_INTERNAL); 
435C:  MOVLW  80
435E:  MOVWF  FD5
....................   setup_timer_1(T1_DISABLED); 
4360:  CLRF   FCD
....................   //sy setup_timer_2(T2_DIV_BY_1, 255, 1);// for PWM 
....................   setup_timer_2(T2_DISABLED, 255, 1); 
4362:  MOVLW  00
4364:  MOVWF  FCA
4366:  MOVLW  FF
4368:  MOVWF  FCB
....................   setup_timer_3(T3_DISABLED|T3_DIV_BY_1); 
436A:  CLRF   FB1
....................   setup_comparator(NC_NC_NC_NC); 
436C:  MOVLW  07
436E:  MOVWF  FB4
4370:  MOVF   F92,W
4372:  MOVWF  F92
4374:  MOVLW  27
4376:  MOVWF  00
4378:  DECFSZ 00,F
437A:  BRA    4378
437C:  BRA    437E
437E:  MOVF   FB4,W
4380:  BCF    FA1.6
....................   setup_vref(FALSE); 
4382:  CLRF   FB5
....................   //sy setup_ccp1(CCP_PWM); 
....................   //sy set_pwm1_duty(0); 
....................   //Setup_Oscillator parameter not selected from Intr Oscillator Config tab 
....................  
....................   // Parameters Initialized 
....................   for(i = 0; i < 7; i++) 
4384:  MOVLB  0
4386:  CLRF   x88
4388:  MOVF   x88,W
438A:  SUBLW  06
438C:  BNC   43F6
....................   { 
....................     countAve[i] = 0; 
438E:  CLRF   03
4390:  MOVF   x88,W
4392:  ADDLW  EA
4394:  MOVWF  FE9
4396:  MOVLW  01
4398:  ADDWFC 03,W
439A:  MOVWF  FEA
439C:  CLRF   FEF
....................     adc_total[i] = 0; 
439E:  BCF    FD8.0
43A0:  RLCF   x88,W
43A2:  CLRF   03
43A4:  ADDLW  F3
43A6:  MOVWF  FE9
43A8:  MOVLW  01
43AA:  ADDWFC 03,W
43AC:  MOVWF  FEA
43AE:  CLRF   FEC
43B0:  MOVF   FED,F
43B2:  CLRF   FEF
....................     for(j = 0; j < 8; j++) 
43B4:  CLRF   x89
43B6:  MOVF   x89,W
43B8:  SUBLW  07
43BA:  BNC   43F2
....................       adc_value[i][j] = 0; 
43BC:  MOVF   x88,W
43BE:  MULLW  10
43C0:  MOVF   FF3,W
43C2:  MOVLB  2
43C4:  CLRF   x78
43C6:  MOVWF  x77
43C8:  BCF    FD8.0
43CA:  MOVLB  0
43CC:  RLCF   x89,W
43CE:  CLRF   03
43D0:  MOVLB  2
43D2:  ADDWF  x77,W
43D4:  MOVWF  01
43D6:  MOVF   x78,W
43D8:  ADDWFC 03,F
43DA:  MOVF   01,W
43DC:  ADDLW  01
43DE:  MOVWF  FE9
43E0:  MOVLW  02
43E2:  ADDWFC 03,W
43E4:  MOVWF  FEA
43E6:  CLRF   FEC
43E8:  MOVF   FED,F
43EA:  CLRF   FEF
43EC:  MOVLB  0
43EE:  INCF   x89,F
43F0:  BRA    43B6
....................   } 
43F2:  INCF   x88,F
43F4:  BRA    4388
....................  
....................   getParaFromEeprom(&para, sizeof(para), 0); 
43F6:  MOVLW  02
43F8:  MOVLB  2
43FA:  MOVWF  x78
43FC:  MOVLW  76
43FE:  MOVWF  x77
4400:  MOVLW  01
4402:  MOVWF  x79
4404:  CLRF   x7A
4406:  MOVLB  0
4408:  GOTO   272A
....................   if(!(para.intensity > 0)) 
440C:  MOVLB  2
440E:  MOVF   x76,F
4410:  BNZ   4418
....................     initAndSaveParaToEeprom(); 
4412:  MOVLB  0
4414:  GOTO   27C0
....................  
....................   // Button Initialized 
....................   buttonInit(); 
4418:  MOVLB  0
441A:  GOTO   27DC
....................  
....................   output_bit(SR_A, 1); 
441E:  BSF    F8A.7
4420:  BCF    F93.7
....................   for(i = 0; i < 8; i++) 
4422:  CLRF   x88
4424:  MOVF   x88,W
4426:  SUBLW  07
4428:  BNC   444C
....................   { 
....................     led_data[i] = 0; 
442A:  BCF    FD8.0
442C:  RLCF   x88,W
442E:  CLRF   03
4430:  ADDLW  93
4432:  MOVWF  FE9
4434:  MOVLW  00
4436:  ADDWFC 03,W
4438:  MOVWF  FEA
443A:  CLRF   FEC
443C:  MOVF   FED,F
443E:  CLRF   FEF
....................     output_bit(SR_CLK, 1); 
4440:  BSF    F8A.6
4442:  BCF    F93.6
....................     output_bit(SR_CLK, 0); 
4444:  BCF    F8A.6
4446:  BCF    F93.6
....................   } 
4448:  INCF   x88,F
444A:  BRA    4424
....................  
....................   // Input Initialized 
....................   inputInit(); 
444C:  GOTO   286C
....................  
....................   // MAX7219 Initialized 
....................   initLedDriver(); 
4450:  GOTO   28F4
....................  
....................   // USB CDC Class Initialized 
....................   usb_cdc_init(); 
4454:  CALL   1A48
....................   usb_init(); 
4458:  GOTO   2BD0
....................   while(!usb_cdc_connected()){} 
445C:  BTFSC  x81.1
445E:  BRA    4462
4460:  BRA    445C
....................  
....................   while(TRUE) 
....................   { 
....................     usb_task(); 
4462:  CALL   2BAE
....................     if(usb_enumerated()) 
4466:  MOVF   20,F
4468:  BZ    4472
....................     { 
....................       receiveOscMsgs(); 
446A:  GOTO   3360
....................  
....................       // Button Handling 
....................       sendOscMsgPress(); 
446E:  BRA    3E5C
....................  
....................       // Digital Input Handling 
....................       //sy sendOscMsgInput(); 
....................  
....................       // Adc Handling 
....................       sendOscMsgAdc(); 
4470:  BRA    40A2
....................     } 
....................   } 
4472:  BRA    4462
.................... } 
....................  
.................... /***********************************/ 
.................... /*                                 */ 
.................... /*    Functions for Max7219CNG     */ 
.................... /*                                 */ 
.................... /***********************************/ 
.................... #ifndef ONE_TWENTY_EIGHT//for sixty four 
.................... void initLedDriver(void) 
.................... { 
....................   sendSpiLED(0x0B, 0x07);           // Scan Limit full range 
....................   sendSpiLED(0x0C, 0x01);           // Shutdown Normal Operation 
....................   sendSpiLED(0x0F, 0x00);           // Display Test Off 
....................  
....................   // print startup pattern  
....................   sendSpiLED(0x0A, 0x0F); // Max Intensity 0x00[min] - 0x0F[max] 
....................   sendSpiLED(1, 0); 
....................   sendSpiLED(2, 0); 
....................   sendSpiLED(3, 0); 
....................   sendSpiLED(4, 24); 
....................   sendSpiLED(5, 24); 
....................   sendSpiLED(6, 0); 
....................   sendSpiLED(7, 0); 
....................   sendSpiLED(8, 0); 
....................   for(i = 0; i < 64; i++) 
....................   { 
....................     sendSpiLED(0x0A, (64 - i) / 4);   // set to max intensity 
....................     delay_ms(4); 
....................   } 
....................   sendSpiLED(0x0A, 0x0F); // Max Intensity 0x00[min] - 0x0F[max] 
....................   sendSpiLED(1, 0); 
....................   sendSpiLED(2, 0); 
....................   sendSpiLED(3, 24); 
....................   sendSpiLED(4, 36); 
....................   sendSpiLED(5, 36); 
....................   sendSpiLED(6, 24); 
....................   sendSpiLED(7, 0); 
....................   sendSpiLED(8, 0); 
....................   for(i = 0; i < 64; i++) 
....................   { 
....................     sendSpiLED(0x0A, (64 - i) / 4);   // set to max intensity 
....................     delay_ms(4); 
....................   } 
....................   sendSpiLED(0x0A, 0x0F); // Max Intensity 0x00[min] - 0x0F[max] 
....................   sendSpiLED(1, 0); 
....................   sendSpiLED(2, 24); 
....................   sendSpiLED(3, 36); 
....................   sendSpiLED(4, 66); 
....................   sendSpiLED(5, 66); 
....................   sendSpiLED(6, 36); 
....................   sendSpiLED(7, 24); 
....................   sendSpiLED(8, 0); 
....................   for(i = 0; i < 64; i++) 
....................   { 
....................     sendSpiLED(0x0A, (64 - i) / 4);   // set to max intensity 
....................     delay_ms(4); 
....................   } 
....................  
....................   sendSpiLED(0x0A, para.intensity); // Max Intensity 0x00[min] - 0x0F[max] 
....................   for(i = 1; i < 9; i++) 
....................     sendSpiLED(i, 0x00); 
.................... } 
....................  
.................... void sendSpiLED(int msb, int lsb) 
.................... { 
....................   output_bit(LDD_LOAD, 0); 
....................   spi_write(msb); 
....................   spi_write(lsb); 
....................   output_bit(LDD_LOAD, 1); 
....................   delay_cycles(1); 
.................... } 
.................... #else//for one twenty eight 
.................... void initLedDriver(void) 
.................... { 
4474:  SLEEP 
....................   sendSpiLED2(0x0B, 0x07, 0x0B, 0x07);      // Scan Limit full range 
*
28F4:  MOVLW  0B
28F6:  MOVLB  2
28F8:  MOVWF  x87
28FA:  MOVLW  07
28FC:  MOVWF  x88
28FE:  MOVLW  0B
2900:  MOVWF  x89
2902:  MOVLW  07
2904:  MOVWF  x8A
2906:  MOVLB  0
2908:  RCALL  2896
....................   sendSpiLED2(0x0C, 0x01, 0x0C, 0x01);      // Shutdown Normal Operation 
290A:  MOVLW  0C
290C:  MOVLB  2
290E:  MOVWF  x87
2910:  MOVLW  01
2912:  MOVWF  x88
2914:  MOVLW  0C
2916:  MOVWF  x89
2918:  MOVLW  01
291A:  MOVWF  x8A
291C:  MOVLB  0
291E:  RCALL  2896
....................   sendSpiLED2(0x0F, 0x00, 0x0F, 0x00);      // Display Test Off 
2920:  MOVLW  0F
2922:  MOVLB  2
2924:  MOVWF  x87
2926:  CLRF   x88
2928:  MOVWF  x89
292A:  CLRF   x8A
292C:  MOVLB  0
292E:  RCALL  2896
....................  
....................   // print startup pattern  
....................   sendSpiLED2(0x0A, 0x0F, 0x0A, 0x0F); // Max Intensity 0x00[min] - 0x0F[max] 
2930:  MOVLW  0A
2932:  MOVLB  2
2934:  MOVWF  x87
2936:  MOVLW  0F
2938:  MOVWF  x88
293A:  MOVLW  0A
293C:  MOVWF  x89
293E:  MOVLW  0F
2940:  MOVWF  x8A
2942:  MOVLB  0
2944:  RCALL  2896
....................   sendSpiLED2(4, 24, 4, 0); 
2946:  MOVLW  04
2948:  MOVLB  2
294A:  MOVWF  x87
294C:  MOVLW  18
294E:  MOVWF  x88
2950:  MOVLW  04
2952:  MOVWF  x89
2954:  CLRF   x8A
2956:  MOVLB  0
2958:  RCALL  2896
....................   sendSpiLED2(5, 24, 5, 0); 
295A:  MOVLW  05
295C:  MOVLB  2
295E:  MOVWF  x87
2960:  MOVLW  18
2962:  MOVWF  x88
2964:  MOVLW  05
2966:  MOVWF  x89
2968:  CLRF   x8A
296A:  MOVLB  0
296C:  RCALL  2896
....................   for(i = 0; i < 64; i++) 
296E:  CLRF   x88
2970:  MOVF   x88,W
2972:  SUBLW  3F
2974:  BNC   29A8
....................   { 
....................     sendSpiLED2(0x0A, (64 - i) / 4, 0x0A, 0);   // set to max intensity 
2976:  MOVLW  40
2978:  BSF    FD8.0
297A:  SUBFWB x88,W
297C:  MOVWF  00
297E:  RRCF   00,W
2980:  MOVLB  2
2982:  MOVWF  x77
2984:  RRCF   x77,F
2986:  MOVLW  3F
2988:  ANDWF  x77,F
298A:  MOVLW  0A
298C:  MOVWF  x87
298E:  MOVFF  277,288
2992:  MOVWF  x89
2994:  CLRF   x8A
2996:  MOVLB  0
2998:  RCALL  2896
....................     delay_ms(4); 
299A:  MOVLW  04
299C:  MOVLB  2
299E:  MOVWF  x77
29A0:  MOVLB  0
29A2:  RCALL  28CA
....................   } 
29A4:  INCF   x88,F
29A6:  BRA    2970
....................   sendSpiLED2(0x0A, 0x0F, 0x0A, 0x0F); // Max Intensity 0x00[min] - 0x0F[max] 
29A8:  MOVLW  0A
29AA:  MOVLB  2
29AC:  MOVWF  x87
29AE:  MOVLW  0F
29B0:  MOVWF  x88
29B2:  MOVLW  0A
29B4:  MOVWF  x89
29B6:  MOVLW  0F
29B8:  MOVWF  x8A
29BA:  MOVLB  0
29BC:  RCALL  2896
....................   sendSpiLED2(3, 24, 3, 0); 
29BE:  MOVLW  03
29C0:  MOVLB  2
29C2:  MOVWF  x87
29C4:  MOVLW  18
29C6:  MOVWF  x88
29C8:  MOVLW  03
29CA:  MOVWF  x89
29CC:  CLRF   x8A
29CE:  MOVLB  0
29D0:  RCALL  2896
....................   sendSpiLED2(4, 36, 4, 0); 
29D2:  MOVLW  04
29D4:  MOVLB  2
29D6:  MOVWF  x87
29D8:  MOVLW  24
29DA:  MOVWF  x88
29DC:  MOVLW  04
29DE:  MOVWF  x89
29E0:  CLRF   x8A
29E2:  MOVLB  0
29E4:  RCALL  2896
....................   sendSpiLED2(5, 36, 5, 0); 
29E6:  MOVLW  05
29E8:  MOVLB  2
29EA:  MOVWF  x87
29EC:  MOVLW  24
29EE:  MOVWF  x88
29F0:  MOVLW  05
29F2:  MOVWF  x89
29F4:  CLRF   x8A
29F6:  MOVLB  0
29F8:  RCALL  2896
....................   sendSpiLED2(6, 24, 6, 0); 
29FA:  MOVLW  06
29FC:  MOVLB  2
29FE:  MOVWF  x87
2A00:  MOVLW  18
2A02:  MOVWF  x88
2A04:  MOVLW  06
2A06:  MOVWF  x89
2A08:  CLRF   x8A
2A0A:  MOVLB  0
2A0C:  RCALL  2896
....................   for(i = 0; i < 64; i++) 
2A0E:  CLRF   x88
2A10:  MOVF   x88,W
2A12:  SUBLW  3F
2A14:  BNC   2A48
....................   { 
....................     sendSpiLED2(0x0A, (64 - i) / 4, 0, 0);   // set to max intensity 
2A16:  MOVLW  40
2A18:  BSF    FD8.0
2A1A:  SUBFWB x88,W
2A1C:  MOVWF  00
2A1E:  RRCF   00,W
2A20:  MOVLB  2
2A22:  MOVWF  x77
2A24:  RRCF   x77,F
2A26:  MOVLW  3F
2A28:  ANDWF  x77,F
2A2A:  MOVLW  0A
2A2C:  MOVWF  x87
2A2E:  MOVFF  277,288
2A32:  CLRF   x89
2A34:  CLRF   x8A
2A36:  MOVLB  0
2A38:  RCALL  2896
....................     delay_ms(4); 
2A3A:  MOVLW  04
2A3C:  MOVLB  2
2A3E:  MOVWF  x77
2A40:  MOVLB  0
2A42:  RCALL  28CA
....................   } 
2A44:  INCF   x88,F
2A46:  BRA    2A10
....................   sendSpiLED2(0x0A, 0x0F, 0x0A, 0x0F); // Max Intensity 0x00[min] - 0x0F[max] 
2A48:  MOVLW  0A
2A4A:  MOVLB  2
2A4C:  MOVWF  x87
2A4E:  MOVLW  0F
2A50:  MOVWF  x88
2A52:  MOVLW  0A
2A54:  MOVWF  x89
2A56:  MOVLW  0F
2A58:  MOVWF  x8A
2A5A:  MOVLB  0
2A5C:  RCALL  2896
....................   sendSpiLED2(2, 24, 2, 0); 
2A5E:  MOVLW  02
2A60:  MOVLB  2
2A62:  MOVWF  x87
2A64:  MOVLW  18
2A66:  MOVWF  x88
2A68:  MOVLW  02
2A6A:  MOVWF  x89
2A6C:  CLRF   x8A
2A6E:  MOVLB  0
2A70:  RCALL  2896
....................   sendSpiLED2(3, 36, 3, 0); 
2A72:  MOVLW  03
2A74:  MOVLB  2
2A76:  MOVWF  x87
2A78:  MOVLW  24
2A7A:  MOVWF  x88
2A7C:  MOVLW  03
2A7E:  MOVWF  x89
2A80:  CLRF   x8A
2A82:  MOVLB  0
2A84:  RCALL  2896
....................   sendSpiLED2(4, 66, 4, 0); 
2A86:  MOVLW  04
2A88:  MOVLB  2
2A8A:  MOVWF  x87
2A8C:  MOVLW  42
2A8E:  MOVWF  x88
2A90:  MOVLW  04
2A92:  MOVWF  x89
2A94:  CLRF   x8A
2A96:  MOVLB  0
2A98:  RCALL  2896
....................   sendSpiLED2(5, 66, 5, 0); 
2A9A:  MOVLW  05
2A9C:  MOVLB  2
2A9E:  MOVWF  x87
2AA0:  MOVLW  42
2AA2:  MOVWF  x88
2AA4:  MOVLW  05
2AA6:  MOVWF  x89
2AA8:  CLRF   x8A
2AAA:  MOVLB  0
2AAC:  RCALL  2896
....................   sendSpiLED2(6, 36, 6, 0); 
2AAE:  MOVLW  06
2AB0:  MOVLB  2
2AB2:  MOVWF  x87
2AB4:  MOVLW  24
2AB6:  MOVWF  x88
2AB8:  MOVLW  06
2ABA:  MOVWF  x89
2ABC:  CLRF   x8A
2ABE:  MOVLB  0
2AC0:  RCALL  2896
....................   sendSpiLED2(7, 24, 7, 0); 
2AC2:  MOVLW  07
2AC4:  MOVLB  2
2AC6:  MOVWF  x87
2AC8:  MOVLW  18
2ACA:  MOVWF  x88
2ACC:  MOVLW  07
2ACE:  MOVWF  x89
2AD0:  CLRF   x8A
2AD2:  MOVLB  0
2AD4:  RCALL  2896
....................   for(i = 0; i < 64; i++) 
2AD6:  CLRF   x88
2AD8:  MOVF   x88,W
2ADA:  SUBLW  3F
2ADC:  BNC   2B28
....................   { 
....................     sendSpiLED2(0x0A, (64 - i) / 4, 0x0A, (64 - i) / 4);   // set to max intensity 
2ADE:  MOVLW  40
2AE0:  BSF    FD8.0
2AE2:  SUBFWB x88,W
2AE4:  MOVWF  00
2AE6:  RRCF   00,W
2AE8:  MOVLB  2
2AEA:  MOVWF  x77
2AEC:  RRCF   x77,F
2AEE:  MOVLW  3F
2AF0:  ANDWF  x77,F
2AF2:  MOVLW  40
2AF4:  BSF    FD8.0
2AF6:  MOVLB  0
2AF8:  SUBFWB x88,W
2AFA:  MOVWF  00
2AFC:  RRCF   00,W
2AFE:  MOVLB  2
2B00:  MOVWF  x78
2B02:  RRCF   x78,F
2B04:  MOVLW  3F
2B06:  ANDWF  x78,F
2B08:  MOVLW  0A
2B0A:  MOVWF  x87
2B0C:  MOVFF  277,288
2B10:  MOVWF  x89
2B12:  MOVFF  278,28A
2B16:  MOVLB  0
2B18:  RCALL  2896
....................     delay_ms(4); 
2B1A:  MOVLW  04
2B1C:  MOVLB  2
2B1E:  MOVWF  x77
2B20:  MOVLB  0
2B22:  RCALL  28CA
....................   } 
2B24:  INCF   x88,F
2B26:  BRA    2AD8
....................  
....................   sendSpiLED2(0x0A, para.intensity, 0x0A, para.intensity); // Max Intensity 0x00[min] - 0x0F[max] 
2B28:  MOVLW  0A
2B2A:  MOVLB  2
2B2C:  MOVWF  x87
2B2E:  MOVFF  276,288
2B32:  MOVWF  x89
2B34:  MOVFF  276,28A
2B38:  MOVLB  0
2B3A:  RCALL  2896
....................  
....................   for(i = 1; i < 9; i++) 
2B3C:  MOVLW  01
2B3E:  MOVWF  x88
2B40:  MOVF   x88,W
2B42:  SUBLW  08
2B44:  BNC   2B5C
....................   { 
....................     sendSpiLED2(i, 0x00, i, 0x00); 
2B46:  MOVFF  88,287
2B4A:  MOVLB  2
2B4C:  CLRF   x88
2B4E:  MOVFF  88,289
2B52:  CLRF   x8A
2B54:  MOVLB  0
2B56:  RCALL  2896
....................   } 
2B58:  INCF   x88,F
2B5A:  BRA    2B40
.................... } 
2B5C:  GOTO   4454 (RETURN)
....................  
.................... void sendSpiLED2(int msb0, int lsb0, int msb1, int lsb1) 
.................... { 
....................   output_bit(LDD_LOAD, 0); 
*
2896:  BCF    F8A.5
2898:  BCF    F93.5
....................   spi_write(msb1); 
289A:  MOVF   FC9,W
289C:  MOVFF  289,FC9
28A0:  RRCF   FC7,W
28A2:  BNC   28A0
....................   spi_write(lsb1); 
28A4:  MOVF   FC9,W
28A6:  MOVFF  28A,FC9
28AA:  RRCF   FC7,W
28AC:  BNC   28AA
....................   spi_write(msb0); 
28AE:  MOVF   FC9,W
28B0:  MOVFF  287,FC9
28B4:  RRCF   FC7,W
28B6:  BNC   28B4
....................   spi_write(lsb0); 
28B8:  MOVF   FC9,W
28BA:  MOVFF  288,FC9
28BE:  RRCF   FC7,W
28C0:  BNC   28BE
....................   output_bit(LDD_LOAD, 1); 
28C2:  BSF    F8A.5
28C4:  BCF    F93.5
....................   delay_cycles(1); 
28C6:  NOP   
.................... } 
28C8:  RETLW  00
.................... #endif//sy 
....................  
.................... /***********************************/ 
.................... /*                                 */ 
.................... /*    Function for OSC Msgs Rcv    */ 
.................... /*                                 */ 
.................... /***********************************/ 
.................... void receiveOscMsgs(void) 
.................... { 
....................   if(usb_cdc_kbhit()) 
*
3360:  BTFSS  x83.0
3362:  GOTO   3B4A
....................   { 
....................     my_get_string_usb(string, 15); 
3366:  MOVLB  2
3368:  CLRF   x85
336A:  MOVLW  A4
336C:  MOVWF  x84
336E:  MOVLW  0F
3370:  MOVWF  x86
3372:  MOVLB  0
3374:  BRA    2C2A
....................  
....................     if(string[0] == 'l' && (string[1] == '0' || string[1] == '1')) // led 
3376:  MOVF   xA4,W
3378:  SUBLW  6C
337A:  BTFSS  FD8.2
337C:  BRA    34C4
337E:  MOVF   xA5,W
3380:  SUBLW  30
3382:  BZ    338C
3384:  MOVF   xA5,W
3386:  SUBLW  31
3388:  BTFSS  FD8.2
338A:  BRA    34C4
....................     { 
....................       y = my_atoi(string[3]); 
338C:  MOVFF  A7,284
3390:  RCALL  2C7C
3392:  MOVFF  01,8D
....................       if(y >= 8) 
3396:  MOVF   x8D,W
3398:  SUBLW  07
339A:  BC    33A0
....................         return; 
339C:  GOTO   3B4A
....................       x = my_atoi(string[2]); 
33A0:  MOVFF  A6,284
33A4:  RCALL  2C7C
33A6:  MOVFF  01,8C
....................       state = my_atoi(string[1]); 
33AA:  MOVFF  A5,284
33AE:  RCALL  2C7C
33B0:  MOVFF  01,8E
.................... #ifndef ONE_TWENTY_EIGHT//for sixty four 
....................       if(state) 
....................         led_data[y] |= (1 << x); 
....................       else 
....................         led_data[y] &= ~(1 << x); 
....................  
....................       sendSpiLED(y + 1, led_data[y]); 
.................... #else//for one twenty eight 
....................       if(x < 8) 
33B4:  MOVF   x8C,W
33B6:  SUBLW  07
33B8:  BNC   33CE
....................       { 
....................         x1 = y; 
33BA:  MOVFF  8D,8F
....................         y1 = 7 - x; 
33BE:  MOVLW  07
33C0:  BSF    FD8.0
33C2:  SUBFWB x8C,W
33C4:  MOVWF  x90
....................         x = x1; 
33C6:  MOVFF  8F,8C
....................         y = y1; 
33CA:  MOVFF  90,8D
....................       } 
....................       if(state == 0) 
33CE:  MOVF   x8E,F
33D0:  BNZ   341C
....................         led_data[y] &= ~((long)1 << x); 
33D2:  BCF    FD8.0
33D4:  RLCF   x8D,W
33D6:  CLRF   03
33D8:  ADDLW  93
33DA:  MOVWF  FE9
33DC:  MOVLW  00
33DE:  ADDWFC 03,W
33E0:  MOVWF  FEA
33E2:  CLRF   03
33E4:  MOVLW  01
33E6:  MOVWF  02
33E8:  MOVF   x8C,W
33EA:  MOVWF  00
33EC:  BZ    33F8
33EE:  BCF    FD8.0
33F0:  RLCF   02,F
33F2:  RLCF   03,F
33F4:  DECFSZ 00,F
33F6:  BRA    33EE
33F8:  MOVF   02,W
33FA:  CLRF   00
33FC:  DECF   00,F
33FE:  XORWF  00,F
3400:  MOVLW  FF
3402:  XORWF  03,F
3404:  MOVF   00,W
3406:  ANDWF  FEF,W
3408:  MOVWF  00
340A:  MOVF   03,W
340C:  ANDWF  FEC,W
340E:  MOVWF  03
3410:  MOVF   00,W
3412:  MOVF   FED,F
3414:  MOVWF  FEF
3416:  MOVFF  03,FEC
....................       else 
341A:  BRA    3458
....................         led_data[y] |= ((long)1 << x); 
341C:  BCF    FD8.0
341E:  RLCF   x8D,W
3420:  CLRF   03
3422:  ADDLW  93
3424:  MOVWF  FE9
3426:  MOVLW  00
3428:  ADDWFC 03,W
342A:  MOVWF  FEA
342C:  CLRF   03
342E:  MOVLW  01
3430:  MOVWF  02
3432:  MOVF   x8C,W
3434:  MOVWF  00
3436:  BZ    3442
3438:  BCF    FD8.0
343A:  RLCF   02,F
343C:  RLCF   03,F
343E:  DECFSZ 00,F
3440:  BRA    3438
3442:  MOVF   02,W
3444:  IORWF  FEF,W
3446:  MOVWF  00
3448:  MOVF   03,W
344A:  IORWF  FEC,W
344C:  MOVWF  03
344E:  MOVF   00,W
3450:  MOVF   FED,F
3452:  MOVWF  FEF
3454:  MOVFF  03,FEC
....................  
....................       lsb0 = (int)(led_data[y] & 0x00FF); 
3458:  BCF    FD8.0
345A:  RLCF   x8D,W
345C:  CLRF   03
345E:  ADDLW  93
3460:  MOVWF  FE9
3462:  MOVLW  00
3464:  ADDWFC 03,W
3466:  MOVWF  FEA
3468:  MOVFF  FEC,285
346C:  MOVF   FED,F
346E:  MOVFF  FEF,284
3472:  MOVFF  284,91
3476:  MOVLB  0
....................       lsb1 = (int)((led_data[y] & 0xFF00) >> 8); 
3478:  BCF    FD8.0
347A:  RLCF   x8D,W
347C:  CLRF   03
347E:  ADDLW  93
3480:  MOVWF  FE9
3482:  MOVLW  00
3484:  ADDWFC 03,W
3486:  MOVWF  FEA
3488:  MOVFF  FEC,285
348C:  MOVF   FED,F
348E:  MOVFF  FEF,284
3492:  MOVLB  2
3494:  CLRF   x84
3496:  MOVF   x85,W
3498:  MOVLB  0
349A:  MOVWF  x92
....................       sendSpiLED2(y + 1, lsb0, y + 1, lsb1); 
349C:  MOVLW  01
349E:  ADDWF  x8D,W
34A0:  MOVLB  2
34A2:  MOVWF  x84
34A4:  MOVLW  01
34A6:  MOVLB  0
34A8:  ADDWF  x8D,W
34AA:  MOVLB  2
34AC:  MOVWF  x85
34AE:  MOVFF  284,287
34B2:  MOVFF  91,288
34B6:  MOVWF  x89
34B8:  MOVFF  92,28A
34BC:  MOVLB  0
34BE:  CALL   2896
.................... #endif 
....................     } 
....................     else if(string[0] == 'l' && string[1] == 'c') // led_col 
34C2:  BRA    3B4A
34C4:  MOVF   xA4,W
34C6:  SUBLW  6C
34C8:  BTFSS  FD8.2
34CA:  BRA    371A
34CC:  MOVF   xA5,W
34CE:  SUBLW  63
34D0:  BTFSS  FD8.2
34D2:  BRA    371A
....................     { 
.................... #ifndef ONE_TWENTY_EIGHT//for sixty four       
....................       int column, data; 
....................       ch = strtok(string, space); 
....................       ch = strtok(0, space); 
....................       column = atoi(ch); 
....................       ch = strtok(0, space); 
....................       data = atoi(ch); 
....................  
....................       if(firstRun == TRUE) 
....................       { 
....................         for(i = 0; i < 8; i++) 
....................         { 
....................           led_data[i] = 0; 
....................           sendSpiLED(i + 1, led_data[i]); 
....................         } 
....................         firstRun = FALSE; 
....................       } 
....................       for(i = 0; i < 8; i++) 
....................       { 
....................         if(data & (1 << i)) 
....................           led_data[i] |= 1 << column; 
....................         else 
....................           led_data[i] &= ~(1 << column); 
....................          
....................         sendSpiLED(i + 1, led_data[i]); 
....................       } 
.................... #else//for one twenty eight 
....................       int column, data; 
....................       int column1, i1; 
....................       ch = strtok(string, space); 
34D4:  MOVLB  2
34D6:  CLRF   x85
34D8:  MOVLW  A4
34DA:  MOVWF  x84
34DC:  CLRF   x87
34DE:  MOVLW  B3
34E0:  MOVWF  x86
34E2:  MOVLB  0
34E4:  RCALL  2DC2
34E6:  MOVFF  02,8B
34EA:  MOVFF  01,8A
....................       ch = strtok(0, space); 
34EE:  MOVLB  2
34F0:  CLRF   x85
34F2:  CLRF   x84
34F4:  CLRF   x87
34F6:  MOVLW  B3
34F8:  MOVWF  x86
34FA:  MOVLB  0
34FC:  RCALL  2DC2
34FE:  MOVFF  02,8B
3502:  MOVFF  01,8A
....................       column = atoi(ch); 
3506:  MOVFF  8B,285
350A:  MOVFF  8A,284
350E:  RCALL  2EC2
3510:  MOVFF  01,277
....................       ch = strtok(0, space); 
3514:  MOVLB  2
3516:  CLRF   x85
3518:  CLRF   x84
351A:  CLRF   x87
351C:  MOVLW  B3
351E:  MOVWF  x86
3520:  MOVLB  0
3522:  RCALL  2DC2
3524:  MOVFF  02,8B
3528:  MOVFF  01,8A
....................       data = atoi(ch); 
352C:  MOVFF  8B,285
3530:  MOVFF  8A,284
3534:  RCALL  2EC2
3536:  MOVFF  01,278
....................  
....................       if(firstRun == TRUE) 
353A:  DECFSZ xA3,W
353C:  BRA    35CC
....................       { 
....................         for(i = 0; i < 8; i++) 
353E:  CLRF   x88
3540:  MOVF   x88,W
3542:  SUBLW  07
3544:  BNC   35CA
....................         { 
....................           led_data[i] = 0; 
3546:  BCF    FD8.0
3548:  RLCF   x88,W
354A:  CLRF   03
354C:  ADDLW  93
354E:  MOVWF  FE9
3550:  MOVLW  00
3552:  ADDWFC 03,W
3554:  MOVWF  FEA
3556:  CLRF   FEC
3558:  MOVF   FED,F
355A:  CLRF   FEF
....................           lsb0 = (int)(led_data[i] & 0x00FF); 
355C:  BCF    FD8.0
355E:  RLCF   x88,W
3560:  CLRF   03
3562:  ADDLW  93
3564:  MOVWF  FE9
3566:  MOVLW  00
3568:  ADDWFC 03,W
356A:  MOVWF  FEA
356C:  MOVFF  FEC,285
3570:  MOVF   FED,F
3572:  MOVFF  FEF,284
3576:  MOVFF  284,91
357A:  MOVLB  0
....................           lsb1 = (int)((led_data[i] & 0xFF00) >> 8); 
357C:  BCF    FD8.0
357E:  RLCF   x88,W
3580:  CLRF   03
3582:  ADDLW  93
3584:  MOVWF  FE9
3586:  MOVLW  00
3588:  ADDWFC 03,W
358A:  MOVWF  FEA
358C:  MOVFF  FEC,285
3590:  MOVF   FED,F
3592:  MOVFF  FEF,284
3596:  MOVLB  2
3598:  CLRF   x84
359A:  MOVF   x85,W
359C:  MOVLB  0
359E:  MOVWF  x92
....................           sendSpiLED2(i + 1, lsb0, i + 1, lsb1); 
35A0:  MOVLW  01
35A2:  ADDWF  x88,W
35A4:  MOVLB  2
35A6:  MOVWF  x84
35A8:  MOVLW  01
35AA:  MOVLB  0
35AC:  ADDWF  x88,W
35AE:  MOVLB  2
35B0:  MOVWF  x85
35B2:  MOVFF  284,287
35B6:  MOVFF  91,288
35BA:  MOVWF  x89
35BC:  MOVFF  92,28A
35C0:  MOVLB  0
35C2:  CALL   2896
....................         } 
35C6:  INCF   x88,F
35C8:  BRA    3540
....................         firstRun = FALSE; 
35CA:  CLRF   xA3
....................       } 
....................       for(i = 0; i < 8; i++) 
35CC:  CLRF   x88
35CE:  MOVF   x88,W
35D0:  SUBLW  07
35D2:  BTFSS  FD8.0
35D4:  BRA    3718
....................       { 
....................         if(column < 8) 
35D6:  MOVLB  2
35D8:  MOVF   x77,W
35DA:  SUBLW  07
35DC:  BNC   35EC
....................         { 
....................           column1 = i; 
35DE:  MOVFF  88,279
....................           i1 = 7 - column; 
35E2:  MOVLW  07
35E4:  BSF    FD8.0
35E6:  SUBFWB x77,W
35E8:  MOVWF  x7A
....................         } 
....................         else 
35EA:  BRA    35F4
....................         { 
....................           column1 = column; 
35EC:  MOVFF  277,279
....................           i1 = i; 
35F0:  MOVFF  88,27A
....................         } 
....................         if(data & (1 << i)) 
35F4:  MOVLW  01
35F6:  MOVWF  00
35F8:  MOVLB  0
35FA:  MOVF   x88,W
35FC:  MOVWF  01
35FE:  BZ    3608
3600:  BCF    FD8.0
3602:  RLCF   00,F
3604:  DECFSZ 01,F
3606:  BRA    3600
3608:  MOVF   00,W
360A:  MOVLB  2
360C:  ANDWF  x78,W
360E:  BZ    364E
....................           led_data[i1] |= ((long)1 << column1); 
3610:  BCF    FD8.0
3612:  RLCF   x7A,W
3614:  CLRF   03
3616:  ADDLW  93
3618:  MOVWF  FE9
361A:  MOVLW  00
361C:  ADDWFC 03,W
361E:  MOVWF  FEA
3620:  CLRF   03
3622:  MOVLW  01
3624:  MOVWF  02
3626:  MOVF   x79,W
3628:  MOVWF  00
362A:  BZ    3636
362C:  BCF    FD8.0
362E:  RLCF   02,F
3630:  RLCF   03,F
3632:  DECFSZ 00,F
3634:  BRA    362C
3636:  MOVF   02,W
3638:  IORWF  FEF,W
363A:  MOVWF  00
363C:  MOVF   03,W
363E:  IORWF  FEC,W
3640:  MOVWF  03
3642:  MOVF   00,W
3644:  MOVF   FED,F
3646:  MOVWF  FEF
3648:  MOVFF  03,FEC
....................         else 
364C:  BRA    3696
....................           led_data[i1] &= ~((long)1 << column1); 
364E:  BCF    FD8.0
3650:  RLCF   x7A,W
3652:  CLRF   03
3654:  ADDLW  93
3656:  MOVWF  FE9
3658:  MOVLW  00
365A:  ADDWFC 03,W
365C:  MOVWF  FEA
365E:  CLRF   03
3660:  MOVLW  01
3662:  MOVWF  02
3664:  MOVF   x79,W
3666:  MOVWF  00
3668:  BZ    3674
366A:  BCF    FD8.0
366C:  RLCF   02,F
366E:  RLCF   03,F
3670:  DECFSZ 00,F
3672:  BRA    366A
3674:  MOVF   02,W
3676:  CLRF   00
3678:  DECF   00,F
367A:  XORWF  00,F
367C:  MOVLW  FF
367E:  XORWF  03,F
3680:  MOVF   00,W
3682:  ANDWF  FEF,W
3684:  MOVWF  00
3686:  MOVF   03,W
3688:  ANDWF  FEC,W
368A:  MOVWF  03
368C:  MOVF   00,W
368E:  MOVF   FED,F
3690:  MOVWF  FEF
3692:  MOVFF  03,FEC
....................          
....................         if(column < 8) { 
3696:  MOVF   x77,W
3698:  SUBLW  07
369A:  BNC   36D8
....................           lsb0 = (int)(led_data[i1] & 0x00FF); 
369C:  BCF    FD8.0
369E:  RLCF   x7A,W
36A0:  CLRF   03
36A2:  ADDLW  93
36A4:  MOVWF  FE9
36A6:  MOVLW  00
36A8:  ADDWFC 03,W
36AA:  MOVWF  FEA
36AC:  MOVFF  FEC,285
36B0:  MOVF   FED,F
36B2:  MOVFF  FEF,284
36B6:  MOVFF  284,91
36BA:  MOVLB  0
....................           sendSpiLED2(i1 + 1, lsb0, 0, 0); 
36BC:  MOVLW  01
36BE:  MOVLB  2
36C0:  ADDWF  x7A,W
36C2:  MOVWF  x84
36C4:  MOVWF  x87
36C6:  MOVFF  91,288
36CA:  CLRF   x89
36CC:  CLRF   x8A
36CE:  MOVLB  0
36D0:  CALL   2896
....................         } 
....................         else { 
36D4:  BRA    3714
36D6:  MOVLB  2
....................           lsb1 = (int)((led_data[i1] >> 8) & 0x00FF); 
36D8:  BCF    FD8.0
36DA:  RLCF   x7A,W
36DC:  CLRF   03
36DE:  ADDLW  93
36E0:  MOVWF  FE9
36E2:  MOVLW  00
36E4:  ADDWFC 03,W
36E6:  MOVWF  FEA
36E8:  MOVFF  FEC,285
36EC:  MOVF   FED,F
36EE:  MOVFF  FEF,284
36F2:  MOVFF  285,284
36F6:  MOVFF  284,92
36FA:  MOVLB  0
....................           sendSpiLED2(0, 0, i1 + 1, lsb1); 
36FC:  MOVLW  01
36FE:  MOVLB  2
3700:  ADDWF  x7A,W
3702:  MOVWF  x84
3704:  CLRF   x87
3706:  CLRF   x88
3708:  MOVWF  x89
370A:  MOVFF  92,28A
370E:  MOVLB  0
3710:  CALL   2896
....................         } 
....................       } 
3714:  INCF   x88,F
3716:  BRA    35CE
.................... #endif//sy 
....................     } 
....................     else if(string[0] == 'l' && string[1] == 'r') // led_row 
3718:  BRA    3B4A
371A:  MOVF   xA4,W
371C:  SUBLW  6C
371E:  BTFSS  FD8.2
3720:  BRA    394A
3722:  MOVF   xA5,W
3724:  SUBLW  72
3726:  BTFSS  FD8.2
3728:  BRA    394A
....................     { 
.................... #ifndef ONE_TWENTY_EIGHT//for sixty four 
....................       int row, data; 
....................       ch = strtok(string, space); 
....................       ch = strtok(0, space); 
....................       row = atoi(ch); 
....................       ch = strtok(0, space); 
....................       data = atoi(ch); 
....................        
....................       if(firstRun == TRUE) 
....................       { 
....................         for(i = 0; i < 8; i++) 
....................         { 
....................           led_data[i] = 0; 
....................           sendSpiLED(i + 1, led_data[i]); 
....................         } 
....................         firstRun = FALSE; 
....................       } 
....................       led_data[row] = data; 
....................       sendSpiLED(row + 1, led_data[row]); 
.................... #else//for one twenty eight 
....................       int row;  
....................       long data; 
....................       int row1, i1; 
....................       ch = strtok(string, space); 
372A:  MOVLB  2
372C:  CLRF   x85
372E:  MOVLW  A4
3730:  MOVWF  x84
3732:  CLRF   x87
3734:  MOVLW  B3
3736:  MOVWF  x86
3738:  MOVLB  0
373A:  CALL   2DC2
373E:  MOVFF  02,8B
3742:  MOVFF  01,8A
....................       ch = strtok(0, space); 
3746:  MOVLB  2
3748:  CLRF   x85
374A:  CLRF   x84
374C:  CLRF   x87
374E:  MOVLW  B3
3750:  MOVWF  x86
3752:  MOVLB  0
3754:  CALL   2DC2
3758:  MOVFF  02,8B
375C:  MOVFF  01,8A
....................       row = atoi(ch); 
3760:  MOVFF  8B,285
3764:  MOVFF  8A,284
3768:  CALL   2EC2
376C:  MOVFF  01,27B
....................       ch = strtok(0, space); 
3770:  MOVLB  2
3772:  CLRF   x85
3774:  CLRF   x84
3776:  CLRF   x87
3778:  MOVLW  B3
377A:  MOVWF  x86
377C:  MOVLB  0
377E:  CALL   2DC2
3782:  MOVFF  02,8B
3786:  MOVFF  01,8A
....................       data = atol(ch); 
378A:  MOVFF  8B,285
378E:  MOVFF  8A,284
3792:  BRA    3088
3794:  MOVFF  02,27D
3798:  MOVFF  01,27C
....................        
....................       if(firstRun == TRUE) 
379C:  DECFSZ xA3,W
379E:  BRA    382E
....................       { 
....................         for(i = 0; i < 8; i++) 
37A0:  CLRF   x88
37A2:  MOVF   x88,W
37A4:  SUBLW  07
37A6:  BNC   382C
....................         { 
....................           led_data[i] = 0; 
37A8:  BCF    FD8.0
37AA:  RLCF   x88,W
37AC:  CLRF   03
37AE:  ADDLW  93
37B0:  MOVWF  FE9
37B2:  MOVLW  00
37B4:  ADDWFC 03,W
37B6:  MOVWF  FEA
37B8:  CLRF   FEC
37BA:  MOVF   FED,F
37BC:  CLRF   FEF
....................           lsb0 = (int)(led_data[i] & 0x00FF); 
37BE:  BCF    FD8.0
37C0:  RLCF   x88,W
37C2:  CLRF   03
37C4:  ADDLW  93
37C6:  MOVWF  FE9
37C8:  MOVLW  00
37CA:  ADDWFC 03,W
37CC:  MOVWF  FEA
37CE:  MOVFF  FEC,285
37D2:  MOVF   FED,F
37D4:  MOVFF  FEF,284
37D8:  MOVFF  284,91
37DC:  MOVLB  0
....................           lsb1 = (int)((led_data[i] & 0xFF00) >> 8); 
37DE:  BCF    FD8.0
37E0:  RLCF   x88,W
37E2:  CLRF   03
37E4:  ADDLW  93
37E6:  MOVWF  FE9
37E8:  MOVLW  00
37EA:  ADDWFC 03,W
37EC:  MOVWF  FEA
37EE:  MOVFF  FEC,285
37F2:  MOVF   FED,F
37F4:  MOVFF  FEF,284
37F8:  MOVLB  2
37FA:  CLRF   x84
37FC:  MOVF   x85,W
37FE:  MOVLB  0
3800:  MOVWF  x92
....................           sendSpiLED2(i + 1, lsb0, i + 1, lsb1); 
3802:  MOVLW  01
3804:  ADDWF  x88,W
3806:  MOVLB  2
3808:  MOVWF  x84
380A:  MOVLW  01
380C:  MOVLB  0
380E:  ADDWF  x88,W
3810:  MOVLB  2
3812:  MOVWF  x85
3814:  MOVFF  284,287
3818:  MOVFF  91,288
381C:  MOVWF  x89
381E:  MOVFF  92,28A
3822:  MOVLB  0
3824:  CALL   2896
....................         } 
3828:  INCF   x88,F
382A:  BRA    37A2
....................         firstRun = FALSE; 
382C:  CLRF   xA3
....................       } 
....................  
....................       lsb0 = (int)(data & 0x00FF); 
382E:  MOVFF  27C,91
3832:  MOVLB  0
....................       for(i = 0; i < 8; i++) 
3834:  CLRF   x88
3836:  MOVF   x88,W
3838:  SUBLW  07
383A:  BTFSS  FD8.0
383C:  BRA    3928
....................       { 
....................         i1 = row; 
383E:  MOVFF  27B,27F
....................         row1 = 7 - i; 
3842:  MOVLW  07
3844:  BSF    FD8.0
3846:  SUBFWB x88,W
3848:  MOVLB  2
384A:  MOVWF  x7E
....................          
....................         if(lsb0 & (1 << i)) 
384C:  MOVLW  01
384E:  MOVWF  00
3850:  MOVLB  0
3852:  MOVF   x88,W
3854:  MOVWF  01
3856:  BZ    3860
3858:  BCF    FD8.0
385A:  RLCF   00,F
385C:  DECFSZ 01,F
385E:  BRA    3858
3860:  MOVF   00,W
3862:  ANDWF  x91,W
3864:  BZ    38A8
....................           led_data[row1] |= ((long)1 << i1); 
3866:  BCF    FD8.0
3868:  MOVLB  2
386A:  RLCF   x7E,W
386C:  CLRF   03
386E:  ADDLW  93
3870:  MOVWF  FE9
3872:  MOVLW  00
3874:  ADDWFC 03,W
3876:  MOVWF  FEA
3878:  CLRF   03
387A:  MOVLW  01
387C:  MOVWF  02
387E:  MOVF   x7F,W
3880:  MOVWF  00
3882:  BZ    388E
3884:  BCF    FD8.0
3886:  RLCF   02,F
3888:  RLCF   03,F
388A:  DECFSZ 00,F
388C:  BRA    3884
388E:  MOVF   02,W
3890:  IORWF  FEF,W
3892:  MOVWF  00
3894:  MOVF   03,W
3896:  IORWF  FEC,W
3898:  MOVWF  03
389A:  MOVF   00,W
389C:  MOVF   FED,F
389E:  MOVWF  FEF
38A0:  MOVFF  03,FEC
....................         else 
38A4:  BRA    38F2
38A6:  MOVLB  0
....................           led_data[row1] &= ~((long)1 << i1); 
38A8:  BCF    FD8.0
38AA:  MOVLB  2
38AC:  RLCF   x7E,W
38AE:  CLRF   03
38B0:  ADDLW  93
38B2:  MOVWF  FE9
38B4:  MOVLW  00
38B6:  ADDWFC 03,W
38B8:  MOVWF  FEA
38BA:  CLRF   03
38BC:  MOVLW  01
38BE:  MOVWF  02
38C0:  MOVF   x7F,W
38C2:  MOVWF  00
38C4:  BZ    38D0
38C6:  BCF    FD8.0
38C8:  RLCF   02,F
38CA:  RLCF   03,F
38CC:  DECFSZ 00,F
38CE:  BRA    38C6
38D0:  MOVF   02,W
38D2:  CLRF   00
38D4:  DECF   00,F
38D6:  XORWF  00,F
38D8:  MOVLW  FF
38DA:  XORWF  03,F
38DC:  MOVF   00,W
38DE:  ANDWF  FEF,W
38E0:  MOVWF  00
38E2:  MOVF   03,W
38E4:  ANDWF  FEC,W
38E6:  MOVWF  03
38E8:  MOVF   00,W
38EA:  MOVF   FED,F
38EC:  MOVWF  FEF
38EE:  MOVFF  03,FEC
....................          
....................         sendSpiLED2(row1 + 1, led_data[row1], 0, 0); 
38F2:  MOVLW  01
38F4:  ADDWF  x7E,W
38F6:  MOVWF  x84
38F8:  BCF    FD8.0
38FA:  RLCF   x7E,W
38FC:  CLRF   03
38FE:  ADDLW  93
3900:  MOVWF  FE9
3902:  MOVLW  00
3904:  ADDWFC 03,W
3906:  MOVWF  FEA
3908:  MOVFF  FEC,286
390C:  MOVF   FED,F
390E:  MOVFF  FEF,285
3912:  MOVFF  284,287
3916:  MOVFF  285,288
391A:  CLRF   x89
391C:  CLRF   x8A
391E:  MOVLB  0
3920:  CALL   2896
....................       } 
3924:  INCF   x88,F
3926:  BRA    3836
....................       lsb1 = (int)(data >> 8); 
3928:  MOVLB  2
392A:  MOVF   x7D,W
392C:  MOVLB  0
392E:  MOVWF  x92
....................       sendSpiLED2(0, 0, row + 1, lsb1); 
3930:  MOVLW  01
3932:  MOVLB  2
3934:  ADDWF  x7B,W
3936:  MOVWF  x84
3938:  CLRF   x87
393A:  CLRF   x88
393C:  MOVWF  x89
393E:  MOVFF  92,28A
3942:  MOVLB  0
3944:  CALL   2896
.................... #endif//sy 
....................     } 
....................     else if(string[0] == 'a' && string[1] == 'e') // adc_enable 
3948:  BRA    3B4A
394A:  MOVF   xA4,W
394C:  SUBLW  61
394E:  BNZ   39DE
3950:  MOVF   xA5,W
3952:  SUBLW  65
3954:  BNZ   39DE
....................     { 
....................       int pin, state; 
....................       ch = strtok(string, space); 
3956:  MOVLB  2
3958:  CLRF   x85
395A:  MOVLW  A4
395C:  MOVWF  x84
395E:  CLRF   x87
3960:  MOVLW  B3
3962:  MOVWF  x86
3964:  MOVLB  0
3966:  CALL   2DC2
396A:  MOVFF  02,8B
396E:  MOVFF  01,8A
....................       ch = strtok(0, space); 
3972:  MOVLB  2
3974:  CLRF   x85
3976:  CLRF   x84
3978:  CLRF   x87
397A:  MOVLW  B3
397C:  MOVWF  x86
397E:  MOVLB  0
3980:  CALL   2DC2
3984:  MOVFF  02,8B
3988:  MOVFF  01,8A
....................       pin = atoi(ch); 
398C:  MOVFF  8B,285
3990:  MOVFF  8A,284
3994:  CALL   2EC2
3998:  MOVFF  01,280
....................       ch = strtok(0, space); 
399C:  MOVLB  2
399E:  CLRF   x85
39A0:  CLRF   x84
39A2:  CLRF   x87
39A4:  MOVLW  B3
39A6:  MOVWF  x86
39A8:  MOVLB  0
39AA:  CALL   2DC2
39AE:  MOVFF  02,8B
39B2:  MOVFF  01,8A
....................       state = atoi(ch); 
39B6:  MOVFF  8B,285
39BA:  MOVFF  8A,284
39BE:  CALL   2EC2
39C2:  MOVFF  01,281
....................       if(state) 
39C6:  MOVLB  2
39C8:  MOVF   x81,F
39CA:  BZ    39D4
....................         enableAdc(pin); 
39CC:  MOVFF  280,284
39D0:  MOVLB  0
39D2:  BRA    327A
....................       else 
....................         disableAdc(pin); 
39D4:  MOVFF  280,284
39D8:  MOVLB  0
39DA:  BRA    32B6
....................     } 
....................     //sy else if(!strcmp(ch, p)) // pwm 
.................... /* 
....................     else if(string[0] == 'p' && string[1] == 'w' && string[2] == 'm') 
....................     { 
....................       int prescale, period; 
....................       float duty; 
....................       ch = strtok(string, space); 
....................       ch = strtok(0, space); 
....................       prescale = atoi(ch); 
....................       ch = strtok(0, space); 
....................       period = atoi(ch); 
....................       ch = strtok(0, space); 
....................       duty = atof(ch); 
....................       if(prescale == 1) 
....................         setup_timer_2(T2_DIV_BY_1, period, 1); 
....................       else if(prescale == 4) 
....................         setup_timer_2(T2_DIV_BY_4, period, 1); 
....................       else if(prescale == 16) 
....................         setup_timer_2(T2_DIV_BY_16, period, 1); 
....................       set_pwm1_duty((long)(1024.0 * duty)); 
....................     } 
.................... */ 
.................... /*sy 
....................     else if(!strcmp(ch, o)) // output 
....................     { 
....................       int pin, state; 
....................       ch = strtok(0, space); 
....................       pin = atoi(ch); 
....................       ch = strtok(0, space); 
....................       state = atoi(ch); 
....................       if(pin == 0) 
....................         output_bit(PIN_B4, state); 
....................       else if(pin == 1) 
....................         output_bit(PIN_B0, state); 
....................     } 
.................... */ 
....................     else if(string[0] == 'i') // intensity 
39DC:  BRA    3B4A
39DE:  MOVF   xA4,W
39E0:  SUBLW  69
39E2:  BNZ   3A58
....................     { 
....................       ch = strtok(string, space); 
39E4:  MOVLB  2
39E6:  CLRF   x85
39E8:  MOVLW  A4
39EA:  MOVWF  x84
39EC:  CLRF   x87
39EE:  MOVLW  B3
39F0:  MOVWF  x86
39F2:  MOVLB  0
39F4:  CALL   2DC2
39F8:  MOVFF  02,8B
39FC:  MOVFF  01,8A
....................       ch = strtok(0, space); 
3A00:  MOVLB  2
3A02:  CLRF   x85
3A04:  CLRF   x84
3A06:  CLRF   x87
3A08:  MOVLW  B3
3A0A:  MOVWF  x86
3A0C:  MOVLB  0
3A0E:  CALL   2DC2
3A12:  MOVFF  02,8B
3A16:  MOVFF  01,8A
....................       para.intensity = atoi(ch); 
3A1A:  MOVFF  8B,285
3A1E:  MOVFF  8A,284
3A22:  CALL   2EC2
3A26:  MOVFF  01,276
.................... #ifndef ONE_TWENTY_EIGHT//for sixty four 
....................       sendSpiLED(0x0A, para.intensity); 
.................... #else//for one twenty eight 
....................       sendSpiLED2(0x0A, para.intensity, 0x0A, para.intensity); 
3A2A:  MOVLW  0A
3A2C:  MOVLB  2
3A2E:  MOVWF  x87
3A30:  MOVFF  276,288
3A34:  MOVWF  x89
3A36:  MOVFF  276,28A
3A3A:  MOVLB  0
3A3C:  CALL   2896
.................... #endif 
....................       putParaToEeprom(&para, sizeof(para), 0); 
3A40:  MOVLW  02
3A42:  MOVLB  2
3A44:  MOVWF  x85
3A46:  MOVLW  76
3A48:  MOVWF  x84
3A4A:  MOVLW  01
3A4C:  MOVWF  x86
3A4E:  CLRF   x87
3A50:  MOVLB  0
3A52:  CALL   276A
....................     } 
....................     else if(string[0] == 't') // test 
3A56:  BRA    3B4A
3A58:  MOVF   xA4,W
3A5A:  SUBLW  74
3A5C:  BNZ   3ABC
....................     { 
....................       int state; 
....................       ch = strtok(string, space); 
3A5E:  MOVLB  2
3A60:  CLRF   x85
3A62:  MOVLW  A4
3A64:  MOVWF  x84
3A66:  CLRF   x87
3A68:  MOVLW  B3
3A6A:  MOVWF  x86
3A6C:  MOVLB  0
3A6E:  CALL   2DC2
3A72:  MOVFF  02,8B
3A76:  MOVFF  01,8A
....................       ch = strtok(0, space); 
3A7A:  MOVLB  2
3A7C:  CLRF   x85
3A7E:  CLRF   x84
3A80:  CLRF   x87
3A82:  MOVLW  B3
3A84:  MOVWF  x86
3A86:  MOVLB  0
3A88:  CALL   2DC2
3A8C:  MOVFF  02,8B
3A90:  MOVFF  01,8A
....................       state = atoi(ch); 
3A94:  MOVFF  8B,285
3A98:  MOVFF  8A,284
3A9C:  CALL   2EC2
3AA0:  MOVFF  01,282
.................... #ifndef ONE_TWENTY_EIGHT//for sixty four 
....................       sendSpiLED(15, state); 
.................... #else//for one twenty eight 
....................       sendSpiLED2(15, state, 15, state); 
3AA4:  MOVLW  0F
3AA6:  MOVLB  2
3AA8:  MOVWF  x87
3AAA:  MOVFF  282,288
3AAE:  MOVWF  x89
3AB0:  MOVFF  282,28A
3AB4:  MOVLB  0
3AB6:  CALL   2896
.................... #endif//sy 
....................     } 
....................     else if(string[0] == 's') // shutdown 
3ABA:  BRA    3B4A
3ABC:  MOVF   xA4,W
3ABE:  SUBLW  73
3AC0:  BNZ   3B20
....................     { 
....................       int state; 
....................       ch = strtok(string, space); 
3AC2:  MOVLB  2
3AC4:  CLRF   x85
3AC6:  MOVLW  A4
3AC8:  MOVWF  x84
3ACA:  CLRF   x87
3ACC:  MOVLW  B3
3ACE:  MOVWF  x86
3AD0:  MOVLB  0
3AD2:  CALL   2DC2
3AD6:  MOVFF  02,8B
3ADA:  MOVFF  01,8A
....................       ch = strtok(0, space); 
3ADE:  MOVLB  2
3AE0:  CLRF   x85
3AE2:  CLRF   x84
3AE4:  CLRF   x87
3AE6:  MOVLW  B3
3AE8:  MOVWF  x86
3AEA:  MOVLB  0
3AEC:  CALL   2DC2
3AF0:  MOVFF  02,8B
3AF4:  MOVFF  01,8A
....................       state = atoi(ch); 
3AF8:  MOVFF  8B,285
3AFC:  MOVFF  8A,284
3B00:  CALL   2EC2
3B04:  MOVFF  01,283
.................... #ifndef ONE_TWENTY_EIGHT//for sixty four 
....................       sendSpiLED(12, state); 
.................... #else//for one twenty eight 
....................       sendSpiLED2(12, state, 12, state); 
3B08:  MOVLW  0C
3B0A:  MOVLB  2
3B0C:  MOVWF  x87
3B0E:  MOVFF  283,288
3B12:  MOVWF  x89
3B14:  MOVFF  283,28A
3B18:  MOVLB  0
3B1A:  CALL   2896
.................... #endif 
....................     } 
....................     else if(string[0] == 'f') // firmware 
3B1E:  BRA    3B4A
3B20:  MOVF   xA4,W
3B22:  SUBLW  66
3B24:  BNZ   3B4A
....................     { 
....................       usb_cdc_putc('f'); 
3B26:  MOVLW  66
3B28:  MOVLB  2
3B2A:  MOVWF  x84
3B2C:  MOVLB  0
3B2E:  RCALL  333C
....................       usb_cdc_putc(10); 
3B30:  MOVLW  0A
3B32:  MOVLB  2
3B34:  MOVWF  x84
3B36:  MOVLB  0
3B38:  RCALL  333C
....................       delay_cycles(1); 
3B3A:  NOP   
....................       usb_cdc_putc(24); 
3B3C:  MOVLW  18
3B3E:  MOVLB  2
3B40:  MOVWF  x84
3B42:  MOVLB  0
3B44:  CALL   333C
....................       delay_cycles(1); 
3B48:  NOP   
....................     } 
....................   } 
.................... } 
3B4A:  GOTO   446E (RETURN)
....................  
.................... /***********************************/ 
.................... /*                                 */ 
.................... /*  Functions for Button Handling  */ 
.................... /*                                 */ 
.................... /***********************************/ 
.................... void buttonInit(void) 
.................... { 
....................   for(i = 0; i < 8; i++) 
*
27DC:  CLRF   x88
27DE:  MOVF   x88,W
27E0:  SUBLW  07
27E2:  BNC   2868
....................   { 
....................     btnCurrent[i] = 0x00; 
27E4:  BCF    FD8.0
27E6:  RLCF   x88,W
27E8:  CLRF   03
27EA:  ADDLW  B6
27EC:  MOVWF  FE9
27EE:  MOVLW  00
27F0:  ADDWFC 03,W
27F2:  MOVWF  FEA
27F4:  CLRF   FEC
27F6:  MOVF   FED,F
27F8:  CLRF   FEF
....................     btnLast[i] = 0x00; 
27FA:  BCF    FD8.0
27FC:  RLCF   x88,W
27FE:  CLRF   03
2800:  ADDLW  C6
2802:  MOVWF  FE9
2804:  MOVLW  00
2806:  ADDWFC 03,W
2808:  MOVWF  FEA
280A:  CLRF   FEC
280C:  MOVF   FED,F
280E:  CLRF   FEF
....................     btnState[i] = 0x00; 
2810:  BCF    FD8.0
2812:  RLCF   x88,W
2814:  CLRF   03
2816:  ADDLW  D6
2818:  MOVWF  FE9
281A:  MOVLW  00
281C:  ADDWFC 03,W
281E:  MOVWF  FEA
2820:  CLRF   FEC
2822:  MOVF   FED,F
2824:  CLRF   FEF
....................  
.................... #ifndef ONE_TWENTY_EIGHT//for sixty four 
....................     for(j = 0; j < 8; j++) 
.................... #else//for one twenty eight 
....................     for(j = 0; j < 16; j++) 
2826:  CLRF   x89
2828:  MOVF   x89,W
282A:  SUBLW  0F
282C:  BNC   2864
.................... #endif 
....................       btnDebounceCount[i][j] = 0; 
282E:  MOVF   x88,W
2830:  MULLW  20
2832:  MOVF   FF3,W
2834:  MOVLB  2
2836:  CLRF   x78
2838:  MOVWF  x77
283A:  BCF    FD8.0
283C:  MOVLB  0
283E:  RLCF   x89,W
2840:  CLRF   03
2842:  MOVLB  2
2844:  ADDWF  x77,W
2846:  MOVWF  01
2848:  MOVF   x78,W
284A:  ADDWFC 03,F
284C:  MOVF   01,W
284E:  ADDLW  E6
2850:  MOVWF  FE9
2852:  MOVLW  00
2854:  ADDWFC 03,W
2856:  MOVWF  FEA
2858:  CLRF   FEC
285A:  MOVF   FED,F
285C:  CLRF   FEF
285E:  MOVLB  0
2860:  INCF   x89,F
2862:  BRA    2828
....................   } 
2864:  INCF   x88,F
2866:  BRA    27DE
.................... } 
2868:  GOTO   441E (RETURN)
....................  
.................... short buttonCheck(int row, int index) 
.................... { 
....................   flag = FALSE; 
*
3B4E:  BCF    x81.2
....................  
.................... #ifndef ONE_TWENTY_EIGHT//for sixty four 
....................   if(((btnCurrent[row] ^ btnLast[row]) & (1 << index)) && ((btnCurrent[row] ^ btnState[row]) & (1 << index))) 
....................     btnDebounceCount[row][index] = 0; 
....................   else if (((btnCurrent[row] ^ btnLast[row]) & (1 << index)) == 0 && ((btnCurrent[row] ^ btnState[row]) & (1 << index))) 
....................   { 
....................     if(btnDebounceCount[row][index] < 4 && ++btnDebounceCount[row][index] == 4) 
....................     { 
....................       if(btnCurrent[row] & (1 << index)) 
....................         btnState[row] |= (1 << index); 
....................       else 
....................         btnState[row] &= ~(1 << index); 
....................       flag = TRUE; 
....................     } 
....................   } 
.................... #else//for one twenty eight 
....................   if(((btnCurrent[row] ^ btnLast[row]) & ((long)1 << index)) && ((btnCurrent[row] ^ btnState[row]) & ((long)1 << index))) 
3B50:  BCF    FD8.0
3B52:  MOVLB  2
3B54:  RLCF   x77,W
3B56:  CLRF   03
3B58:  ADDLW  B6
3B5A:  MOVWF  FE9
3B5C:  MOVLW  00
3B5E:  ADDWFC 03,W
3B60:  MOVWF  FEA
3B62:  MOVFF  FEC,27A
3B66:  MOVF   FED,F
3B68:  MOVFF  FEF,279
3B6C:  BCF    FD8.0
3B6E:  RLCF   x77,W
3B70:  CLRF   03
3B72:  ADDLW  C6
3B74:  MOVWF  FE9
3B76:  MOVLW  00
3B78:  ADDWFC 03,W
3B7A:  MOVWF  FEA
3B7C:  MOVFF  FEC,03
3B80:  MOVF   FED,F
3B82:  MOVF   FEF,W
3B84:  XORWF  x79,F
3B86:  MOVF   03,W
3B88:  XORWF  x7A,F
3B8A:  CLRF   03
3B8C:  MOVLW  01
3B8E:  MOVWF  02
3B90:  MOVF   x78,W
3B92:  MOVWF  00
3B94:  BZ    3BA0
3B96:  BCF    FD8.0
3B98:  RLCF   02,F
3B9A:  RLCF   03,F
3B9C:  DECFSZ 00,F
3B9E:  BRA    3B96
3BA0:  MOVF   02,W
3BA2:  ANDWF  x79,W
3BA4:  MOVWF  00
3BA6:  MOVF   03,W
3BA8:  ANDWF  x7A,W
3BAA:  MOVWF  03
3BAC:  MOVF   00,W
3BAE:  IORWF  03,W
3BB0:  BZ    3C3E
3BB2:  BCF    FD8.0
3BB4:  RLCF   x77,W
3BB6:  CLRF   03
3BB8:  ADDLW  B6
3BBA:  MOVWF  FE9
3BBC:  MOVLW  00
3BBE:  ADDWFC 03,W
3BC0:  MOVWF  FEA
3BC2:  MOVFF  FEC,27A
3BC6:  MOVF   FED,F
3BC8:  MOVFF  FEF,279
3BCC:  BCF    FD8.0
3BCE:  RLCF   x77,W
3BD0:  CLRF   03
3BD2:  ADDLW  D6
3BD4:  MOVWF  FE9
3BD6:  MOVLW  00
3BD8:  ADDWFC 03,W
3BDA:  MOVWF  FEA
3BDC:  MOVFF  FEC,03
3BE0:  MOVF   FED,F
3BE2:  MOVF   FEF,W
3BE4:  XORWF  x79,F
3BE6:  MOVF   03,W
3BE8:  XORWF  x7A,F
3BEA:  CLRF   03
3BEC:  MOVLW  01
3BEE:  MOVWF  02
3BF0:  MOVF   x78,W
3BF2:  MOVWF  00
3BF4:  BZ    3C00
3BF6:  BCF    FD8.0
3BF8:  RLCF   02,F
3BFA:  RLCF   03,F
3BFC:  DECFSZ 00,F
3BFE:  BRA    3BF6
3C00:  MOVF   02,W
3C02:  ANDWF  x79,W
3C04:  MOVWF  00
3C06:  MOVF   03,W
3C08:  ANDWF  x7A,W
3C0A:  MOVWF  03
3C0C:  MOVF   00,W
3C0E:  IORWF  03,W
3C10:  BZ    3C3E
....................     btnDebounceCount[row][index] = 0; 
3C12:  MOVF   x77,W
3C14:  MULLW  20
3C16:  MOVF   FF3,W
3C18:  CLRF   x7A
3C1A:  MOVWF  x79
3C1C:  BCF    FD8.0
3C1E:  RLCF   x78,W
3C20:  CLRF   03
3C22:  ADDWF  x79,W
3C24:  MOVWF  01
3C26:  MOVF   x7A,W
3C28:  ADDWFC 03,F
3C2A:  MOVF   01,W
3C2C:  ADDLW  E6
3C2E:  MOVWF  FE9
3C30:  MOVLW  00
3C32:  ADDWFC 03,W
3C34:  MOVWF  FEA
3C36:  CLRF   FEC
3C38:  MOVF   FED,F
3C3A:  CLRF   FEF
....................   else if (((btnCurrent[row] ^ btnLast[row]) & ((long)1 << index)) == 0 && ((btnCurrent[row] ^ btnState[row]) & ((long)1 << index))) 
3C3C:  BRA    3E4E
3C3E:  BCF    FD8.0
3C40:  RLCF   x77,W
3C42:  CLRF   03
3C44:  ADDLW  B6
3C46:  MOVWF  FE9
3C48:  MOVLW  00
3C4A:  ADDWFC 03,W
3C4C:  MOVWF  FEA
3C4E:  MOVFF  FEC,27A
3C52:  MOVF   FED,F
3C54:  MOVFF  FEF,279
3C58:  BCF    FD8.0
3C5A:  RLCF   x77,W
3C5C:  CLRF   03
3C5E:  ADDLW  C6
3C60:  MOVWF  FE9
3C62:  MOVLW  00
3C64:  ADDWFC 03,W
3C66:  MOVWF  FEA
3C68:  MOVFF  FEC,03
3C6C:  MOVF   FED,F
3C6E:  MOVF   FEF,W
3C70:  XORWF  x79,F
3C72:  MOVF   03,W
3C74:  XORWF  x7A,F
3C76:  CLRF   03
3C78:  MOVLW  01
3C7A:  MOVWF  02
3C7C:  MOVF   x78,W
3C7E:  MOVWF  00
3C80:  BZ    3C8C
3C82:  BCF    FD8.0
3C84:  RLCF   02,F
3C86:  RLCF   03,F
3C88:  DECFSZ 00,F
3C8A:  BRA    3C82
3C8C:  MOVF   02,W
3C8E:  ANDWF  x79,F
3C90:  MOVF   03,W
3C92:  ANDWF  x7A,F
3C94:  MOVF   x79,F
3C96:  BTFSS  FD8.2
3C98:  BRA    3E4E
3C9A:  MOVF   x7A,F
3C9C:  BTFSS  FD8.2
3C9E:  BRA    3E4E
3CA0:  BCF    FD8.0
3CA2:  RLCF   x77,W
3CA4:  CLRF   03
3CA6:  ADDLW  B6
3CA8:  MOVWF  FE9
3CAA:  MOVLW  00
3CAC:  ADDWFC 03,W
3CAE:  MOVWF  FEA
3CB0:  MOVFF  FEC,27A
3CB4:  MOVF   FED,F
3CB6:  MOVFF  FEF,279
3CBA:  BCF    FD8.0
3CBC:  RLCF   x77,W
3CBE:  CLRF   03
3CC0:  ADDLW  D6
3CC2:  MOVWF  FE9
3CC4:  MOVLW  00
3CC6:  ADDWFC 03,W
3CC8:  MOVWF  FEA
3CCA:  MOVFF  FEC,03
3CCE:  MOVF   FED,F
3CD0:  MOVF   FEF,W
3CD2:  XORWF  x79,F
3CD4:  MOVF   03,W
3CD6:  XORWF  x7A,F
3CD8:  CLRF   03
3CDA:  MOVLW  01
3CDC:  MOVWF  02
3CDE:  MOVF   x78,W
3CE0:  MOVWF  00
3CE2:  BZ    3CEE
3CE4:  BCF    FD8.0
3CE6:  RLCF   02,F
3CE8:  RLCF   03,F
3CEA:  DECFSZ 00,F
3CEC:  BRA    3CE4
3CEE:  MOVF   02,W
3CF0:  ANDWF  x79,W
3CF2:  MOVWF  00
3CF4:  MOVF   03,W
3CF6:  ANDWF  x7A,W
3CF8:  MOVWF  03
3CFA:  MOVF   00,W
3CFC:  IORWF  03,W
3CFE:  BTFSC  FD8.2
3D00:  BRA    3E4E
....................   { 
....................     if(btnDebounceCount[row][index] < 4 && ++btnDebounceCount[row][index] == 4) 
3D02:  MOVF   x77,W
3D04:  MULLW  20
3D06:  MOVF   FF3,W
3D08:  CLRF   x7A
3D0A:  MOVWF  x79
3D0C:  BCF    FD8.0
3D0E:  RLCF   x78,W
3D10:  CLRF   03
3D12:  ADDWF  x79,W
3D14:  MOVWF  01
3D16:  MOVF   x7A,W
3D18:  ADDWFC 03,F
3D1A:  MOVF   01,W
3D1C:  ADDLW  E6
3D1E:  MOVWF  FE9
3D20:  MOVLW  00
3D22:  ADDWFC 03,W
3D24:  MOVWF  FEA
3D26:  MOVFF  FEC,27A
3D2A:  MOVF   FED,F
3D2C:  MOVFF  FEF,279
3D30:  MOVF   x7A,F
3D32:  BTFSS  FD8.2
3D34:  BRA    3E4E
3D36:  MOVF   x79,W
3D38:  SUBLW  03
3D3A:  BTFSS  FD8.0
3D3C:  BRA    3E4E
3D3E:  MOVF   x77,W
3D40:  MULLW  20
3D42:  MOVF   FF3,W
3D44:  CLRF   x7A
3D46:  MOVWF  x79
3D48:  BCF    FD8.0
3D4A:  RLCF   x78,W
3D4C:  CLRF   03
3D4E:  ADDWF  x79,W
3D50:  MOVWF  01
3D52:  MOVF   x7A,W
3D54:  ADDWFC 03,F
3D56:  MOVF   01,W
3D58:  ADDLW  E6
3D5A:  MOVWF  FE9
3D5C:  MOVLW  00
3D5E:  ADDWFC 03,W
3D60:  MOVWF  FEA
3D62:  MOVLW  01
3D64:  ADDWF  FEE,F
3D66:  BNC   3D6A
3D68:  INCF   FEF,F
3D6A:  MOVF   FED,F
3D6C:  MOVFF  FEC,27A
3D70:  MOVF   FED,F
3D72:  MOVFF  FEF,279
3D76:  MOVF   x79,W
3D78:  SUBLW  04
3D7A:  BNZ   3E4E
3D7C:  MOVF   x7A,F
3D7E:  BNZ   3E4E
....................     { 
....................       if(btnCurrent[row] & ((long)1 << index)) 
3D80:  BCF    FD8.0
3D82:  RLCF   x77,W
3D84:  CLRF   03
3D86:  ADDLW  B6
3D88:  MOVWF  FE9
3D8A:  MOVLW  00
3D8C:  ADDWFC 03,W
3D8E:  MOVWF  FEA
3D90:  MOVFF  FEC,27A
3D94:  MOVF   FED,F
3D96:  MOVFF  FEF,279
3D9A:  CLRF   03
3D9C:  MOVLW  01
3D9E:  MOVWF  02
3DA0:  MOVF   x78,W
3DA2:  MOVWF  00
3DA4:  BZ    3DB0
3DA6:  BCF    FD8.0
3DA8:  RLCF   02,F
3DAA:  RLCF   03,F
3DAC:  DECFSZ 00,F
3DAE:  BRA    3DA6
3DB0:  MOVF   02,W
3DB2:  ANDWF  x79,W
3DB4:  MOVWF  00
3DB6:  MOVF   03,W
3DB8:  ANDWF  x7A,W
3DBA:  MOVWF  03
3DBC:  MOVF   00,W
3DBE:  IORWF  03,W
3DC0:  BZ    3E00
....................         btnState[row] |= ((long)1 << index); 
3DC2:  BCF    FD8.0
3DC4:  RLCF   x77,W
3DC6:  CLRF   03
3DC8:  ADDLW  D6
3DCA:  MOVWF  FE9
3DCC:  MOVLW  00
3DCE:  ADDWFC 03,W
3DD0:  MOVWF  FEA
3DD2:  CLRF   03
3DD4:  MOVLW  01
3DD6:  MOVWF  02
3DD8:  MOVF   x78,W
3DDA:  MOVWF  00
3DDC:  BZ    3DE8
3DDE:  BCF    FD8.0
3DE0:  RLCF   02,F
3DE2:  RLCF   03,F
3DE4:  DECFSZ 00,F
3DE6:  BRA    3DDE
3DE8:  MOVF   02,W
3DEA:  IORWF  FEF,W
3DEC:  MOVWF  00
3DEE:  MOVF   03,W
3DF0:  IORWF  FEC,W
3DF2:  MOVWF  03
3DF4:  MOVF   00,W
3DF6:  MOVF   FED,F
3DF8:  MOVWF  FEF
3DFA:  MOVFF  03,FEC
....................       else 
3DFE:  BRA    3E48
....................         btnState[row] &= ~((long)1 << index); 
3E00:  BCF    FD8.0
3E02:  RLCF   x77,W
3E04:  CLRF   03
3E06:  ADDLW  D6
3E08:  MOVWF  FE9
3E0A:  MOVLW  00
3E0C:  ADDWFC 03,W
3E0E:  MOVWF  FEA
3E10:  CLRF   03
3E12:  MOVLW  01
3E14:  MOVWF  02
3E16:  MOVF   x78,W
3E18:  MOVWF  00
3E1A:  BZ    3E26
3E1C:  BCF    FD8.0
3E1E:  RLCF   02,F
3E20:  RLCF   03,F
3E22:  DECFSZ 00,F
3E24:  BRA    3E1C
3E26:  MOVF   02,W
3E28:  CLRF   00
3E2A:  DECF   00,F
3E2C:  XORWF  00,F
3E2E:  MOVLW  FF
3E30:  XORWF  03,F
3E32:  MOVF   00,W
3E34:  ANDWF  FEF,W
3E36:  MOVWF  00
3E38:  MOVF   03,W
3E3A:  ANDWF  FEC,W
3E3C:  MOVWF  03
3E3E:  MOVF   00,W
3E40:  MOVF   FED,F
3E42:  MOVWF  FEF
3E44:  MOVFF  03,FEC
....................       flag = TRUE; 
3E48:  MOVLB  0
3E4A:  BSF    x81.2
3E4C:  MOVLB  2
....................     } 
....................   } 
.................... #endif 
....................   return flag; 
3E4E:  MOVLW  00
3E50:  MOVLB  0
3E52:  BTFSC  x81.2
3E54:  MOVLW  01
3E56:  MOVWF  01
.................... } 
3E58:  GOTO   3F76 (RETURN)
....................  
.................... void sendOscMsgPress(void) 
.................... { 
....................   if(start_row == 0) 
3E5C:  MOVF   xB5,F
3E5E:  BNZ   3E64
....................     output_bit(SR_A, 0); 
3E60:  BCF    F8A.7
3E62:  BCF    F93.7
....................  
....................   for(i = start_row; i < start_row + 4; i++) 
3E64:  MOVFF  B5,88
3E68:  MOVLW  04
3E6A:  ADDWF  xB5,W
3E6C:  SUBWF  x88,W
3E6E:  BTFSC  FD8.0
3E70:  BRA    408C
....................   { 
....................     output_bit(SR_CLK, 1); 
3E72:  BSF    F8A.6
3E74:  BCF    F93.6
....................     output_bit(SR_CLK, 0); 
3E76:  BCF    F8A.6
3E78:  BCF    F93.6
....................  
....................     output_bit(SR_A, 1); 
3E7A:  BSF    F8A.7
3E7C:  BCF    F93.7
....................  
....................     btnLast[i] = btnCurrent[i]; 
3E7E:  BCF    FD8.0
3E80:  RLCF   x88,W
3E82:  CLRF   03
3E84:  ADDLW  C6
3E86:  MOVWF  01
3E88:  MOVLW  00
3E8A:  ADDWFC 03,F
3E8C:  MOVLB  2
3E8E:  MOVFF  03,278
3E92:  BCF    FD8.0
3E94:  MOVLB  0
3E96:  RLCF   x88,W
3E98:  CLRF   03
3E9A:  ADDLW  B6
3E9C:  MOVWF  FE9
3E9E:  MOVLW  00
3EA0:  ADDWFC 03,W
3EA2:  MOVWF  FEA
3EA4:  MOVFF  FEC,03
3EA8:  MOVF   FED,F
3EAA:  MOVFF  FEF,279
3EAE:  MOVLB  2
3EB0:  MOVFF  278,FEA
3EB4:  MOVFF  01,FE9
3EB8:  MOVFF  03,FEC
3EBC:  MOVF   FED,F
3EBE:  MOVFF  279,FEF
....................  
....................     output_bit(SR_SL, 0); 
3EC2:  BCF    F8B.1
3EC4:  BCF    F94.1
....................     delay_us(5); 
3EC6:  MOVLW  13
3EC8:  MOVWF  00
3ECA:  DECFSZ 00,F
3ECC:  BRA    3ECA
3ECE:  BRA    3ED0
....................     output_bit(SR_SL, 1); 
3ED0:  BSF    F8B.1
3ED2:  BCF    F94.1
....................  
.................... #ifndef ONE_TWENTY_EIGHT//for sixty four 
....................     for(j = 0; j < 8; j++) 
.................... #else//for one twenty eight 
....................     for(j = 0; j < 16; j++) 
3ED4:  MOVLB  0
3ED6:  CLRF   x89
3ED8:  MOVF   x89,W
3EDA:  SUBLW  0F
3EDC:  BTFSS  FD8.0
3EDE:  BRA    4088
.................... #endif 
....................     { 
....................       if(input(SR_QH)) 
3EE0:  BSF    F94.6
3EE2:  BTFSS  F82.6
3EE4:  BRA    3F30
....................         btnCurrent[i] &= ~((long)1 << j); 
3EE6:  BCF    FD8.0
3EE8:  RLCF   x88,W
3EEA:  CLRF   03
3EEC:  ADDLW  B6
3EEE:  MOVWF  FE9
3EF0:  MOVLW  00
3EF2:  ADDWFC 03,W
3EF4:  MOVWF  FEA
3EF6:  CLRF   03
3EF8:  MOVLW  01
3EFA:  MOVWF  02
3EFC:  MOVF   x89,W
3EFE:  MOVWF  00
3F00:  BZ    3F0C
3F02:  BCF    FD8.0
3F04:  RLCF   02,F
3F06:  RLCF   03,F
3F08:  DECFSZ 00,F
3F0A:  BRA    3F02
3F0C:  MOVF   02,W
3F0E:  CLRF   00
3F10:  DECF   00,F
3F12:  XORWF  00,F
3F14:  MOVLW  FF
3F16:  XORWF  03,F
3F18:  MOVF   00,W
3F1A:  ANDWF  FEF,W
3F1C:  MOVWF  00
3F1E:  MOVF   03,W
3F20:  ANDWF  FEC,W
3F22:  MOVWF  03
3F24:  MOVF   00,W
3F26:  MOVF   FED,F
3F28:  MOVWF  FEF
3F2A:  MOVFF  03,FEC
....................       else 
3F2E:  BRA    3F6C
....................         btnCurrent[i] |= ((long)1 << j); 
3F30:  BCF    FD8.0
3F32:  RLCF   x88,W
3F34:  CLRF   03
3F36:  ADDLW  B6
3F38:  MOVWF  FE9
3F3A:  MOVLW  00
3F3C:  ADDWFC 03,W
3F3E:  MOVWF  FEA
3F40:  CLRF   03
3F42:  MOVLW  01
3F44:  MOVWF  02
3F46:  MOVF   x89,W
3F48:  MOVWF  00
3F4A:  BZ    3F56
3F4C:  BCF    FD8.0
3F4E:  RLCF   02,F
3F50:  RLCF   03,F
3F52:  DECFSZ 00,F
3F54:  BRA    3F4C
3F56:  MOVF   02,W
3F58:  IORWF  FEF,W
3F5A:  MOVWF  00
3F5C:  MOVF   03,W
3F5E:  IORWF  FEC,W
3F60:  MOVWF  03
3F62:  MOVF   00,W
3F64:  MOVF   FED,F
3F66:  MOVWF  FEF
3F68:  MOVFF  03,FEC
....................  
....................       if(buttonCheck(i, j)) 
3F6C:  MOVFF  88,277
3F70:  MOVFF  89,278
3F74:  BRA    3B4E
3F76:  MOVF   01,F
3F78:  BTFSC  FD8.2
3F7A:  BRA    407C
....................       { 
.................... #ifdef ONE_TWENTY_EIGHT//for sixty four 
....................         if(j < 8) 
3F7C:  MOVF   x89,W
3F7E:  SUBLW  07
3F80:  BNC   4004
....................         { 
....................           if(btnState[i] & ((long)1 << j)) 
3F82:  BCF    FD8.0
3F84:  RLCF   x88,W
3F86:  CLRF   03
3F88:  ADDLW  D6
3F8A:  MOVWF  FE9
3F8C:  MOVLW  00
3F8E:  ADDWFC 03,W
3F90:  MOVWF  FEA
3F92:  MOVFF  FEC,278
3F96:  MOVF   FED,F
3F98:  MOVFF  FEF,277
3F9C:  CLRF   03
3F9E:  MOVLW  01
3FA0:  MOVWF  02
3FA2:  MOVF   x89,W
3FA4:  MOVWF  00
3FA6:  BZ    3FB2
3FA8:  BCF    FD8.0
3FAA:  RLCF   02,F
3FAC:  RLCF   03,F
3FAE:  DECFSZ 00,F
3FB0:  BRA    3FA8
3FB2:  MOVF   02,W
3FB4:  MOVLB  2
3FB6:  ANDWF  x77,W
3FB8:  MOVWF  00
3FBA:  MOVF   03,W
3FBC:  ANDWF  x78,W
3FBE:  MOVWF  03
3FC0:  MOVF   00,W
3FC2:  IORWF  03,W
3FC4:  BZ    3FD4
....................             usb_cdc_putc('p'); 
3FC6:  MOVLW  70
3FC8:  MOVWF  x84
3FCA:  MOVLB  0
3FCC:  CALL   333C
....................           else 
3FD0:  BRA    3FDE
3FD2:  MOVLB  2
....................             usb_cdc_putc('r'); 
3FD4:  MOVLW  72
3FD6:  MOVWF  x84
3FD8:  MOVLB  0
3FDA:  CALL   333C
....................           delay_cycles(1); 
3FDE:  NOP   
....................           usb_cdc_putc((j << 4) + (7 - i)); 
3FE0:  SWAPF  x89,W
3FE2:  MOVLB  2
3FE4:  MOVWF  x77
3FE6:  MOVLW  F0
3FE8:  ANDWF  x77,F
3FEA:  MOVLW  07
3FEC:  BSF    FD8.0
3FEE:  MOVLB  0
3FF0:  SUBFWB x88,W
3FF2:  MOVLB  2
3FF4:  ADDWF  x77,F
3FF6:  MOVFF  277,284
3FFA:  MOVLB  0
3FFC:  CALL   333C
....................           delay_cycles(1); 
4000:  NOP   
....................         } 
....................         else 
4002:  BRA    407C
.................... #endif 
....................         { 
....................           if(btnState[i] & ((long)1 << j)) 
4004:  BCF    FD8.0
4006:  RLCF   x88,W
4008:  CLRF   03
400A:  ADDLW  D6
400C:  MOVWF  FE9
400E:  MOVLW  00
4010:  ADDWFC 03,W
4012:  MOVWF  FEA
4014:  MOVFF  FEC,278
4018:  MOVF   FED,F
401A:  MOVFF  FEF,277
401E:  CLRF   03
4020:  MOVLW  01
4022:  MOVWF  02
4024:  MOVF   x89,W
4026:  MOVWF  00
4028:  BZ    4034
402A:  BCF    FD8.0
402C:  RLCF   02,F
402E:  RLCF   03,F
4030:  DECFSZ 00,F
4032:  BRA    402A
4034:  MOVF   02,W
4036:  MOVLB  2
4038:  ANDWF  x77,W
403A:  MOVWF  00
403C:  MOVF   03,W
403E:  ANDWF  x78,W
4040:  MOVWF  03
4042:  MOVF   00,W
4044:  IORWF  03,W
4046:  BZ    4056
....................             usb_cdc_putc('p'); 
4048:  MOVLW  70
404A:  MOVWF  x84
404C:  MOVLB  0
404E:  CALL   333C
....................           else 
4052:  BRA    4060
4054:  MOVLB  2
....................             usb_cdc_putc('r'); 
4056:  MOVLW  72
4058:  MOVWF  x84
405A:  MOVLB  0
405C:  CALL   333C
....................           delay_cycles(1); 
4060:  NOP   
....................           usb_cdc_putc((i << 4) + j); 
4062:  SWAPF  x88,W
4064:  MOVWF  00
4066:  MOVLW  F0
4068:  ANDWF  00,F
406A:  MOVF   00,W
406C:  ADDWF  x89,W
406E:  MOVLB  2
4070:  MOVWF  x77
4072:  MOVWF  x84
4074:  MOVLB  0
4076:  CALL   333C
....................           delay_cycles(1); 
407A:  NOP   
....................         } 
....................       } 
....................       output_bit(SR_CLK2, 1); 
407C:  BSF    F8B.0
407E:  BCF    F94.0
....................       output_bit(SR_CLK2, 0); 
4080:  BCF    F8B.0
4082:  BCF    F94.0
....................     } 
4084:  INCF   x89,F
4086:  BRA    3ED8
....................   } 
4088:  INCF   x88,F
408A:  BRA    3E68
....................   if(start_row == 0) 
408C:  MOVF   xB5,F
408E:  BNZ   4096
....................     start_row = 4; 
4090:  MOVLW  04
4092:  MOVWF  xB5
....................   else if(start_row == 4) 
4094:  BRA    409E
4096:  MOVF   xB5,W
4098:  SUBLW  04
409A:  BNZ   409E
....................     start_row = 0; 
409C:  CLRF   xB5
.................... } 
409E:  GOTO   4470 (RETURN)
....................  
.................... /***********************************/ 
.................... /*                                 */ 
.................... /*  Functions for A/D Conversion   */ 
.................... /*                                 */ 
.................... /***********************************/ 
.................... void enableAdc(int port) 
.................... { 
....................   if(port >= kAdcFilterNumAdcs) 
*
327A:  MOVLB  2
327C:  MOVF   x84,W
327E:  SUBLW  06
3280:  BC    3284
....................     return; 
3282:  BRA    32B0
....................  
....................   if((gAdcEnableState & 0x7F) == 0) 
3284:  MOVLB  1
3286:  MOVF   xE6,W
3288:  ANDLW  7F
328A:  BNZ   3292
....................     enableAdcFlag = TRUE; 
328C:  MOVLB  0
328E:  BSF    x81.3
3290:  MOVLB  1
....................  
....................   gAdcEnableState |= (1 << port); 
3292:  MOVLW  01
3294:  MOVWF  00
3296:  MOVLB  2
3298:  MOVF   x84,W
329A:  MOVWF  01
329C:  BZ    32A6
329E:  BCF    FD8.0
32A0:  RLCF   00,F
32A2:  DECFSZ 01,F
32A4:  BRA    329E
32A6:  MOVF   00,W
32A8:  MOVLB  1
32AA:  IORWF  xE6,F
....................   enableAdcNum++; 
32AC:  INCF   xE9,F
32AE:  MOVLB  2
.................... } 
32B0:  MOVLB  0
32B2:  GOTO   39DC (RETURN)
....................  
.................... void disableAdc(int port) 
.................... { 
....................   if(port >= kAdcFilterNumAdcs) 
32B6:  MOVLB  2
32B8:  MOVF   x84,W
32BA:  SUBLW  06
32BC:  BC    32C0
....................     return; 
32BE:  BRA    32EA
....................  
....................   gAdcEnableState &= ~(1 << port); 
32C0:  MOVLW  01
32C2:  MOVWF  00
32C4:  MOVF   x84,W
32C6:  MOVWF  01
32C8:  BZ    32D2
32CA:  BCF    FD8.0
32CC:  RLCF   00,F
32CE:  DECFSZ 01,F
32D0:  BRA    32CA
32D2:  MOVF   00,W
32D4:  XORLW  FF
32D6:  MOVLB  1
32D8:  ANDWF  xE6,F
....................  
....................   if((gAdcEnableState & 0x7F) == 0) 
32DA:  MOVF   xE6,W
32DC:  ANDLW  7F
32DE:  BNZ   32E6
....................     enableAdcFlag = FALSE; 
32E0:  MOVLB  0
32E2:  BCF    x81.3
32E4:  MOVLB  1
....................   enableAdcNum--; 
32E6:  DECF   xE9,F
32E8:  MOVLB  2
.................... } 
32EA:  MOVLB  0
32EC:  GOTO   39DC (RETURN)
....................  
.................... void sendOscMsgAdc(void) 
.................... { 
....................   if(enableAdcFlag) 
*
40A2:  BTFSS  x81.3
40A4:  BRA    42E6
....................   { 
....................     if(countAdc >= (8 * enableAdcNum)) 
40A6:  MOVLB  1
40A8:  MOVF   xE9,W
40AA:  MULLW  08
40AC:  MOVF   FF3,W
40AE:  SUBWF  xE7,W
40B0:  BTFSS  FD8.0
40B2:  BRA    42E4
....................     { 
....................       if((gAdcEnableState & (1 << loopAdc)) == (1 << loopAdc)) 
40B4:  MOVLW  01
40B6:  MOVWF  00
40B8:  MOVF   xE8,W
40BA:  MOVWF  01
40BC:  BZ    40C6
40BE:  BCF    FD8.0
40C0:  RLCF   00,F
40C2:  DECFSZ 01,F
40C4:  BRA    40BE
40C6:  MOVF   00,W
40C8:  ANDWF  xE6,W
40CA:  MOVLB  2
40CC:  MOVWF  x77
40CE:  MOVLW  01
40D0:  MOVWF  00
40D2:  MOVLB  1
40D4:  MOVF   xE8,W
40D6:  MOVWF  01
40D8:  BZ    40E2
40DA:  BCF    FD8.0
40DC:  RLCF   00,F
40DE:  DECFSZ 01,F
40E0:  BRA    40DA
40E2:  MOVF   00,W
40E4:  MOVLB  2
40E6:  SUBWF  x77,W
40E8:  BTFSS  FD8.2
40EA:  BRA    42D6
....................       { 
....................         set_adc_channel(adc_id[loopAdc]); 
40EC:  CLRF   03
40EE:  MOVLB  1
40F0:  MOVF   xE8,W
40F2:  MOVFF  FF2,277
40F6:  BCF    FF2.7
40F8:  MOVLB  0
40FA:  CALL   1A14
40FE:  MOVLB  2
4100:  BTFSC  x77.7
4102:  BSF    FF2.7
4104:  MOVWF  x77
4106:  RLCF   x77,W
4108:  MOVWF  00
410A:  RLCF   00,F
410C:  MOVLW  FC
410E:  ANDWF  00,F
4110:  MOVF   FC2,W
4112:  ANDLW  C3
4114:  IORWF  00,W
4116:  MOVWF  FC2
....................         lvalue = read_adc(ADC_START_AND_READ); 
4118:  BSF    FC2.1
411A:  BTFSC  FC2.1
411C:  BRA    411A
411E:  MOVFF  FC4,1F2
4122:  MOVLB  1
4124:  MOVFF  FC3,1F1
....................         adc_total[loopAdc] += lvalue; 
4128:  BCF    FD8.0
412A:  RLCF   xE8,W
412C:  CLRF   03
412E:  ADDLW  F3
4130:  MOVWF  FE9
4132:  MOVLW  01
4134:  ADDWFC 03,W
4136:  MOVWF  FEA
4138:  MOVF   xF1,W
413A:  ADDWF  FEF,W
413C:  MOVWF  01
413E:  MOVF   xF2,W
4140:  ADDWFC FEC,W
4142:  MOVF   FED,F
4144:  MOVFF  01,FEF
4148:  MOVWF  FEC
....................         adc_total[loopAdc] -= adc_value[loopAdc][countAve[loopAdc]]; 
414A:  BCF    FD8.0
414C:  RLCF   xE8,W
414E:  CLRF   03
4150:  ADDLW  F3
4152:  MOVWF  01
4154:  MOVLW  01
4156:  ADDWFC 03,F
4158:  MOVFF  01,277
415C:  MOVLB  2
415E:  MOVFF  03,278
4162:  MOVFF  03,FEA
4166:  MOVFF  01,FE9
416A:  MOVFF  FEC,27A
416E:  MOVF   FED,F
4170:  MOVFF  FEF,279
4174:  MOVLB  1
4176:  MOVF   xE8,W
4178:  MULLW  10
417A:  MOVF   FF3,W
417C:  MOVLB  2
417E:  CLRF   x7C
4180:  MOVWF  x7B
4182:  CLRF   03
4184:  MOVLB  1
4186:  MOVF   xE8,W
4188:  ADDLW  EA
418A:  MOVWF  FE9
418C:  MOVLW  01
418E:  ADDWFC 03,W
4190:  MOVWF  FEA
4192:  BCF    FD8.0
4194:  RLCF   FEF,W
4196:  CLRF   03
4198:  MOVLB  2
419A:  ADDWF  x7B,W
419C:  MOVWF  01
419E:  MOVF   x7C,W
41A0:  ADDWFC 03,F
41A2:  MOVF   01,W
41A4:  ADDLW  01
41A6:  MOVWF  FE9
41A8:  MOVLW  02
41AA:  ADDWFC 03,W
41AC:  MOVWF  FEA
41AE:  MOVFF  FEC,03
41B2:  MOVF   FED,F
41B4:  MOVF   FEF,W
41B6:  SUBWF  x79,W
41B8:  MOVWF  00
41BA:  MOVF   03,W
41BC:  SUBWFB x7A,W
41BE:  MOVFF  278,FEA
41C2:  MOVFF  277,FE9
41C6:  MOVWF  FEC
41C8:  MOVF   FED,F
41CA:  MOVFF  00,FEF
....................         adc_value[loopAdc][countAve[loopAdc]] = lvalue; 
41CE:  MOVLB  1
41D0:  MOVF   xE8,W
41D2:  MULLW  10
41D4:  MOVF   FF3,W
41D6:  MOVLB  2
41D8:  CLRF   x78
41DA:  MOVWF  x77
41DC:  CLRF   03
41DE:  MOVLB  1
41E0:  MOVF   xE8,W
41E2:  ADDLW  EA
41E4:  MOVWF  FE9
41E6:  MOVLW  01
41E8:  ADDWFC 03,W
41EA:  MOVWF  FEA
41EC:  BCF    FD8.0
41EE:  RLCF   FEF,W
41F0:  CLRF   03
41F2:  MOVLB  2
41F4:  ADDWF  x77,W
41F6:  MOVWF  01
41F8:  MOVF   x78,W
41FA:  ADDWFC 03,F
41FC:  MOVF   01,W
41FE:  ADDLW  01
4200:  MOVWF  FE9
4202:  MOVLW  02
4204:  ADDWFC 03,W
4206:  MOVWF  FEA
4208:  MOVFF  1F2,FEC
420C:  MOVF   FED,F
420E:  MOVFF  1F1,FEF
....................         lvalue = adc_total[loopAdc] / 8; 
4212:  BCF    FD8.0
4214:  MOVLB  1
4216:  RLCF   xE8,W
4218:  CLRF   03
421A:  ADDLW  F3
421C:  MOVWF  FE9
421E:  MOVLW  01
4220:  ADDWFC 03,W
4222:  MOVWF  FEA
4224:  MOVFF  FEC,278
4228:  MOVF   FED,F
422A:  MOVFF  FEF,277
422E:  MOVLB  2
4230:  RRCF   x78,W
4232:  MOVLB  1
4234:  MOVWF  xF2
4236:  MOVLB  2
4238:  RRCF   x77,W
423A:  MOVLB  1
423C:  MOVWF  xF1
423E:  RRCF   xF2,F
4240:  RRCF   xF1,F
4242:  RRCF   xF2,F
4244:  RRCF   xF1,F
4246:  MOVLW  1F
4248:  ANDWF  xF2,F
....................  
....................         countAve[loopAdc]++; 
424A:  CLRF   03
424C:  MOVF   xE8,W
424E:  ADDLW  EA
4250:  MOVWF  FE9
4252:  MOVLW  01
4254:  ADDWFC 03,W
4256:  MOVWF  FEA
4258:  INCF   FEF,F
....................         if(countAve[loopAdc] == 8) 
425A:  CLRF   03
425C:  MOVF   xE8,W
425E:  ADDLW  EA
4260:  MOVWF  FE9
4262:  MOVLW  01
4264:  ADDWFC 03,W
4266:  MOVWF  FEA
4268:  MOVF   FEF,W
426A:  SUBLW  08
426C:  BNZ   427E
....................           countAve[loopAdc] = 0; 
426E:  CLRF   03
4270:  MOVF   xE8,W
4272:  ADDLW  EA
4274:  MOVWF  FE9
4276:  MOVLW  01
4278:  ADDWFC 03,W
427A:  MOVWF  FEA
427C:  CLRF   FEF
....................  
....................         usb_cdc_putc('a'); 
427E:  MOVLW  61
4280:  MOVLB  2
4282:  MOVWF  x84
4284:  MOVLB  0
4286:  CALL   333C
....................         delay_cycles(1); 
428A:  NOP   
....................         usb_cdc_putc((int)((loopAdc << 4) + ((lvalue & 0x0300) >> 8))); 
428C:  MOVLB  1
428E:  SWAPF  xE8,W
4290:  MOVLB  2
4292:  MOVWF  x77
4294:  MOVLW  F0
4296:  ANDWF  x77,F
4298:  CLRF   x78
429A:  MOVLB  1
429C:  MOVF   xF2,W
429E:  ANDLW  03
42A0:  MOVLB  2
42A2:  MOVWF  x79
42A4:  CLRF   03
42A6:  ADDWF  x77,W
42A8:  MOVWF  01
42AA:  MOVLW  00
42AC:  ADDWFC 03,F
42AE:  MOVFF  01,277
42B2:  MOVFF  01,284
42B6:  MOVLB  0
42B8:  CALL   333C
....................         delay_cycles(1); 
42BC:  NOP   
....................         usb_cdc_putc((int)(lvalue & 0x00FF)); 
42BE:  MOVLB  1
42C0:  MOVFF  1F1,00
42C4:  CLRF   03
42C6:  MOVFF  1F1,277
42CA:  MOVFF  1F1,284
42CE:  MOVLB  0
42D0:  CALL   333C
....................         delay_cycles(1); 
42D4:  NOP   
....................       } 
....................       loopAdc++; 
42D6:  MOVLB  1
42D8:  INCF   xE8,F
....................       if(loopAdc >= kAdcFilterNumAdcs) 
42DA:  MOVF   xE8,W
42DC:  SUBLW  06
42DE:  BC    42E2
....................         loopAdc = 0; 
42E0:  CLRF   xE8
....................  
....................       countAdc = 0; 
42E2:  CLRF   xE7
....................     } 
....................     countAdc++; 
42E4:  INCF   xE7,F
42E6:  MOVLB  0
....................   } 
.................... } 
42E8:  GOTO   4472 (RETURN)
....................  
.................... /**********************************/ 
.................... /*                                */ 
.................... /*  Functions for Input Handling  */ 
.................... /*                                */ 
.................... /**********************************/ 
.................... void inputInit(void) 
.................... { 
....................   inCurrent = 0x00; 
*
286C:  MOVLB  2
286E:  CLRF   x71
....................   inLast    = 0x00; 
2870:  CLRF   x72
....................   inState   = 0x00; 
2872:  CLRF   x73
....................  
....................   for(i = 0; i < 2; i++) 
2874:  MOVLB  0
2876:  CLRF   x88
2878:  MOVF   x88,W
287A:  SUBLW  01
287C:  BNC   2892
....................     inDebounceCount[i] = 0; 
287E:  CLRF   03
2880:  MOVF   x88,W
2882:  ADDLW  74
2884:  MOVWF  FE9
2886:  MOVLW  02
2888:  ADDWFC 03,W
288A:  MOVWF  FEA
288C:  CLRF   FEF
288E:  INCF   x88,F
2890:  BRA    2878
.................... } 
2892:  GOTO   4450 (RETURN)
....................  
.................... short inputCheck(int index) 
.................... { 
....................   flag = FALSE; 
....................  
....................   if(((inCurrent ^ inLast) & (1 << index)) && ((inCurrent ^ inState) & (1 << index))) 
....................     inDebounceCount[index] = 0; 
....................   else if (((inCurrent ^ inLast) & (1 << index)) == 0 && ((inCurrent ^ inState) & (1 << index))) 
....................   { 
....................     if(inDebounceCount[index] < 32 && ++inDebounceCount[index] == 32) 
....................     { 
....................       if(inCurrent & (1 << index)) 
....................         inState |= (1 << index); 
....................       else 
....................         inState &= ~(1 << index); 
....................       flag = TRUE; 
....................     } 
....................   } 
....................   return flag; 
.................... } 
....................  
.................... /* 
.................... void sendOscMsgInput(void) 
.................... { 
....................   inLast = inCurrent; 
....................  
....................   for(j = 0; j < 2; j++) 
....................   { 
....................     if(j == 0) 
....................       k = input(PIN_B4); 
....................     else if(j == 1) 
....................       k = input(PIN_B0); 
....................  
....................     if(k == 0) 
....................       inCurrent |= (1 << j); 
....................     else 
....................       inCurrent &= ~(1 << j); 
....................        
....................     if(inputCheck(j)) 
....................       printf(usb_cdc_putc, "input %d %d\r", j, ((inState & (1 << j)) ? 1 : 0)); 
....................   } 
.................... } 
.................... */ 
....................  
.................... /***********************************/ 
.................... /*                                 */ 
.................... /*      Functions for EEPROM       */ 
.................... /*                                 */ 
.................... /***********************************/ 
.................... void initAndSaveParaToEeprom(void) 
.................... { 
....................   para.intensity = 0x0F; 
*
27C0:  MOVLW  0F
27C2:  MOVLB  2
27C4:  MOVWF  x76
....................   putParaToEeprom(&para, sizeof(para), 0); 
27C6:  MOVLW  02
27C8:  MOVWF  x85
27CA:  MOVLW  76
27CC:  MOVWF  x84
27CE:  MOVLW  01
27D0:  MOVWF  x86
27D2:  CLRF   x87
27D4:  MOVLB  0
27D6:  RCALL  276A
.................... } 
27D8:  GOTO   4418 (RETURN)
....................  
.................... void getParaFromEeprom(int *ptr, int num, int addr) 
.................... { 
....................   int count; 
....................   for(count = 0; count < num; count++) 
*
272A:  MOVLB  2
272C:  CLRF   x7B
272E:  MOVF   x79,W
2730:  SUBWF  x7B,W
2732:  BC    2764
....................     ptr[count] = read_eeprom(addr + count); 
2734:  CLRF   03
2736:  MOVF   x7B,W
2738:  ADDWF  x77,W
273A:  MOVWF  FE9
273C:  MOVF   x78,W
273E:  ADDWFC 03,W
2740:  MOVWF  FEA
2742:  MOVF   x7B,W
2744:  ADDWF  x7A,W
2746:  MOVWF  x7E
2748:  MOVFF  FF2,27F
274C:  BCF    FF2.7
274E:  MOVFF  27E,FA9
2752:  BCF    FA6.6
2754:  BCF    FA6.7
2756:  BSF    FA6.0
2758:  MOVF   FA8,W
275A:  BTFSC  x7F.7
275C:  BSF    FF2.7
275E:  MOVWF  FEF
2760:  INCF   x7B,F
2762:  BRA    272E
.................... } 
2764:  MOVLB  0
2766:  GOTO   440C (RETURN)
....................  
.................... void putParaToEeprom(int *ptr,int num,int addr) 
.................... { 
....................   int count; 
....................   for(count = 0; count < num; count++) 
276A:  MOVLB  2
276C:  CLRF   x88
276E:  MOVF   x86,W
2770:  SUBWF  x88,W
2772:  BC    27BC
....................     write_eeprom(addr + count, ptr[count]); 
2774:  MOVF   x88,W
2776:  ADDWF  x87,W
2778:  MOVWF  x89
277A:  CLRF   03
277C:  MOVF   x88,W
277E:  ADDWF  x84,W
2780:  MOVWF  FE9
2782:  MOVF   x85,W
2784:  ADDWFC 03,W
2786:  MOVWF  FEA
2788:  MOVFF  FEF,28A
278C:  MOVFF  289,FA9
2790:  MOVFF  28A,FA8
2794:  BCF    FA6.6
2796:  BCF    FA6.7
2798:  BSF    FA6.2
279A:  MOVFF  FF2,00
279E:  BCF    FF2.7
27A0:  MOVLB  F
27A2:  MOVLW  55
27A4:  MOVWF  FA7
27A6:  MOVLW  AA
27A8:  MOVWF  FA7
27AA:  BSF    FA6.1
27AC:  BTFSC  FA6.1
27AE:  BRA    27AC
27B0:  BCF    FA6.2
27B2:  MOVF   00,W
27B4:  IORWF  FF2,F
27B6:  MOVLB  2
27B8:  INCF   x88,F
27BA:  BRA    276E
.................... } 
27BC:  MOVLB  0
27BE:  RETLW  00
....................  
.................... int my_atoi(char s) 
.................... { 
....................   int result = 0; 
*
2C7C:  MOVLB  2
2C7E:  CLRF   x85
....................  
....................   if (s >= '0' && s <= '9') 
2C80:  MOVF   x84,W
2C82:  SUBLW  2F
2C84:  BC    2C9E
2C86:  MOVF   x84,W
2C88:  SUBLW  39
2C8A:  BNC   2C9E
....................     result = (result << 4) + (s - '0'); 
2C8C:  SWAPF  x85,W
2C8E:  MOVWF  x86
2C90:  MOVLW  F0
2C92:  ANDWF  x86,F
2C94:  MOVLW  30
2C96:  SUBWF  x84,W
2C98:  ADDWF  x86,W
2C9A:  MOVWF  x85
....................   else 
2C9C:  BRA    2CB0
....................     result = (result << 4) + (s - 'A' + 10); 
2C9E:  SWAPF  x85,W
2CA0:  MOVWF  x86
2CA2:  MOVLW  F0
2CA4:  ANDWF  x86,F
2CA6:  MOVLW  41
2CA8:  SUBWF  x84,W
2CAA:  ADDLW  0A
2CAC:  ADDWF  x86,W
2CAE:  MOVWF  x85
....................   return result; 
2CB0:  MOVFF  285,01
.................... } 
2CB4:  MOVLB  0
2CB6:  RETLW  00
....................  
.................... void my_get_string_usb(char* s, int max) 
.................... { 
....................   int len = 0; 
*
2C2A:  MOVLB  2
2C2C:  CLRF   x87
....................   char c; 
....................  
....................   --max; 
2C2E:  DECF   x86,F
....................   do { 
....................     c = usb_cdc_getc(); 
2C30:  MOVLB  0
2C32:  BRA    2BDE
2C34:  MOVFF  01,288
....................     if(c >= ' ' && c <= '~') 
2C38:  MOVLB  2
2C3A:  MOVF   x88,W
2C3C:  SUBLW  1F
2C3E:  BC    2C60
2C40:  MOVF   x88,W
2C42:  SUBLW  7E
2C44:  BNC   2C60
....................       if(len < max) 
2C46:  MOVF   x86,W
2C48:  SUBWF  x87,W
2C4A:  BC    2C60
....................         s[len++] = c; 
2C4C:  MOVF   x87,W
2C4E:  INCF   x87,F
2C50:  CLRF   03
2C52:  ADDWF  x84,W
2C54:  MOVWF  FE9
2C56:  MOVF   x85,W
2C58:  ADDWFC 03,W
2C5A:  MOVWF  FEA
2C5C:  MOVFF  288,FEF
....................   } while(c != 13); 
2C60:  MOVF   x88,W
2C62:  SUBLW  0D
2C64:  BNZ   2C30
....................   s[len] = 0; 
2C66:  CLRF   03
2C68:  MOVF   x87,W
2C6A:  ADDWF  x84,W
2C6C:  MOVWF  FE9
2C6E:  MOVF   x85,W
2C70:  ADDWFC 03,W
2C72:  MOVWF  FEA
2C74:  CLRF   FEF
.................... } 
2C76:  MOVLB  0
2C78:  GOTO   3376 (RETURN)

Configuration Fuses:
   Word  1: 0E24   NOIESO NOFCMEN HSPLL PLL5 CPUDIV1 USBDIV
   Word  2: 0E39   NOBROWNOUT WDT128 NOWDT BORV20 NOPUT VREGEN
   Word  3: 0500   NOPBADEN CCP2C1 NOMCLR LPT1OSC
   Word  4: 0080   NOSTVREN NODEBUG NOLVP NOXINST
   Word  5: C00F   NOPROTECT NOCPD NOCPB
   Word  6: E00F   NOWRT NOWRTD NOWRTC NOWRTB
   Word  7: 400F   NOEBTR NOEBTRB
