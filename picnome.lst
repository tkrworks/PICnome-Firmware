CCS PCH C Compiler, Version 4.089, 47658               06-7-10 00:52

               Filename: Y:\PICnome-firmware\picnome.lst

               ROM used: 9488 bytes (29%)
                         Largest free fragment is 17132
               RAM used: 1429 (70%) at main() level
                         1476 (72%) worst case
               Stack:    13 worst case (6 in main + 7 for interrupts)

*
1800:  GOTO   3B90
*
1808:  MOVWF  05
180A:  MOVFF  FD8,06
180E:  MOVFF  FE0,07
1812:  MOVLB  0
1814:  MOVFF  FE9,0D
1818:  MOVFF  FEA,08
181C:  MOVFF  FE1,09
1820:  MOVFF  FE2,0A
1824:  MOVFF  FD9,0B
1828:  MOVFF  FDA,0C
182C:  MOVFF  FF3,14
1830:  MOVFF  FF4,15
1834:  MOVFF  FFA,16
1838:  MOVFF  00,0F
183C:  MOVFF  01,10
1840:  MOVFF  02,11
1844:  MOVFF  03,12
1848:  MOVFF  04,13
184C:  BTFSS  FA0.5
184E:  GOTO   1858
1852:  BTFSC  FA1.5
1854:  GOTO   26BA
1858:  MOVFF  0F,00
185C:  MOVFF  10,01
1860:  MOVFF  11,02
1864:  MOVFF  12,03
1868:  MOVFF  13,04
186C:  MOVFF  0D,FE9
1870:  MOVFF  08,FEA
1874:  BSF    08.7
1876:  MOVFF  09,FE1
187A:  MOVFF  0A,FE2
187E:  MOVFF  0B,FD9
1882:  MOVFF  0C,FDA
1886:  MOVFF  14,FF3
188A:  MOVFF  15,FF4
188E:  MOVFF  16,FFA
1892:  MOVF   05,W
1894:  MOVFF  07,FE0
1898:  MOVFF  06,FD8
189C:  RETFIE 0
.................... /* 
....................  * Copyright (C) 2006, Brian Crabtree and Joe Lake, monome.org 
....................  * 
....................  * This file is used the copied code from monome/40h/40h.c. 
....................  * 
....................  * Copylight (C) 2009, Shunichi Yamamoto, tkrworks.net 
....................  * 
....................  * This file is part of PICnome. 
....................  * 
....................  * PICnome is free software: you can redistribute it and/or modify 
....................  * it under the terms of the GNU General Public License as published by 
....................  * the Free Software Foundation, either version 3 of the License, or 
....................  * (at your option ) any later version. 
....................  * 
....................  * PICnome is distributed in the hope that it will be useful, 
....................  * but WITHIOUT ANY WARRANTY; without even the implied warranty of 
....................  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.   See the 
....................  * GNU General Public License for more details. 
....................  * 
....................  * You should have received a copy of the GNU General Public License 
....................  * along with PICnome. if not, see <http:/www.gnu.org/licenses/>. 
....................  * 
....................  * picnome.c,v.1.0.23 2010/07/05 
....................  */ 
....................  
.................... #include "picnome.h" 
.................... /* 
....................  * Copylight (C) 2009, Shunichi Yamamoto, tkrworks.net 
....................  * 
....................  * This file is part of PICnome. 
....................  * 
....................  * PICnome is free software: you can redistribute it and/or modify 
....................  * it under the terms of the GNU General Public License as published by 
....................  * the Free Software Foundation, either version 3 of the License, or 
....................  * (at your option ) any later version. 
....................  * 
....................  * PICnome is distributed in the hope that it will be useful, 
....................  * but WITHIOUT ANY WARRANTY; without even the implied warranty of 
....................  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.   See the 
....................  * GNU General Public License for more details. 
....................  * 
....................  * You should have received a copy of the GNU General Public License 
....................  * along with PICnome. if not, see <http:/www.gnu.org/licenses/>. 
....................  * 
....................  * picnome.h,v.1.0.23 2010/07/05 
....................  */ 
....................  
.................... //sy #define ONE_TWENTY_EIGHT 
....................  
.................... #include <18F2550.h> 
.................... //////// Standard Header file for the PIC18F2550 device //////////////// 
.................... #device PIC18F2550 
.................... #list 
....................  
.................... #device adc=10 
....................  
.................... #FUSES NOWDT                    //No Watch Dog Timer 
.................... #FUSES WDT128                   //Watch Dog Timer uses 1:128 Postscale 
.................... #FUSES HSPLL                    //High Speed Crystal/Resonator with PLL enabled 
.................... #FUSES NOPROTECT                //Code not protected from reading 
.................... #FUSES NOBROWNOUT               //No brownout reset 
.................... #FUSES BORV20                   //Brownout reset at 2.0V 
.................... #FUSES NOPUT                    //No Power Up Timer 
.................... #FUSES NOCPD                    //No EE protection 
.................... #FUSES NOSTVREN                 //Stack full/underflow will not cause reset 
.................... #FUSES NODEBUG                  //No Debug mode for ICD 
.................... #FUSES NOLVP                    //No low voltage prgming, B3(PIC16) or B5(PIC18) used for I/O 
.................... #FUSES NOWRT                    //Program memory not write protected 
.................... #FUSES NOWRTD                   //Data EEPROM not write protected 
.................... #FUSES NOIESO                   //Internal External Switch Over mode disabled 
.................... #FUSES NOFCMEN                  //Fail-safe clock monitor disabled 
.................... #FUSES NOPBADEN                 //PORTB pins are configured as digital I/O on RESET 
.................... #FUSES NOWRTC                   //configuration not registers write protected 
.................... #FUSES NOWRTB                   //Boot block not write protected 
.................... #FUSES NOEBTR                   //Memory not protected from table reads 
.................... #FUSES NOEBTRB                  //Boot block not protected from table reads 
.................... #FUSES NOCPB                    //No Boot Block code protection 
.................... #FUSES LPT1OSC                  //Timer1 configured for low-power operation 
.................... #FUSES NOMCLR                   //Master Clear pin used for I/O 
.................... #FUSES NOXINST                  //Extended set extension and Indexed Addressing mode disabled (Legacy mode) 
.................... #FUSES PLL5                     //Divide By 5(20MHz oscillator input) 
.................... #FUSES USBDIV                   //USB clock source comes from PLL divide by 2 
.................... #FUSES CPUDIV1                  //No System Clock Postscaler 
.................... #FUSES VREGEN                   //USB voltage regulator enabled 
....................  
.................... #USE DELAY(CLOCK=48MHZ, CRYSTAL=20MHZ) 
*
2898:  MOVLW  01
289A:  MOVWF  FEA
289C:  MOVLW  93
289E:  MOVWF  FE9
28A0:  MOVF   FEF,W
28A2:  BZ    28C0
28A4:  MOVLW  0F
28A6:  MOVWF  01
28A8:  CLRF   00
28AA:  DECFSZ 00,F
28AC:  BRA    28AA
28AE:  DECFSZ 01,F
28B0:  BRA    28A8
28B2:  MOVLW  8F
28B4:  MOVWF  00
28B6:  DECFSZ 00,F
28B8:  BRA    28B6
28BA:  NOP   
28BC:  DECFSZ FEF,F
28BE:  BRA    28A4
28C0:  RETLW  00
....................  
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #define size_t unsigned int8 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #define size_t unsigned int8 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #define size_t unsigned int8 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
*
2D02:  MOVFF  1A4,1A8
2D06:  MOVFF  1A3,1A7
2D0A:  MOVFF  1A8,03
2D0E:  MOVLB  1
2D10:  MOVFF  1A7,FE9
2D14:  MOVFF  1A8,FEA
2D18:  MOVF   FEF,F
2D1A:  BZ    2D70
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
2D1C:  MOVFF  1A6,1AA
2D20:  MOVFF  1A5,1A9
2D24:  MOVFF  1AA,03
2D28:  MOVFF  1A9,FE9
2D2C:  MOVFF  1AA,FEA
2D30:  MOVF   FEF,F
2D32:  BZ    2D64
....................          if (*sc1 == *sc2) 
2D34:  MOVFF  1A7,FE9
2D38:  MOVFF  1A8,FEA
2D3C:  MOVFF  FEF,1AB
2D40:  MOVFF  1AA,03
2D44:  MOVFF  1A9,FE9
2D48:  MOVFF  1AA,FEA
2D4C:  MOVF   FEF,W
2D4E:  SUBWF  xAB,W
2D50:  BNZ   2D5C
....................             return(sc1); 
2D52:  MOVFF  1A7,01
2D56:  MOVFF  1A8,02
2D5A:  BRA    2D76
2D5C:  INCF   xA9,F
2D5E:  BTFSC  FD8.2
2D60:  INCF   xAA,F
2D62:  BRA    2D24
2D64:  INCF   xA7,F
2D66:  BTFSC  FD8.2
2D68:  INCF   xA8,F
2D6A:  MOVLB  0
2D6C:  BRA    2D0A
2D6E:  MOVLB  1
....................    return(0); 
2D70:  MOVLW  00
2D72:  MOVWF  01
2D74:  MOVWF  02
.................... } 
2D76:  MOVLB  0
2D78:  GOTO   2DEE (RETURN)
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
*
2C72:  MOVFF  1A4,1A8
2C76:  MOVFF  1A3,1A7
2C7A:  MOVFF  1A8,03
2C7E:  MOVLB  1
2C80:  MOVFF  1A7,FE9
2C84:  MOVFF  1A8,FEA
2C88:  MOVF   FEF,F
2C8A:  BZ    2CEC
....................       for (sc2 = s2; ; sc2++) 
2C8C:  MOVFF  1A6,1AA
2C90:  MOVFF  1A5,1A9
....................     if (*sc2 == '\0') 
2C94:  MOVFF  1AA,03
2C98:  MOVFF  1A9,FE9
2C9C:  MOVFF  1AA,FEA
2CA0:  MOVF   FEF,F
2CA2:  BNZ   2CB8
....................        return(sc1 - s1); 
2CA4:  MOVF   xA3,W
2CA6:  SUBWF  xA7,W
2CA8:  MOVWF  00
2CAA:  MOVF   xA4,W
2CAC:  SUBWFB xA8,W
2CAE:  MOVWF  03
2CB0:  MOVFF  00,01
2CB4:  BRA    2CFC
....................          else if (*sc1 == *sc2) 
2CB6:  BRA    2CD8
2CB8:  MOVFF  1A7,FE9
2CBC:  MOVFF  1A8,FEA
2CC0:  MOVFF  FEF,1AB
2CC4:  MOVFF  1AA,03
2CC8:  MOVFF  1A9,FE9
2CCC:  MOVFF  1AA,FEA
2CD0:  MOVF   FEF,W
2CD2:  SUBWF  xAB,W
2CD4:  BNZ   2CD8
....................             break; 
2CD6:  BRA    2CE0
2CD8:  INCF   xA9,F
2CDA:  BTFSC  FD8.2
2CDC:  INCF   xAA,F
2CDE:  BRA    2C94
2CE0:  INCF   xA7,F
2CE2:  BTFSC  FD8.2
2CE4:  INCF   xA8,F
2CE6:  MOVLB  0
2CE8:  BRA    2C7A
2CEA:  MOVLB  1
....................    return(sc1 - s1); 
2CEC:  MOVF   xA3,W
2CEE:  SUBWF  xA7,W
2CF0:  MOVWF  00
2CF2:  MOVF   xA4,W
2CF4:  SUBWFB xA8,W
2CF6:  MOVWF  03
2CF8:  MOVFF  00,01
.................... } 
2CFC:  MOVLB  0
2CFE:  GOTO   2DAC (RETURN)
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
*
2D7C:  MOVLB  1
2D7E:  MOVF   x9B,W
2D80:  IORWF  x9C,W
2D82:  BZ    2D8C
2D84:  MOVFF  19C,03
2D88:  MOVF   x9B,W
2D8A:  BRA    2D92
2D8C:  MOVFF  1A,03
2D90:  MOVF   19,W
2D92:  MOVWF  x9F
2D94:  MOVFF  03,1A0
....................    beg += strspn(beg, s2); 
2D98:  MOVFF  1A0,1A4
2D9C:  MOVFF  19F,1A3
2DA0:  MOVFF  19E,1A6
2DA4:  MOVFF  19D,1A5
2DA8:  MOVLB  0
2DAA:  BRA    2C72
2DAC:  MOVF   01,W
2DAE:  MOVLB  1
2DB0:  ADDWF  x9F,F
2DB2:  MOVLW  00
2DB4:  ADDWFC xA0,F
....................    if (*beg == '\0') 
2DB6:  MOVFF  1A0,03
2DBA:  MOVFF  19F,FE9
2DBE:  MOVFF  1A0,FEA
2DC2:  MOVF   FEF,F
2DC4:  BNZ   2DDA
....................    { 
....................       *save = ' '; 
2DC6:  MOVFF  19,FE9
2DCA:  MOVFF  1A,FEA
2DCE:  MOVLW  20
2DD0:  MOVWF  FEF
....................       return(0); 
2DD2:  MOVLW  00
2DD4:  MOVWF  01
2DD6:  MOVWF  02
2DD8:  BRA    2E28
....................    } 
....................    end = strpbrk(beg, s2); 
2DDA:  MOVFF  1A0,1A4
2DDE:  MOVFF  19F,1A3
2DE2:  MOVFF  19E,1A6
2DE6:  MOVFF  19D,1A5
2DEA:  MOVLB  0
2DEC:  BRA    2D02
2DEE:  MOVFF  02,1A2
2DF2:  MOVFF  01,1A1
....................    if (*end != '\0') 
2DF6:  MOVFF  1A2,03
2DFA:  MOVLB  1
2DFC:  MOVFF  1A1,FE9
2E00:  MOVFF  1A2,FEA
2E04:  MOVF   FEF,F
2E06:  BZ    2E18
....................    { 
....................       *end = '\0'; 
2E08:  MOVFF  1A1,FE9
2E0C:  MOVFF  1A2,FEA
2E10:  CLRF   FEF
....................       end++; 
2E12:  INCF   xA1,F
2E14:  BTFSC  FD8.2
2E16:  INCF   xA2,F
....................    } 
....................    save = end; 
2E18:  MOVFF  1A2,1A
2E1C:  MOVFF  1A1,19
....................    return(beg); 
2E20:  MOVFF  19F,01
2E24:  MOVFF  1A0,02
.................... } 
2E28:  MOVLB  0
2E2A:  RETLW  00
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
*
2E7C:  MOVLB  1
2E7E:  CLRF   xA0
....................    sign = 0; 
2E80:  CLRF   x9E
....................    base = 10; 
2E82:  MOVLW  0A
2E84:  MOVWF  x9F
....................    result = 0; 
2E86:  CLRF   x9D
....................  
....................    if (!s) 
2E88:  MOVF   x9B,W
2E8A:  IORWF  x9C,W
2E8C:  BNZ   2E94
....................       return 0; 
2E8E:  MOVLW  00
2E90:  MOVWF  01
2E92:  BRA    301A
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
2E94:  MOVF   xA0,W
2E96:  INCF   xA0,F
2E98:  CLRF   03
2E9A:  ADDWF  x9B,W
2E9C:  MOVWF  FE9
2E9E:  MOVF   x9C,W
2EA0:  ADDWFC 03,W
2EA2:  MOVWF  FEA
2EA4:  MOVFF  FEF,1A1
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
2EA8:  MOVF   xA1,W
2EAA:  SUBLW  2D
2EAC:  BNZ   2EC8
....................    { 
....................       sign = 1;         // Set the sign to negative 
2EAE:  MOVLW  01
2EB0:  MOVWF  x9E
....................       c = s[index++]; 
2EB2:  MOVF   xA0,W
2EB4:  INCF   xA0,F
2EB6:  CLRF   03
2EB8:  ADDWF  x9B,W
2EBA:  MOVWF  FE9
2EBC:  MOVF   x9C,W
2EBE:  ADDWFC 03,W
2EC0:  MOVWF  FEA
2EC2:  MOVFF  FEF,1A1
....................    } 
....................    else if (c == '+') 
2EC6:  BRA    2EE2
2EC8:  MOVF   xA1,W
2ECA:  SUBLW  2B
2ECC:  BNZ   2EE2
....................    { 
....................       c = s[index++]; 
2ECE:  MOVF   xA0,W
2ED0:  INCF   xA0,F
2ED2:  CLRF   03
2ED4:  ADDWF  x9B,W
2ED6:  MOVWF  FE9
2ED8:  MOVF   x9C,W
2EDA:  ADDWFC 03,W
2EDC:  MOVWF  FEA
2EDE:  MOVFF  FEF,1A1
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
2EE2:  MOVF   xA1,W
2EE4:  SUBLW  2F
2EE6:  BTFSC  FD8.0
2EE8:  BRA    300A
2EEA:  MOVF   xA1,W
2EEC:  SUBLW  39
2EEE:  BTFSS  FD8.0
2EF0:  BRA    300A
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
2EF2:  MOVF   xA1,W
2EF4:  SUBLW  30
2EF6:  BNZ   2F3A
2EF8:  CLRF   03
2EFA:  MOVF   xA0,W
2EFC:  ADDWF  x9B,W
2EFE:  MOVWF  FE9
2F00:  MOVF   x9C,W
2F02:  ADDWFC 03,W
2F04:  MOVWF  FEA
2F06:  MOVF   FEF,W
2F08:  SUBLW  78
2F0A:  BZ    2F20
2F0C:  CLRF   03
2F0E:  MOVF   xA0,W
2F10:  ADDWF  x9B,W
2F12:  MOVWF  FE9
2F14:  MOVF   x9C,W
2F16:  ADDWFC 03,W
2F18:  MOVWF  FEA
2F1A:  MOVF   FEF,W
2F1C:  SUBLW  58
2F1E:  BNZ   2F3A
....................       { 
....................          base = 16; 
2F20:  MOVLW  10
2F22:  MOVWF  x9F
....................          index++; 
2F24:  INCF   xA0,F
....................          c = s[index++]; 
2F26:  MOVF   xA0,W
2F28:  INCF   xA0,F
2F2A:  CLRF   03
2F2C:  ADDWF  x9B,W
2F2E:  MOVWF  FE9
2F30:  MOVF   x9C,W
2F32:  ADDWFC 03,W
2F34:  MOVWF  FEA
2F36:  MOVFF  FEF,1A1
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
2F3A:  MOVF   x9F,W
2F3C:  SUBLW  0A
2F3E:  BNZ   2F7A
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
2F40:  MOVF   xA1,W
2F42:  SUBLW  2F
2F44:  BC    2F78
2F46:  MOVF   xA1,W
2F48:  SUBLW  39
2F4A:  BNC   2F78
....................             result = 10*result + (c - '0'); 
2F4C:  MOVLW  0A
2F4E:  MOVWF  xA2
2F50:  MOVFF  19D,1A3
2F54:  MOVLB  0
2F56:  BRA    2E2C
2F58:  MOVLW  30
2F5A:  MOVLB  1
2F5C:  SUBWF  xA1,W
2F5E:  ADDWF  01,W
2F60:  MOVWF  x9D
....................             c = s[index++]; 
2F62:  MOVF   xA0,W
2F64:  INCF   xA0,F
2F66:  CLRF   03
2F68:  ADDWF  x9B,W
2F6A:  MOVWF  FE9
2F6C:  MOVF   x9C,W
2F6E:  ADDWFC 03,W
2F70:  MOVWF  FEA
2F72:  MOVFF  FEF,1A1
....................          } 
2F76:  BRA    2F40
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
2F78:  BRA    300A
2F7A:  MOVF   x9F,W
2F7C:  SUBLW  10
2F7E:  BNZ   300A
....................       { 
....................          c = toupper(c); 
2F80:  MOVF   xA1,W
2F82:  SUBLW  60
2F84:  BC    2F92
2F86:  MOVF   xA1,W
2F88:  SUBLW  7A
2F8A:  BNC   2F92
2F8C:  MOVF   xA1,W
2F8E:  ANDLW  DF
2F90:  BRA    2F94
2F92:  MOVF   xA1,W
2F94:  MOVWF  xA1
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
2F96:  MOVF   xA1,W
2F98:  SUBLW  2F
2F9A:  BC    2FA2
2F9C:  MOVF   xA1,W
2F9E:  SUBLW  39
2FA0:  BC    2FAE
2FA2:  MOVF   xA1,W
2FA4:  SUBLW  40
2FA6:  BC    300A
2FA8:  MOVF   xA1,W
2FAA:  SUBLW  46
2FAC:  BNC   300A
....................             if (c >= '0' && c <= '9') 
2FAE:  MOVF   xA1,W
2FB0:  SUBLW  2F
2FB2:  BC    2FCC
2FB4:  MOVF   xA1,W
2FB6:  SUBLW  39
2FB8:  BNC   2FCC
....................                result = (result << 4) + (c - '0'); 
2FBA:  SWAPF  x9D,W
2FBC:  MOVWF  xA2
2FBE:  MOVLW  F0
2FC0:  ANDWF  xA2,F
2FC2:  MOVLW  30
2FC4:  SUBWF  xA1,W
2FC6:  ADDWF  xA2,W
2FC8:  MOVWF  x9D
....................             else 
2FCA:  BRA    2FDE
....................                result = (result << 4) + (c - 'A' + 10); 
2FCC:  SWAPF  x9D,W
2FCE:  MOVWF  xA2
2FD0:  MOVLW  F0
2FD2:  ANDWF  xA2,F
2FD4:  MOVLW  41
2FD6:  SUBWF  xA1,W
2FD8:  ADDLW  0A
2FDA:  ADDWF  xA2,W
2FDC:  MOVWF  x9D
....................  
....................             c = s[index++]; 
2FDE:  MOVF   xA0,W
2FE0:  INCF   xA0,F
2FE2:  CLRF   03
2FE4:  ADDWF  x9B,W
2FE6:  MOVWF  FE9
2FE8:  MOVF   x9C,W
2FEA:  ADDWFC 03,W
2FEC:  MOVWF  FEA
2FEE:  MOVFF  FEF,1A1
....................             c = toupper(c); 
2FF2:  MOVF   xA1,W
2FF4:  SUBLW  60
2FF6:  BC    3004
2FF8:  MOVF   xA1,W
2FFA:  SUBLW  7A
2FFC:  BNC   3004
2FFE:  MOVF   xA1,W
3000:  ANDLW  DF
3002:  BRA    3006
3004:  MOVF   xA1,W
3006:  MOVWF  xA1
....................          } 
3008:  BRA    2F96
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
300A:  DECFSZ x9E,W
300C:  BRA    3016
300E:  MOVF   x9F,W
3010:  SUBLW  0A
3012:  BNZ   3016
....................        result = -result; 
3014:  NEGF   x9D
....................  
....................    return(result); 
3016:  MOVFF  19D,01
.................... } 
301A:  MOVLB  0
301C:  RETLW  00
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = TRUE, sign = FALSE, point = FALSE; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = FALSE; 
....................          if (c == '+') 
....................          { 
....................             sign = FALSE; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = TRUE; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = TRUE; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((long *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((long *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = TRUE, sign = FALSE, point = FALSE; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = FALSE; 
....................          if (c == '+') 
....................          { 
....................             sign = FALSE; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = TRUE; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = TRUE; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((long *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((long *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = TRUE, sign = FALSE, point = FALSE; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = FALSE; 
....................          if (c == '+') 
....................          { 
....................             sign = FALSE; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = TRUE; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = TRUE; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((long *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((long *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((long *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((long *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((long *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((long *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    BYTE t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=TRUE; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = FALSE; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #include <usb_bootloader.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                     USB_BOOTLOADER.H                              //// 
.................... ////                                                                   //// 
.................... ////  This include file must be included by any application loaded     //// 
.................... ////  by the example USB bootloader (ex_usb_bootloader                 //// 
.................... ////                                                                   //// 
.................... ////  The directives in this file relocate the reset and interrupt     //// 
.................... ////  vectors as well as reserving space for the bootloader.           //// 
.................... ////                                                                   //// 
.................... ////  For more documentation see ex_usb_bootloader.c                   //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS    //// 
.................... //// C compiler.  This source code may only be distributed to other    //// 
.................... //// licensed users of the CCS C compiler.  No other use,              //// 
.................... //// reproduction or distribution is permitted without written         //// 
.................... //// permission.  Derivative programs created using this software      //// 
.................... //// in object code form are not restricted in any way.                //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... //how big is the bootloader? 
.................... //the bootloader will reside from address 0x0000 to this location.  the 
.................... //application will then sit at this location+1 to the end of program memory. 
.................... #define LOADER_SIZE        (0x17FF) 
....................  
.................... //the loader and application need a common flag that determines if we are in 
.................... //the bootloader or application, that way the ISR knows where to go.  this 
.................... //is the location in ram that is reserved for this flag. 
.................... #define LOC_IN_LOADER_FLAG  0x25 
....................  
.................... //// --- end configuration --- //////////////////////////////////////////// 
....................  
.................... #reserve LOC_IN_LOADER_FLAG 
....................  
.................... int8 g_InBootloader; 
.................... #locate g_InBootloader=LOC_IN_LOADER_FLAG 
....................  
.................... #define LOADER_START       (0) 
.................... #define LOADER_END         (LOADER_SIZE) 
.................... #define APPLICATION_START  (LOADER_SIZE+1) 
.................... #define APPLICATION_END    (getenv("PROGRAM_MEMORY")-1) 
.................... #define APPLICATION_ISR    (APPLICATION_START+8) 
....................  
.................... #ifdef _bootloader 
....................  /* 
....................   Provide an empty application, so if you load this .HEX file into the pic 
....................   without an application this will prevent the pic from executing unknown code. 
....................  */ 
....................  #org APPLICATION_START,APPLICATION_START+0xF 
....................  void BlankApplication(void)  
....................  { 
....................    while(TRUE); 
....................  } 
....................  
....................  //we need to prevent the loader from using application space 
....................  #if APPLICATION_END>0xFFFF 
....................    #org APPLICATION_START+0x10, 0xFFFF {} 
....................    #if APPLICATION_END>0x1FFFF 
....................       #org 0xFFFF, 0x1FFFF {} 
....................    #else 
....................       #org 0xFFFF, APPLICATION_END {} 
....................    #endif 
....................  #else 
....................    #org APPLICATION_START+0x10, APPLICATION_END {} 
....................  #endif 
.................... #endif 
....................  
.................... #ifndef _bootloader 
....................  //in the application, this moves the reset and isr vector out of the bootload 
....................  //space.  it then reserves the loader space from being used by the application. 
....................  #build(reset=APPLICATION_START, interrupt=APPLICATION_ISR) 
....................  #org 0, LOADER_END {} 
.................... #endif 
....................  
.................... #include "usb_cdc.h" 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                                                                 //// 
.................... ////                            usb_cdc.h                            //// 
.................... ////                                                                 //// 
.................... //// Library for adding a virtual COM port on your PC over USB using //// 
.................... //// the standard Communication Device Class (CDC) specification.    //// 
.................... //// Including this file in your code will add all USB code,         //// 
.................... //// interrupts, descriptors and handlers required.  No other        //// 
.................... //// modifications need to be made.                                  //// 
.................... ////                                                                 //// 
.................... //// This library creates a virtual RS232 link between the PC and    //// 
.................... //// the PIC, therefore the library provided will be familiar to     //// 
.................... //// anyone with standard UART stream I/O:                           //// 
.................... ////                                                                 //// 
.................... //// usb_cdc_kbhit() - Returns TRUE if there is one or more          //// 
.................... ////      character received and waiting in the receive buffer.      //// 
.................... ////                                                                 //// 
.................... //// usb_cdc_getc() - Gets a character from the receive buffer.  If  //// 
.................... ////      there is no data in the receive buffer it will wait until  //// 
.................... ////      there is data in the receive buffer.  If you do not want   //// 
.................... ////      to wait in an infinit loop, use usb_cdc_kbhit() first to   //// 
.................... ////      check if there is data before calling usb_cdc_getc().      //// 
.................... ////                                                                 //// 
.................... //// usb_cdc_putc(char c) - Puts a character into the transmit       //// 
.................... ////      buffer.  If the transmit buffer is full it will wait until //// 
.................... ////      the transmit buffer is not full before putting the char    //// 
.................... ////      into the transmit buffer.  The transmit buffer is read by  //// 
.................... ////      the PC very quickly, and therefore the buffer should only  //// 
.................... ////      be full for a few milli-seconds.  If you are concerned     //// 
.................... ////      and don't want to be stuck in a long or infinite loop,     //// 
.................... ////      use usb_cdc_putready() to see if there is space in the     //// 
.................... ////      transmit buffer before putting data into the transmit      //// 
.................... ////      buffer.                                                    //// 
.................... ////                                                                 //// 
.................... //// usb_cdc_putready() - Returns TRUE if there is room left in the  //// 
.................... ////      transmit buffer for another character.                     //// 
.................... ////                                                                 //// 
.................... //// usb_cdc_connected() - Returns TRUE if we received a             //// 
.................... ////      Set_Line_Coding.  On most serial terminal programs (such   //// 
.................... ////      as Hyperterminal), they will send a Set_Line_Coding        //// 
.................... ////      message when the program starts and it opens the virtual   //// 
.................... ////      COM port.  This is a simple way to determine if the PC     //// 
.................... ////      is ready to display data on a serial terminal program,     //// 
.................... ////      but is not garaunteed to work all the time or on other     //// 
.................... ////      terminal programs.                                         //// 
.................... ////                                                                 //// 
.................... //// usb_cdc_putc_fast(char c) - Similar to usb_cdc_putc(), except   //// 
.................... ////      if the transmit buffer is full it will skip the char.      //// 
.................... ////                                                                 //// 
.................... //// usb_cdc_line_coding - A structure used for Set_Line_Coding and  //// 
.................... ////       Get_Line_Coding.  Most of the time you can ignore this.   //// 
.................... ////                                                                 //// 
.................... //// usb_cdc_break - If the PC has sent a break command, this will   //// 
.................... ////       hold the break time (in milli-seconds).  If the PC sends  //// 
.................... ////       a value of 0xFFFF the device is supposed to hold the      //// 
.................... ////       break until it sends a value of 0                         //// 
.................... ////                                                                 //// 
.................... //// usb_cdc_carrier - Where Set_Control_Line_State value is stored. //// 
.................... ////       Of most relevance is the field dte_present, which is the  //// 
.................... ////       DTR setting.                                              //// 
.................... ////                                                                 //// 
.................... //// The following functions are also provided, and are ports of the //// 
.................... //// I/O functions in input.c.  See input.c and the CCS manual for   //// 
.................... //// documentation:                                                  //// 
.................... ////   get_float_usb() - Read a float number from the user           //// 
.................... ////   get_long_usb() - Read a long number from the user             //// 
.................... ////   get_int_usb() - Read an integer number from the user          //// 
.................... ////   get_string_usb(char *s, int max) - Read a string from the user. //// 
.................... ////   gethex_usb() - Read a byte, in HEX, from the user             //// 
.................... ////   gethex1_usb() - Read a HEX character                          //// 
.................... ////                                                                 //// 
.................... //// This driver will load all the rest of the USB code, and a set   //// 
.................... //// of descriptors that will properly describe a CDC device for a   //// 
.................... //// virtual COM port (usb_desc_cdc.h)                               //// 
.................... ////                                                                 //// 
.................... //// An .INF file is provided (cdc_NTXP.inf) that will load the      //// 
.................... //// standard CDC drivers for a virtual COM port in Windows          //// 
.................... //// NT/2000/XP and above.  Unfortunately we do not provide an .inf  //// 
.................... //// file for Windows 98 and ME.                                     //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                                                                 //// 
.................... //// VERSION HISTORY                                                 //// 
.................... ////                                                                 //// 
.................... //// October 27th, 2005: Changed the way incoming packets are        //// 
.................... ////               handled in that CDC driver will not flush         //// 
.................... ////               endpoint until user has handled all data.  This   //// 
.................... ////               will prevent overflows as the USB will NAK        //// 
.................... ////               incoming packets until it is ready to receive     //// 
.................... ////               more.                                             //// 
.................... ////            When using 18F4550 family, the RX buffer is          //// 
.................... ////               mapped directly to the endpoint buffer - this     //// 
.................... ////               saves a chunk of RAM.                             //// 
.................... ////            When using the 18F4550 family, you can increase      //// 
.................... ////               the TX and RX size over 64 bytes.                 //// 
.................... ////            No longer send 0len packets in the TBE interrupt.    //// 
.................... ////            Hopefully fixed bugs that caused random crashes      //// 
.................... ////               if you tried sending more than 64 bytes.          //// 
.................... ////                                                                 //// 
.................... //// July 6th, 2005: Global interrupts disabled when writing to TX   //// 
.................... ////                   buffer.                                       //// 
.................... ////                                                                 //// 
.................... //// July 1st, 2005: Initial Release.                                //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2005 Custom Computer Services         //// 
.................... //// This source code may only be used by licensed users of the CCS  //// 
.................... //// C compiler.  This source code may only be distributed to other  //// 
.................... //// licensed users of the CCS C compiler.  No other use,            //// 
.................... //// reproduction or distribution is permitted without written       //// 
.................... //// permission.  Derivative programs created using this software    //// 
.................... //// in object code form are not restricted in any way.              //// 
.................... ///////////////////////////////////////////////////////////////////////// 
....................  
....................  
.................... //api for the user: 
.................... #define usb_cdc_kbhit() (usb_cdc_get_buffer_status.got) 
.................... #define usb_cdc_putready() (usb_cdc_put_buffer_nextin<USB_CDC_DATA_IN_SIZE) 
.................... #define usb_cdc_connected() (usb_cdc_got_set_line_coding) 
.................... void usb_cdc_putc_fast(char c); 
.................... char usb_cdc_getc(void); 
.................... void usb_cdc_putc(char c); 
....................  
.................... //input.c ported to use CDC: 
.................... float get_float_usb(); 
.................... signed long get_long_usb(); 
.................... signed int get_int_usb(); 
.................... void get_string_usb(char* s, int max); 
.................... BYTE gethex_usb(); 
.................... BYTE gethex1_usb(); 
....................  
.................... //functions automatically called by USB handler code 
.................... void usb_isr_tkn_cdc(void); 
.................... void usb_cdc_init(void); 
.................... void usb_isr_tok_out_cdc_control_dne(void); 
.................... void usb_isr_tok_in_cdc_data_dne(void); 
.................... void usb_isr_tok_out_cdc_data_dne(void); 
....................  
.................... void usb_cdc_flush_out_buffer(void); 
....................  
.................... //Tells the CCS PIC USB firmware to include HID handling code. 
.................... #DEFINE USB_HID_DEVICE  FALSE 
.................... #DEFINE USB_CDC_DEVICE  TRUE 
....................  
.................... #define USB_CDC_COMM_IN_ENDPOINT       1 
.................... #define USB_CDC_COMM_IN_SIZE           8 
.................... #define USB_EP1_TX_ENABLE  USB_ENABLE_INTERRUPT 
.................... #define USB_EP1_TX_SIZE  USB_CDC_COMM_IN_SIZE 
....................  
.................... //pic to pc endpoint config 
.................... #define USB_CDC_DATA_IN_ENDPOINT       2 
.................... #define USB_CDC_DATA_IN_SIZE           64 
.................... #define USB_EP2_TX_ENABLE  USB_ENABLE_BULK 
.................... #define USB_EP2_TX_SIZE  USB_CDC_DATA_IN_SIZE 
....................  
.................... //pc to pic endpoint config 
.................... #define USB_CDC_DATA_OUT_ENDPOINT       2 
.................... #define USB_CDC_DATA_OUT_SIZE           64 
.................... #define USB_EP2_RX_ENABLE  USB_ENABLE_BULK 
.................... #define USB_EP2_RX_SIZE  USB_CDC_DATA_OUT_SIZE 
....................  
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... // 
.................... // Include the CCS USB Libraries.  See the comments at the top of these 
.................... // files for more information 
.................... // 
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... #ifndef __USB_PIC_PERIF__ 
.................... #define __USB_PIC_PERIF__	1 
.................... #endif 
....................  
.................... #if __USB_PIC_PERIF__ 
....................  #if defined(__PCM__) 
....................   #error CDC requires bulk mode!  PIC16C7x5 does not have bulk mode 
....................  #else 
....................   #include <pic18_usb.h>   //Microchip 18Fxx5x hardware layer for usb.c 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                          pic18_usb.c                            //// 
.................... ////                                                                 //// 
.................... //// Hardware layer for CCS's USB library.  This hardware layer      //// 
.................... //// supports the USB peripheral on the PIC18 family chips.  Current //// 
.................... //// supported families are:                                         //// 
.................... ////     PIC18F2455/2550/4455/4550                                   //// 
.................... ////     PIC18F2450/4450                                             //// 
.................... ////     PIC18F65J50/66J50/66J55/67J50/85J50/86J50/86J55/87J50       //// 
.................... ////                                                                 //// 
.................... //// This file is part of CCS's PIC USB driver code, which includes: //// 
.................... ////   usb_desc_*.h - an example set of config and device descriptor //// 
.................... ////   usb.c - USB token and request handler code                    //// 
.................... ////   usb.h - definitions, prototypes and global variables          //// 
.................... ////                                                                 //// 
.................... //// The following examples are provided by CCS:                     //// 
.................... ////   ex_usb_mouse.c - A HID Mouse.                                 //// 
.................... ////   ex_usb_hid.c - A custom application using HID protocol.       //// 
.................... ////   ex_usb_kbmouse.c - A HID Mouse/Keyboard combo using multiple  //// 
.................... ////                      interfaces.                                //// 
.................... ////   ex_usb_kbmouse2.c - A HID Mouse/Keyboard combo using multiple //// 
.................... ////                      HID Reports.                               //// 
.................... ////   ex_usb_scope.c - A digital oscilloscope using a custom        //// 
.................... ////                    protocol requiring custom Windows drivers.   //// 
.................... ////   ex_usb_serial.c -                                             //// 
.................... ////   ex_usb_serial2.c - Two examples of using the CDC driver for   //// 
.................... ////     a virtual COM port.                                         //// 
.................... ////                                                                 //// 
.................... ////   *********** NOTE ABOUT 18F2450/4450 LIMITATIONS **********    //// 
.................... ////  Due to the limited USB RAM of this family, a limitation of     //// 
.................... ////  this driver is that there are only 3 endpoints (0, 1 and 2).   //// 
.................... ////  The HW actually supports more endpoints, but to simplify       //// 
.................... ////  driver development this driver will only support the first 3   //// 
.................... ////  so there is an easier memory block to work with.               //// 
.................... ////                                                                 //// 
.................... ////  USB_MAX_EP0_PACKET_LENGTH will also be set to 8 regardless     //// 
.................... ////  of USB speed, to save RAM.                                     //// 
.................... ////                                                                 //// 
.................... ////   ************** NOTE ABOUT HW REQUIREMENTS ****************    //// 
.................... ////  If you are not using internal pullups, you will need to put    //// 
.................... ////  an internal pullup resistor on C4 or C5 depending on if you    //// 
.................... ////  want to use slow speed or full speed.  This code configures    //// 
.................... ////  the device to use internal pullups, see usb_init() if you      //// 
.................... ////  want to change that.                                           //// 
.................... ////                                                                 //// 
.................... ////  You need approximately 470nF cap on C3, even if you are using  //// 
.................... ////  the internal 3.3V USB regulator.                               //// 
.................... ////                                                                 //// 
.................... ////  To run at full speed, you must use the oscillator              //// 
.................... ////  configuration (PLLx) to set the PLL divide to 4MHz.  You can   //// 
.................... ////  configure the MCU clock to any speed (up to 48MHz) but the     //// 
.................... ////  PLL must run at 4Mhz to provide the USB peripheral with a      //// 
.................... ////  96MHz clock.  See the datasheet for details.                   //// 
.................... ////                                                                 //// 
.................... ////  To run at slow speed you must configure your MCU to run at     //// 
.................... ////  24Mhz.  See the datasheet for details.                         //// 
.................... ////                                                                 //// 
.................... ////   ****************  NOTE ABOUT INTERRUPTS  ******************   //// 
.................... //// This driver uses INT_USB.  It requires INT_USB to interrupt the //// 
.................... //// PIC when an event has happened on the USB Bus.  Therfore        //// 
.................... //// this code enables interrupts.  A user modification can be made  //// 
.................... //// to poll the USB interrupt flag instead of relying on an         //// 
.................... //// interrupt.                                                      //// 
.................... ////                                                                 //// 
.................... ////    ****************   USER FUNCTIONS  ***********************   //// 
.................... ////                                                                 //// 
.................... //// usb_init() - Initializes the USB stack, the USB peripheral and  //// 
.................... ////              attaches the unit to the usb bus.  Enables         //// 
.................... ////              interrupts.                                        //// 
.................... ////                                                                 //// 
.................... //// usb_init_cs() - A smaller usb_init(), does not attach unit      //// 
.................... ////              to usb bus or enable interrupts.                   //// 
.................... ////                                                                 //// 
.................... //// usb_put_packet() - Sends one packet to the host.                //// 
.................... ////                    If you need to send a message that spans     //// 
.................... ////                    more than one packet then see usb_puts() in  //// 
.................... ////                    usb.c                                        //// 
.................... ////                                                                 //// 
.................... //// usb_kbhit() - Returns true if OUT endpoint contains data from   //// 
.................... ////               host.                                             //// 
.................... ////                                                                 //// 
.................... //// usb_rx_packet_size() - Returns the size of packet that was      //// 
.................... ////               received.  usb_kbhit() must return TRUE else      //// 
.................... ////               this is not valid.  Don't forget in USB there     //// 
.................... ////               are 0 len packets!                                //// 
.................... ////                                                                 //// 
.................... //// usb_get_packet() - Gets one packet that from the host.          //// 
.................... ////                    usb_kbhit() must return true before you call //// 
.................... ////                    this routine or your data may not be valid.  //// 
.................... ////                    Once usb_kbhit() returns true you want to    //// 
.................... ////                    call this as soon as possible to get data    //// 
.................... ////                    out of the endpoint buffer so the PC can     //// 
.................... ////                    start sending more data, if needed.          //// 
.................... ////                    This only receives one packet, if you are    //// 
.................... ////                    trying to receive a multi-packet message     //// 
.................... ////                    see usb_gets() in usb.c.                     //// 
.................... ////                                                                 //// 
.................... //// usb_detach() - De-attach USB from the system.                   //// 
.................... ////                                                                 //// 
.................... //// usb_attach() - Attach USB to the system.                        //// 
.................... ////                                                                 //// 
.................... //// usb_attached() - Returns TRUE if the device is attached to a    //// 
.................... ////                  USB cable.  A macro that looks at the defined  //// 
.................... ////                  connection sense pin.                          //// 
.................... ////                                                                 //// 
.................... //// usb_task() - Keeps track of connection sense, calling           //// 
.................... ////              usb_detach() and usb_attach() when needed.         //// 
.................... ////                                                                 //// 
.................... //// For more documentation on these functions read the comments at  //// 
.................... //// each function.                                                  //// 
.................... ////                                                                 //// 
.................... //// The other functions defined in this file are for use by the     //// 
.................... //// USB code, and is not meant to be used by the user.              //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                                                                 //// 
.................... //// Version History:                                                //// 
.................... ////                                                                 //// 
.................... ////   09-19-07: Fixed problems with 18F4450 family.                 //// 
.................... ////                                                                 //// 
.................... ////   07-17-07: Added 18F4450,2450 support                          //// 
.................... ////                                                                 //// 
.................... ////   07-13-07: Added 87J50 family support                          //// 
.................... ////                                                                 //// 
.................... ////   11-01-05: usb_detach(), usb_attach() and usb_init_cs()        //// 
.................... ////               changed for the better.                           //// 
.................... ////                                                                 //// 
.................... ////   10-28-05: Added usb_rx_packet_size()                          //// 
.................... ////                                                                 //// 
.................... ////   07-13-05: usb_put_packet() changed for 16bit packet sizes     //// 
.................... ////             usb_flush_in() changed for 16bit packet sizes       //// 
.................... ////             usb_get_packet() changed for 16bit packet sizes     //// 
.................... ////             usb_flush_out() changed for 16bit packet sizes      //// 
.................... ////             usb_set_configured() changed for 16bit packet sizes //// 
.................... ////                                                                 //// 
.................... ////   06-30-05: usb_tbe() added                                     //// 
.................... ////             The way endpoint 0 DTS is set has been changed.     //// 
.................... ////                                                                 //// 
.................... ////   06-20-05: Initial Release                                     //// 
.................... ////                                                                 //// 
.................... ////   05-13-05: Beta Release (Full Speed works)                     //// 
.................... ////                                                                 //// 
.................... ////   03-21-05: Initial Alpha Release                               //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2005 Custom Computer Services         //// 
.................... //// This source code may only be used by licensed users of the CCS  //// 
.................... //// C compiler.  This source code may only be distributed to other  //// 
.................... //// licensed users of the CCS C compiler.  No other use,            //// 
.................... //// reproduction or distribution is permitted without written       //// 
.................... //// permission.  Derivative programs created using this software    //// 
.................... //// in object code form are not restricted in any way.              //// 
.................... ///////////////////////////////////////////////////////////////////////// 
....................  
.................... #IFNDEF __USB_HARDWARE__ 
.................... #DEFINE __USB_HARDWARE__ 
....................  
.................... //let the USB Stack know that we are using a PIC with internal USB peripheral 
.................... #DEFINE __PIC__   1 
....................  
.................... #if ((getenv("DEVICE")=="PIC18F87J50") || (getenv("DEVICE")=="PIC18F86J55") || \ 
....................      (getenv("DEVICE")=="PIC18F86J50") || (getenv("DEVICE")=="PIC18F85J50") || \ 
....................      (getenv("DEVICE")=="PIC18F67J50") || (getenv("DEVICE")=="PIC18F66J55") || \ 
....................      (getenv("DEVICE")=="PIC18F66J50") || (getenv("DEVICE")=="PIC18F65J50")) 
....................  #define __USB_87J50__ 
....................  #define USB_TOTAL_BUFFER_SPACE  ((int16)getenv("RAM")-0x500) 
....................  #define USB_MAX_NUM_ENDPOINTS  16 
.................... #elif ((getenv("DEVICE")=="PIC18F2450") || (getenv("DEVICE")=="PIC18F4450")) 
....................  #define __USB_4450__ 
....................  #if ((USB_EP3_TX_SIZE + USB_EP3_RX_SIZE + USB_EP4_TX_SIZE + USB_EP4_RX_SIZE + \ 
....................       USB_EP5_TX_SIZE + USB_EP5_RX_SIZE + USB_EP6_TX_SIZE + USB_EP6_RX_SIZE + \ 
....................       USB_EP7_TX_SIZE + USB_EP7_RX_SIZE + USB_EP8_TX_SIZE + USB_EP8_RX_SIZE + \ 
....................       USB_EP9_TX_SIZE + USB_EP9_RX_SIZE + USB_EP10_TX_SIZE + USB_EP10_RX_SIZE + \ 
....................       USB_EP11_TX_SIZE + USB_EP11_RX_SIZE + USB_EP12_TX_SIZE +USB_EP12_RX_SIZE + \ 
....................       USB_EP13_TX_SIZE + USB_EP13_RX_SIZE + USB_EP14_TX_SIZE + USB_EP14_RX_SIZE + \ 
....................       USB_EP15_TX_SIZE + USB_EP15_RX_SIZE) > 0) 
....................    #error This driver only supports endpoints 0, 1 and 2 for this chip. 
....................  #endif 
....................  #define USB_MAX_NUM_ENDPOINTS  3 
....................  #define USB_TOTAL_BUFFER_SPACE  (0x100 - USB_MAX_NUM_ENDPOINTS*8) 
.................... #elif ((getenv("DEVICE")=="PIC18F2455") || (getenv("DEVICE")=="PIC18F2550") || \ 
....................        (getenv("DEVICE")=="PIC18F4455") || (getenv("DEVICE")=="PIC18F4550")) 
....................  #define __USB_4550__ 
....................  #define USB_TOTAL_BUFFER_SPACE  ((int16)0x300) 
....................  #define USB_MAX_NUM_ENDPOINTS  16 
.................... #else 
....................  #error Unknown PIC device, USB not supported in this library. 
.................... #endif 
....................  
.................... #ifndef USB_USE_FULL_SPEED 
....................  #define USB_USE_FULL_SPEED   TRUE 
.................... #endif 
....................  
.................... #ifndef USB_CON_SENSE_PIN 
....................  #define USB_CON_SENSE_PIN  0 
.................... #endif 
....................  
.................... #if defined(__USB_4450__) 
....................    //due to limited ram, force max packet length to 8 for this chip 
....................    #define USB_MAX_EP0_PACKET_LENGTH   8 
.................... #else 
....................    #if USB_USE_FULL_SPEED==FALSE 
....................       //slow speed requires 8byte max packet size for endpoint 0 
....................       #DEFINE USB_MAX_EP0_PACKET_LENGTH   8 
....................    #else 
....................       //for full speed you can still use 8bytes, but 64 will be faster 
....................       #DEFINE USB_MAX_EP0_PACKET_LENGTH   64 
....................    #endif 
.................... #endif 
....................  
.................... #INCLUDE <usb.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                              usb.h                                //// 
.................... ////                                                                   //// 
.................... //// Function protypes, defintions and globals used by CCS USB driver  //// 
.................... ////                                                                   //// 
.................... //// This file is part of CCS's PIC USB driver code, which includes:   //// 
.................... ////   usb_desc_*.h - an example set of config and device descriptor   //// 
.................... ////   usb.c - USB token and request handler code                      //// 
.................... ////   usb.h - definitions, prototypes and global variables            //// 
.................... ////                                                                   //// 
.................... //// The following examples are provided by CCS:                       //// 
.................... ////   ex_usb_mouse.c - A HID Mouse.                                   //// 
.................... ////   ex_usb_hid.c - A custom application using HID protocol.         //// 
.................... ////   ex_usb_kbmouse.c - A HID Mouse/Keyboard combo using multiple    //// 
.................... ////                      interfaces.                                  //// 
.................... ////   ex_usb_kbmouse.c - A HID Mouse/Keyboard combo using multiple    //// 
.................... ////                      HID Reports.                                 //// 
.................... ////   ex_usb_scope.c - A digital oscilloscope using a custom          //// 
.................... ////                    protocol requiring custom Windows drivers.     //// 
.................... ////                                                                   //// 
.................... ////                   **** DEFINITIONS *****                          //// 
.................... //// The following definitions are declared here, but can be           //// 
.................... //// overwritten in your code.  Unless needed otherwise, leave         //// 
.................... //// to default value.  If confused about a definition read the        //// 
.................... //// comments at each defintion                                        //// 
.................... ////                                                                   //// 
.................... //// USB_HID_IDLE (FALSE) - Set to TRUE if your device supports        //// 
.................... ////                            Set_Idle HID class request.  Set to    //// 
.................... ////                            False if you do not (device will       //// 
.................... ////                            send a Wrong-state if computer         //// 
.................... ////                            sends a Set_Idle / Get_Idle command)   //// 
.................... ////                            NOTE: If you set to TRUE you must      //// 
.................... ////                            provide your own code.  See            //// 
.................... ////                            usb_isr_tkn_setup_ClassInterface() in  //// 
.................... ////                            usb.c                                  //// 
.................... ////                                                                   //// 
.................... //// USB_HID_BOOT_PROTOCOL (FALSE) - Set to TRUE if your device supports   //// 
.................... ////                            Set_Protocl HID class request. Set to  //// 
.................... ////                            False if you do not (device will       //// 
.................... ////                            send a Wrong-state if computer         //// 
.................... ////                            sends a Set_Protocl / Get_Protocol     //// 
.................... ////                            command).                              //// 
.................... ////                            NOTE: If you set to TRUE you must      //// 
.................... ////                            provide your own code in the           //// 
.................... ////                            application that properly send boot    //// 
.................... ////                            or HID packets.                        //// 
.................... ////                                                                   //// 
.................... //// USB_MAX_EP0_PACKET_LENGTH (8) - Max Packet size for Endpoint 0.   //// 
.................... ////                            Only the 18Fxx5x USB peripheral can    //// 
.................... ////                            have a value larger than 8.            //// 
.................... ////                                                                   //// 
.................... //// USB_EPx_RX_ENABLE (USB_ENABLE_DISABLED) - Where x is the          //// 
.................... ////                         endpoint number. Change this define       //// 
.................... ////                         to specify what kind of transfer method   //// 
.................... ////                         this RX (PC to device) endpoint uses.     //// 
.................... ////                       Here is the list of valid transfer methods: //// 
.................... ////                             USB_ENABLE_CONTROL                    //// 
.................... ////                             USB_ENABLE_ISOCHRONOUS                //// 
.................... ////                             USB_ENABLE_BULK                       //// 
.................... ////                             USB_ENABLE_INTERRUPT                  //// 
.................... ////                             USB_ENABLE_DISABLED                   //// 
.................... ////                        Don't forget that you must specify the     //// 
.................... ////                        transfer method properly in your endpoint  //// 
.................... ////                        descriptor, too.                           //// 
.................... ////                                                                   //// 
.................... //// USB_EPx_RX_SIZE (0) - For some hardware it is important to know   //// 
.................... ////                       how much memory to reserve for receiving    //// 
.................... ////                       packets.                                    //// 
.................... ////                                                                   //// 
.................... ////  *** NOTE *** You must have both USB_EPx_RX_ENABLE defined and    //// 
.................... ////               USB_EPx_RX_SIZE defined (non 0) to enable a RX      //// 
.................... ////               endpoint.                                           //// 
.................... ////  *** NOTE *** Endpoint 0 is always enabled.                       //// 
.................... ////                                                                   //// 
.................... //// USB_EPx_TX_ENABLE (USB_ENABLE_DISABLED) - Where x is the          //// 
.................... ////                         endpoint number. Change this define       //// 
.................... ////                         to specify what kind of transfer method   //// 
.................... ////                         this TX (device to PC) endpoint uses.     //// 
.................... ////                       Here is the list of valid transfer methods: //// 
.................... ////                             USB_ENABLE_CONTROL                    //// 
.................... ////                             USB_ENABLE_ISOCHRONOUS                //// 
.................... ////                             USB_ENABLE_BULK                       //// 
.................... ////                             USB_ENABLE_INTERRUPT                  //// 
.................... ////                             USB_ENABLE_DISABLED                   //// 
.................... ////                        Don't forget that you must specify the     //// 
.................... ////                        transfer method properly in your endpoint  //// 
.................... ////                        descriptor, too.                           //// 
.................... ////                                                                   //// 
.................... //// USB_EPx_TX_SIZE (0) - For some hardware it is important to know   //// 
.................... ////                       how much memory to reserve for transmitting //// 
.................... ////                       packets.                                    //// 
.................... ////                                                                   //// 
.................... ////  *** NOTE *** You must have both USB_EPx_TX_ENABLE defined and    //// 
.................... ////               USB_EPx_TX_SIZE defined (non 0) to enable a TX      //// 
.................... ////               endpoint.                                           //// 
.................... ////                                                                   //// 
.................... ////                                                                   //// 
.................... //// USB_HID_DEVICE (TRUE) - HID devices require extra code to handle  //// 
.................... ////                         HID requests.  You can disable to save    //// 
.................... ////                         ROM space if you are not using a HID      //// 
.................... ////                         device.  If you are not using a HID       //// 
.................... ////                         device you must provide your own O/S      //// 
.................... ////                         (Windows) driver.                         //// 
.................... ////                                                                   //// 
.................... //// The other definitions should not be changed.                      //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... //// Version History:                                                  //// 
.................... ////                                                                   //// 
.................... //// July 13th, 2005:                                                  //// 
.................... ////  usb_ep_tx_size[] and usb_ep_rx_size[] changed to 16bits          //// 
.................... ////                                                                   //// 
.................... //// June 20th, 2005:                                                  //// 
.................... ////  Initial 18fxx5x release                                          //// 
.................... ////                                                                   //// 
.................... //// May 13th, 2005:                                                   //// 
.................... ////  Beta release, only works with 18Fxx5x hardware layer.            //// 
.................... ////  Now supports multiple interfaces (many defines in descriptors    //// 
.................... ////   will have to be changed, see examples)                          //// 
.................... ////                                                                   //// 
.................... //// Mar 21st, 2005:                                                   //// 
.................... ////  Initial Alpha Release with PIC18Fxx5x support.  (ONLY TESTED     //// 
.................... ////   WITH 18F4550)                                                   //// 
.................... ////  usb_gets() and usb_puts() changed (see usb.c)                    //// 
.................... ////                                                                   //// 
.................... //// June 24th, 2004:                                                  //// 
.................... ////  Optimization and cleanup.                                        //// 
.................... ////                The following definitions changed:                 //// 
.................... ////  USB_EPx_TX_ENABLE and USB_EPx_RX_ENABLE have changed. See usb.h  //// 
.................... ////  USB_CONFIG_DESCRIPTORS[] removed                                 //// 
.................... ////  USB_CONFIG_DESC_LEN changed to USB_DESC_CONFIG_LEN               //// 
.................... ////  USB_INTERFACE_DESC_LEN changed to USB_DESC_INTERFACE_LEN         //// 
.................... ////  USB_CLASS_DESC_LEN changed to USB_DESC_CLASS_LEN                 //// 
.................... ////  USB_ENDPOINT_DESC_LEN changed to USB_DESC_ENDPOINT_LEN           //// 
.................... ////  USB_CONFIG_DESC_KEY changed to USB_DESC_CONFIG_TYPE              //// 
.................... ////  USB_INTERFACE_DESC_KEY changed to USB_DESC_INTERFACE_TYPE        //// 
.................... ////  USB_CLASS_DESC_KEY changed to USB_DESC_CLASS_TYPE                //// 
.................... ////  USB_ENDPOINT_DESC_KEY changed to USB_DESC_ENDPOINT_TYPE          //// 
.................... ////  USB_STRING_X[] arrays removed, see USB_STRING_DESC[] and         //// 
.................... ////                                 USB_STRING_DESC_OFFSET[]          //// 
.................... ////  dev_req, curr_config, status_device and getdesc_type global      //// 
.................... ////        variables moved into struct USB_stack_status               //// 
.................... ////                                                                   //// 
.................... //// October 15th, 2003: Support for boot protocol added.              //// 
.................... ////         Set USB_HID_BOOT_PROTOCOL to TRUE to support this.        //// 
.................... ////         The array hid_protocol[] saves which protocol mode each   //// 
.................... ////         interface is in.  It is your applications job to send     //// 
.................... ////         data that either fit the boot protocol or HID protocol.   //// 
.................... ////                                                                   //// 
.................... //// May 6th, 2003: Fixed a potential stack overflow using PCM         //// 
.................... ////                                                                   //// 
.................... //// October 29th, 2002: New definition added to USB_STATES            //// 
.................... ////                                                                   //// 
.................... //// August 2nd, 2002: Initial Public Release                          //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2005 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS    //// 
.................... //// C compiler.  This source code may only be distributed to other    //// 
.................... //// licensed users of the CCS C compiler.  No other use,              //// 
.................... //// reproduction or distribution is permitted without written         //// 
.................... //// permission.  Derivative programs created using this software      //// 
.................... //// in object code form are not restricted in any way.                //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
....................  
.................... #IFNDEF __USB_PROTOTYPES__ 
.................... #DEFINE __USB_PROTOTYPES__ 
....................  
.................... #IFNDEF USB_HID_BOOT_PROTOCOL 
....................    #DEFINE USB_HID_BOOT_PROTOCOL FALSE 
.................... #ENDIF 
....................  
.................... #IFNDEF USB_HID_IDLE 
....................    #DEFINE USB_HID_IDLE FALSE 
.................... #ENDIF 
....................  
.................... //should the compiler add the extra HID handler code?  Defaults to yes. 
.................... #IFNDEF USB_HID_DEVICE 
....................    #DEFINE USB_HID_DEVICE TRUE 
.................... #ENDIF 
....................  
.................... #IFNDEF USB_CDC_DEVICE 
....................    #DEFINE USB_CDC_DEVICE FALSE 
.................... #ENDIF 
....................  
.................... #ifndef USB_OPT_FOR_ROM 
....................    #define USB_OPT_FOR_ROM TRUE  //set to false to opt for less RAM, true to opt for less ROM 
.................... #endif 
....................  
.................... #IFNDEF USB_MAX_EP0_PACKET_LENGTH 
....................   #DEFINE USB_MAX_EP0_PACKET_LENGTH 8 
.................... #ENDIF 
....................  
.................... //CCS only supports one configuration at this time 
.................... #DEFINE USB_NUM_CONFIGURATIONS 1 //DO NOT CHANGE 
....................  
.................... //PID values for tokens (see page 48 of USB Complete ed.1) 
.................... #define PID_IN       0x09  //device to host transactions 
.................... #define PID_OUT      0x01  //host to device transactions 
.................... #define PID_SETUP    0x0D  //host to device setup transaction 
.................... #define PID_ACK      0x02  //receiver accepts error-free data packet 
.................... #define PID_DATA0    0x03  //data packet with even sync bit 
.................... #define PID_SOF      0x05  //start of framer marker and frame number 
.................... #define PID_NAK      0x0A  //receiver can't accept data or sender cant send data or has no data to transmit 
.................... #define PID_DATA1    0x0B  //data packet with odd sync bit 
.................... #define PID_PRE      0x0C  //preamble issued by host.  enables downstream traffic to low-speed device 
.................... #define PID_STALL    0x0E  //a control request isnt supported or the endpoint is halted 
....................  
.................... //Key which identifies descritpors 
.................... #DEFINE USB_DESC_DEVICE_TYPE     0x01  //#DEFINE USB_DEVICE_DESC_KEY      0x01 
.................... #DEFINE USB_DESC_CONFIG_TYPE     0x02  //#DEFINE USB_CONFIG_DESC_KEY      0x02 
.................... #DEFINE USB_DESC_STRING_TYPE     0x03  //#DEFINE USB_STRING_DESC_KEY      0x03 
.................... #DEFINE USB_DESC_INTERFACE_TYPE  0x04  //#DEFINE USB_INTERFACE_DESC_KEY   0x04 
.................... #DEFINE USB_DESC_ENDPOINT_TYPE   0x05  //#DEFINE USB_ENDPOINT_DESC_KEY    0x05 
.................... #DEFINE USB_DESC_CLASS_TYPE      0x21  //#DEFINE USB_CLASS_DESC_KEY       0x21 
.................... #DEFINE USB_DESC_HIDREPORT_TYPE  0x22 
....................  
.................... //The length of each descriptor 
.................... #DEFINE USB_DESC_DEVICE_LEN      18 //#DEFINE USB_DEVICE_DESC_LEN      18 
.................... #DEFINE USB_DESC_CONFIG_LEN      9  //#DEFINE USB_CONFIG_DESC_LEN      9 
.................... #DEFINE USB_DESC_INTERFACE_LEN   9  //#DEFINE USB_INTERFACE_DESC_LEN   9 
.................... #DEFINE USB_DESC_CLASS_LEN       9  //#DEFINE USB_CLASS_DESC_LEN       9 
.................... #DEFINE USB_DESC_ENDPOINT_LEN    7  //#DEFINE USB_ENDPOINT_DESC_LEN    7 
....................  
.................... //Standard USB Setup bRequest Codes 
.................... #define USB_STANDARD_REQUEST_GET_STATUS         0x00 
.................... #define USB_STANDARD_REQUEST_CLEAR_FEATURE      0x01 
.................... #define USB_STANDARD_REQUEST_SET_FEATURE        0x03 
.................... #define USB_STANDARD_REQUEST_SET_ADDRESS        0x05 
.................... #define USB_STANDARD_REQUEST_GET_DESCRIPTOR     0x06 
.................... #define USB_STANDARD_REQUEST_SET_DESCRIPTOR     0x07 
.................... #define USB_STANDARD_REQUEST_GET_CONFIGURATION  0x08 
.................... #define USB_STANDARD_REQUEST_SET_CONFIGURATION  0x09 
.................... #define USB_STANDARD_REQUEST_GET_INTERFACE      0x0A 
.................... #define USB_STANDARD_REQUEST_SET_INTERFACE      0x0B 
.................... #define USB_STANDARD_REQUEST_SYNCH_FRAME        0x0C 
....................  
.................... //HID Class Setup bRequest Codes 
.................... #define USB_HID_REQUEST_GET_REPORT     0x01 
.................... #define USB_HID_REQUEST_GET_IDLE       0x02 
.................... #define USB_HID_REQUEST_GET_PROTOCOL   0x03 
.................... #define USB_HID_REQUEST_SET_REPORT     0x09 
.................... #define USB_HID_REQUEST_SET_IDLE       0x0A 
.................... #define USB_HID_REQUEST_SET_PROTOCOL   0x0B 
....................  
.................... //types of endpoints as defined in the descriptor 
.................... #define USB_ENDPOINT_TYPE_CONTROL      0x00 
.................... #define USB_ENDPOINT_TYPE_ISOCHRONOUS  0x01 
.................... #define USB_ENDPOINT_TYPE_BULK         0x02 
.................... #define USB_ENDPOINT_TYPE_INTERRUPT    0x03 
....................  
.................... //types of endpoints used internally in this api 
.................... #define USB_ENABLE_DISABLED     0 
.................... #define USB_ENABLE_BULK         0x01 
.................... #define USB_ENABLE_ISOCHRONOUS  0x02 
.................... #define USB_ENABLE_INTERRUPT    0x03 
.................... #define USB_ENABLE_CONTROL      0x04 
....................  
.................... //// DO NOT CHANGE THE FOLLOWING VALUES: 
....................  
.................... enum USB_STATES {GET_DESCRIPTOR=1,SET_ADDRESS=2,NONE=0}; 
....................  
.................... enum USB_DTS_BIT {USB_DTS_DATA1=1, USB_DTS_TOGGLE=2, USB_DTS_DATA0=0, 
....................                    USB_DTS_STALL=3, USB_DTS_USERX=4}; 
....................  
.................... enum USB_GETDESC_TYPES {USB_GETDESC_CONFIG_TYPE=0,USB_GETDESC_HIDREPORT_TYPE=1,USB_GETDESC_STRING_TYPE=2,USB_GETDESC_DEVICE_TYPE=3}; 
....................  
.................... #if USB_OPT_FOR_ROM 
.................... struct { 
....................    USB_STATES dev_req;   //what did the last setup token set us up to do?.  init at none 
....................    int  curr_config;  //our current config.  start at none/powered (NOT THAT THIS LIMITS US TO 3 CONFIGURATIONS) 
....................    int status_device; //Holds our state for Set_Feature and Clear_Feature 
....................    USB_GETDESC_TYPES getdesc_type;   //which get_descriptor() we are handling 
.................... } USB_stack_status; 
.................... #else 
.................... struct { 
....................    USB_STATES dev_req:2;   //what did the last setup token set us up to do?.  init at none 
....................    int  Curr_config:2;  //our current config.  start at none/powered (NOT THAT THIS LIMITS US TO 3 CONFIGURATIONS) 
....................    int status_device:2; //Holds our state for Set_Feature and Clear_Feature 
....................    USB_GETDESC_TYPES getdesc_type:2;   //which get_descriptor() we are handling 
.................... } USB_stack_status; 
.................... #endif 
....................  
.................... int16 __usb_kbhit_status; 
....................  
.................... /// *** User function prototypes 
.................... void usb_wait_for_enumeration(void); 
.................... int1 usb_unermated(void); 
.................... int8 usb_gets(int8 endpoint, int8 * ptr, int16 max, int16 timeout); 
.................... int1 usb_puts(int8 endpoint, int8 * ptr, int16 len, int8 timeout); 
....................  
.................... /// *** Token and request hanlder function prototypes 
.................... void usb_token_reset(); 
....................  
.................... void usb_put_0len_0(void); 
.................... void usb_request_send_response(int len);   //always sends usb_ep0_rx_buffer[] to endpoint 0 with a toggle of DATA 
....................  
.................... void usb_match_registers(int8 endpoint, int16 *status, int16 *buffer, int8 *size); 
....................  
.................... void usb_isr_tok_in_dne(int8 endpoint); 
.................... void usb_isr_tok_out_dne(int8 endpoint); 
.................... void usb_isr_tok_setup_dne(void); 
....................  
.................... void usb_isr_tkn_setup_StandardEndpoint(void); 
.................... void usb_isr_tkn_setup_StandardDevice(void); 
.................... void usb_isr_tkn_setup_StandardInterface(void); 
....................  
.................... #IF USB_HID_DEVICE 
....................    void usb_isr_tkn_setup_ClassInterface(void); 
.................... #ENDIF 
....................  
.................... void usb_Get_Descriptor(void); 
.................... void usb_copy_desc_seg_to_ep(void); 
....................  
.................... void usb_finish_set_address(void); 
....................  
.................... //*** ENABLE RX ENDPOINTS AND BUFFERS 
....................  
.................... //--------- endpoint 0 defines ---------- 
.................... #define USB_EP0_TX_ENABLE  USB_ENABLE_CONTROL 
.................... #define USB_EP0_RX_ENABLE  USB_ENABLE_CONTROL 
.................... #define USB_EP0_RX_SIZE    USB_MAX_EP0_PACKET_LENGTH  //endpoint 0 is setup, and should always be the MAX_PACKET_LENGTH.  Slow speed specifies 8 
.................... #define USB_EP0_TX_SIZE    USB_MAX_EP0_PACKET_LENGTH  //endpoint 0 is setup, and should always be the MAX_PACKET_LENGTH.  Slow speed specifies 8 
....................  
.................... //--------- endpoint 1 defines ---------- 
.................... #ifndef USB_EP1_TX_ENABLE 
....................  #define USB_EP1_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP1_RX_ENABLE 
....................  #define USB_EP1_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP1_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP1_RX_SIZE 
....................   #undef USB_EP1_RX_SIZE 
....................  #endif 
....................  #define USB_EP1_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP1_RX_SIZE 
....................   #error You enabled EP1 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP1_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP1_TX_SIZE 
....................   #undef USB_EP1_TX_SIZE 
....................  #endif 
....................  #define USB_EP1_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP1_TX_SIZE 
....................   #error You enabled EP1 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 2 defines ---------- 
.................... #ifndef USB_EP2_TX_ENABLE 
....................  #define USB_EP2_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP2_RX_ENABLE 
....................  #define USB_EP2_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP2_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP2_RX_SIZE 
....................   #undef USB_EP2_RX_SIZE 
....................  #endif 
....................  #define USB_EP2_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP2_RX_SIZE 
....................   #error You enabled EP2 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP2_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP2_TX_SIZE 
....................   #undef USB_EP2_TX_SIZE 
....................  #endif 
....................  #define USB_EP2_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP2_TX_SIZE 
....................   #error You enabled EP2 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 3 defines ---------- 
.................... #ifndef USB_EP3_TX_ENABLE 
....................  #define USB_EP3_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP3_RX_ENABLE 
....................  #define USB_EP3_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP3_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP3_RX_SIZE 
....................   #undef USB_EP3_RX_SIZE 
....................  #endif 
....................  #define USB_EP3_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP3_RX_SIZE 
....................   #error You enabled EP3 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP3_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP3_TX_SIZE 
....................   #undef USB_EP3_TX_SIZE 
....................  #endif 
....................  #define USB_EP3_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP3_TX_SIZE 
....................   #error You enabled EP3 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 4 defines ---------- 
.................... #ifndef USB_EP4_TX_ENABLE 
....................  #define USB_EP4_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP4_RX_ENABLE 
....................  #define USB_EP4_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP4_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP4_RX_SIZE 
....................   #undef USB_EP4_RX_SIZE 
....................  #endif 
....................  #define USB_EP4_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP4_RX_SIZE 
....................   #error You enabled EP4 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP4_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP4_TX_SIZE 
....................   #undef USB_EP4_TX_SIZE 
....................  #endif 
....................  #define USB_EP4_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP4_TX_SIZE 
....................   #error You enabled EP4 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 5 defines ---------- 
.................... #ifndef USB_EP5_TX_ENABLE 
....................  #define USB_EP5_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP5_RX_ENABLE 
....................  #define USB_EP5_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP5_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP5_RX_SIZE 
....................   #undef USB_EP5_RX_SIZE 
....................  #endif 
....................  #define USB_EP5_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP5_RX_SIZE 
....................   #error You enabled EP5 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP5_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP5_TX_SIZE 
....................   #undef USB_EP5_TX_SIZE 
....................  #endif 
....................  #define USB_EP5_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP5_TX_SIZE 
....................   #error You enabled EP5 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 6 defines ---------- 
.................... #ifndef USB_EP6_TX_ENABLE 
....................  #define USB_EP6_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP6_RX_ENABLE 
....................  #define USB_EP6_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP6_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP6_RX_SIZE 
....................   #undef USB_EP6_RX_SIZE 
....................  #endif 
....................  #define USB_EP6_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP6_RX_SIZE 
....................   #error You enabled EP6 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP6_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP6_TX_SIZE 
....................   #undef USB_EP6_TX_SIZE 
....................  #endif 
....................  #define USB_EP6_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP6_TX_SIZE 
....................   #error You enabled EP6 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 7 defines ---------- 
.................... #ifndef USB_EP7_TX_ENABLE 
....................  #define USB_EP7_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP7_RX_ENABLE 
....................  #define USB_EP7_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP7_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP7_RX_SIZE 
....................   #undef USB_EP7_RX_SIZE 
....................  #endif 
....................  #define USB_EP7_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP7_RX_SIZE 
....................   #error You enabled EP7 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP7_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP7_TX_SIZE 
....................   #undef USB_EP7_TX_SIZE 
....................  #endif 
....................  #define USB_EP7_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP7_TX_SIZE 
....................   #error You enabled EP7 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 8 defines ---------- 
.................... #ifndef USB_EP8_TX_ENABLE 
....................  #define USB_EP8_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP8_RX_ENABLE 
....................  #define USB_EP8_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP8_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP8_RX_SIZE 
....................   #undef USB_EP8_RX_SIZE 
....................  #endif 
....................  #define USB_EP8_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP8_RX_SIZE 
....................   #error You enabled EP8 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP8_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP8_TX_SIZE 
....................   #undef USB_EP8_TX_SIZE 
....................  #endif 
....................  #define USB_EP8_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP8_TX_SIZE 
....................   #error You enabled EP8 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 9 defines ---------- 
.................... #ifndef USB_EP9_TX_ENABLE 
....................  #define USB_EP9_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP9_RX_ENABLE 
....................  #define USB_EP9_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP9_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP9_RX_SIZE 
....................   #undef USB_EP9_RX_SIZE 
....................  #endif 
....................  #define USB_EP9_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP9_RX_SIZE 
....................   #error You enabled EP9 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP9_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP9_TX_SIZE 
....................   #undef USB_EP9_TX_SIZE 
....................  #endif 
....................  #define USB_EP9_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP9_TX_SIZE 
....................   #error You enabled EP9 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 10 defines ---------- 
.................... #ifndef USB_EP10_TX_ENABLE 
....................  #define USB_EP10_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP10_RX_ENABLE 
....................  #define USB_EP10_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP10_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP10_RX_SIZE 
....................   #undef USB_EP10_RX_SIZE 
....................  #endif 
....................  #define USB_EP10_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP10_RX_SIZE 
....................   #error You enabled EP10 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP10_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP10_TX_SIZE 
....................   #undef USB_EP10_TX_SIZE 
....................  #endif 
....................  #define USB_EP10_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP10_TX_SIZE 
....................   #error You enabled EP10 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 11 defines ---------- 
.................... #ifndef USB_EP11_TX_ENABLE 
....................  #define USB_EP11_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP11_RX_ENABLE 
....................  #define USB_EP11_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP11_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP11_RX_SIZE 
....................   #undef USB_EP11_RX_SIZE 
....................  #endif 
....................  #define USB_EP11_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP11_RX_SIZE 
....................   #error You enabled EP11 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP11_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP11_TX_SIZE 
....................   #undef USB_EP11_TX_SIZE 
....................  #endif 
....................  #define USB_EP11_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP11_TX_SIZE 
....................   #error You enabled EP11 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 12 defines ---------- 
.................... #ifndef USB_EP12_TX_ENABLE 
....................  #define USB_EP12_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP12_RX_ENABLE 
....................  #define USB_EP12_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP12_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP12_RX_SIZE 
....................   #undef USB_EP12_RX_SIZE 
....................  #endif 
....................  #define USB_EP12_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP12_RX_SIZE 
....................   #error You enabled EP12 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP12_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP12_TX_SIZE 
....................   #undef USB_EP12_TX_SIZE 
....................  #endif 
....................  #define USB_EP12_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP12_TX_SIZE 
....................   #error You enabled EP12 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 13 defines ---------- 
.................... #ifndef USB_EP13_TX_ENABLE 
....................  #define USB_EP13_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP13_RX_ENABLE 
....................  #define USB_EP13_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP13_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP13_RX_SIZE 
....................   #undef USB_EP13_RX_SIZE 
....................  #endif 
....................  #define USB_EP13_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP13_RX_SIZE 
....................   #error You enabled EP13 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP13_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP13_TX_SIZE 
....................   #undef USB_EP13_TX_SIZE 
....................  #endif 
....................  #define USB_EP13_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP13_TX_SIZE 
....................   #error You enabled EP13 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 14 defines ---------- 
.................... #ifndef USB_EP14_TX_ENABLE 
....................  #define USB_EP14_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP14_RX_ENABLE 
....................  #define USB_EP14_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP14_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP14_RX_SIZE 
....................   #undef USB_EP14_RX_SIZE 
....................  #endif 
....................  #define USB_EP14_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP14_RX_SIZE 
....................   #error You enabled EP14 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP14_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP14_TX_SIZE 
....................   #undef USB_EP14_TX_SIZE 
....................  #endif 
....................  #define USB_EP14_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP14_TX_SIZE 
....................   #error You enabled EP14 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 15 defines ---------- 
.................... #ifndef USB_EP15_TX_ENABLE 
....................  #define USB_EP15_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP15_RX_ENABLE 
....................  #define USB_EP15_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP15_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP15_RX_SIZE 
....................   #undef USB_EP15_RX_SIZE 
....................  #endif 
....................  #define USB_EP15_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP15_RX_SIZE 
....................   #error You enabled EP15 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP15_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP15_TX_SIZE 
....................   #undef USB_EP15_TX_SIZE 
....................  #endif 
....................  #define USB_EP15_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP15_TX_SIZE 
....................   #error You enabled EP15 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... const int8 usb_ep_tx_type[16]={ 
....................   USB_EP0_TX_ENABLE, USB_EP1_TX_ENABLE, USB_EP2_TX_ENABLE, 
....................   USB_EP3_TX_ENABLE, USB_EP4_TX_ENABLE, USB_EP5_TX_ENABLE, 
....................   USB_EP6_TX_ENABLE, USB_EP7_TX_ENABLE, USB_EP8_TX_ENABLE, 
....................   USB_EP9_TX_ENABLE, USB_EP10_TX_ENABLE, USB_EP11_TX_ENABLE, 
....................   USB_EP12_TX_ENABLE, USB_EP13_TX_ENABLE, USB_EP14_TX_ENABLE, 
....................   USB_EP15_TX_ENABLE 
.................... }; 
....................  
.................... const int8 usb_ep_rx_type[16]={ 
....................   USB_EP0_RX_ENABLE, USB_EP1_RX_ENABLE, USB_EP2_RX_ENABLE, 
....................   USB_EP3_RX_ENABLE, USB_EP4_RX_ENABLE, USB_EP5_RX_ENABLE, 
....................   USB_EP6_RX_ENABLE, USB_EP7_RX_ENABLE, USB_EP8_RX_ENABLE, 
....................   USB_EP9_RX_ENABLE, USB_EP10_RX_ENABLE, USB_EP11_RX_ENABLE, 
....................   USB_EP12_RX_ENABLE, USB_EP13_RX_ENABLE, USB_EP14_RX_ENABLE, 
....................   USB_EP15_RX_ENABLE 
.................... }; 
....................  
.................... const int16 usb_ep_tx_size[16]={ 
....................   USB_EP0_TX_SIZE, USB_EP1_TX_SIZE, USB_EP2_TX_SIZE, 
....................   USB_EP3_TX_SIZE, USB_EP4_TX_SIZE, USB_EP5_TX_SIZE, 
....................   USB_EP6_TX_SIZE, USB_EP7_TX_SIZE, USB_EP8_TX_SIZE, 
....................   USB_EP9_TX_SIZE, USB_EP10_TX_SIZE, USB_EP11_TX_SIZE, 
....................   USB_EP12_TX_SIZE, USB_EP13_TX_SIZE, USB_EP14_TX_SIZE, 
....................   USB_EP15_TX_SIZE 
.................... }; 
....................  
.................... const int16 usb_ep_rx_size[16]={ 
....................   USB_EP0_RX_SIZE, USB_EP1_RX_SIZE, USB_EP2_RX_SIZE, 
....................   USB_EP3_RX_SIZE, USB_EP4_RX_SIZE, USB_EP5_RX_SIZE, 
....................   USB_EP6_RX_SIZE, USB_EP7_RX_SIZE, USB_EP8_RX_SIZE, 
....................   USB_EP9_RX_SIZE, USB_EP10_RX_SIZE, USB_EP11_RX_SIZE, 
....................   USB_EP12_RX_SIZE, USB_EP13_RX_SIZE, USB_EP14_RX_SIZE, 
....................   USB_EP15_RX_SIZE 
.................... }; 
....................  
.................... #ENDIF 
....................  
....................  
.................... #define USB_BUFFER_NEEDED (USB_EP0_TX_SIZE+USB_EP0_RX_SIZE+USB_EP1_TX_SIZE+USB_EP1_RX_SIZE+USB_EP2_TX_SIZE+USB_EP2_RX_SIZE+USB_EP3_TX_SIZE+USB_EP3_RX_SIZE+USB_EP4_TX_SIZE+USB_EP4_RX_SIZE+USB_EP5_TX_SIZE+USB_EP5_RX_SIZE+USB_EP6_TX_SIZE+USB_EP6_RX_SIZE+USB_EP7_TX_SIZE+USB_EP7_RX_SIZE+USB_EP8_TX_SIZE+USB_EP8_RX_SIZE+USB_EP9_TX_SIZE+USB_EP9_RX_SIZE+USB_EP10_TX_SIZE+USB_EP10_RX_SIZE+USB_EP11_TX_SIZE+USB_EP11_RX_SIZE+USB_EP12_TX_SIZE+USB_EP12_RX_SIZE+USB_EP13_TX_SIZE+USB_EP13_RX_SIZE+USB_EP14_TX_SIZE+USB_EP14_RX_SIZE+USB_EP15_TX_SIZE+USB_EP15_RX_SIZE) 
....................  
.................... #if (USB_BUFFER_NEEDED > USB_TOTAL_BUFFER_SPACE) 
....................  #error You are trying to allocate more memory for endpoints than the PIC can handle 
.................... #endif 
....................  
.................... #if defined(__USB_4450__) 
....................  #reserve 0x400:0x4FF 
.................... #else 
....................  #reserve 0x400:0x4FF+USB_BUFFER_NEEDED 
.................... #endif 
....................  
.................... #define debug_usb(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z) 
.................... //#define debug_usb printf 
.................... //#define debug_putc putc_tbe 
.................... #define debug_display_ram(x,y) 
.................... /* 
.................... void debug_display_ram(int8 len, int8 *ptr) { 
....................    int8 max=16; 
....................    debug_usb(debug_putc,"%U - ",len); 
....................    if (max>len) {max=len;} 
....................    while(max--) { 
....................       debug_usb(debug_putc,"%X",*ptr); 
....................       len--; 
....................       ptr++; 
....................    } 
....................    if (len) {debug_usb(debug_putc,"...");} 
.................... } 
.................... */ 
....................  
.................... //if you are worried that the PIC is not receiving packets because a bug in the 
.................... //DATA0/DATA1 synch code, you can set this to TRUE to ignore the DTS on 
.................... //receiving. 
.................... #ifndef USB_IGNORE_RX_DTS 
....................  #define USB_IGNORE_RX_DTS FALSE 
.................... #endif 
....................  
.................... #ifndef USB_IGNORE_TX_DTS 
....................  #define USB_IGNORE_TX_DTS FALSE 
.................... #endif 
....................  
.................... //if you enable this it will keep a counter of the 6 possible errors the 
.................... //pic can detect.  disabling this will save you ROM, RAM and execution time. 
.................... #ifndef USB_USE_ERROR_COUNTER 
....................    #define USB_USE_ERROR_COUNTER FALSE 
.................... #endif 
....................  
.................... #define USB_PING_PONG_MODE_OFF   0  //no ping pong 
.................... #define USB_PING_PONG_MODE_E0    1  //ping pong endpoint 0 only 
.................... #define USB_PING_PONG_MODE_ON    2  //ping pong all endpoints 
....................  
.................... //NOTE - PING PONG MODE IS NOT SUPPORTED BY CCS! 
.................... #ifndef USB_PING_PONG_MODE 
....................    #define USB_PING_PONG_MODE USB_PING_PONG_MODE_OFF 
.................... #endif 
....................  
.................... #if USB_USE_ERROR_COUNTER 
....................    int ERROR_COUNTER[6]; 
.................... #endif 
....................  
.................... //---pic18fxx5x memory locations 
.................... #if defined(__USB_4550__) || defined(__USB_4450__) 
....................    #byte UFRML   =  0xF66 
....................    #byte UFRMH   =  0xF67 
....................    #byte UIR     =  0xF68 
....................    #byte UIE     =  0xF69 
....................    #byte UEIR    =  0xF6A 
....................    #byte UEIE    =  0xF6B 
....................    #byte USTAT   =  0xF6C 
....................    #byte UCON    =  0xF6D 
....................    #byte UADDR   =  0xF6E 
....................    #byte UCFG    =  0xF6F 
....................    #define  UEP0_LOC 0xF70 
.................... #else 
....................    #byte UFRML   =  0xF60 
....................    #byte UFRMH   =  0xF61 
....................    #byte UIR     =  0xF62 
....................    #byte UIE     =  0xF5C 
....................    #byte UEIR    =  0xF63 
....................    #byte UEIE    =  0xF5D 
....................    #byte USTAT   =  0xF64 
....................    #byte UCON    =  0xF65 
....................    #byte UADDR   =  0xF5E 
....................    #byte UCFG    =  0xF5F 
....................    #define  UEP0_LOC 0xF4C 
.................... #endif 
....................  
.................... #byte UEP0    =  UEP0_LOC 
....................  
.................... #if defined(__USB_4450__) 
....................  //#define USB_BUFFER (0x400 + (USB_MAX_NUM_ENDPOINTS*8)) //compiler doesnt support this 
....................  #if USB_MAX_NUM_ENDPOINTS==3 
....................   #define USB_BUFFER 0x418   //if you have an old compiler you will need to use this 
....................  #else 
....................   #error Define USB_BUFFER for the number of endpoints you have (0x400 + NUM*0x08) 
....................  #endif 
.................... #else 
....................  #define USB_BUFFER 0x500 
.................... #endif 
....................  
.................... #byte BD0STAT  =  0x400 
.................... #byte BD0CNT  =  0x401 
.................... #byte BD0ADRL  =  0x402 
.................... #byte BD0ADRJ  =  0x403 
....................  
.................... #define BD0STAT_LOC 0x400 
.................... #define BD0CNT_LOC  0x401 
.................... #define BD0ADRL_LOC 0x402 
.................... #define BD0ADRH_LOC 0x403 
....................  
.................... #define UEP(x) *(UEP0_LOC+x) 
....................  
.................... #BIT UIR_SOF = UIR.6 
.................... #BIT UIR_STALL = UIR.5 
.................... #BIT UIR_IDLE = UIR.4 
.................... #BIT UIR_TRN = UIR.3 
.................... #BIT UIR_ACTV = UIR.2 
.................... #BIT UIR_UERR = UIR.1 
.................... #BIT UIR_URST = UIR.0 
....................  
.................... #BIT UIE_SOF = UIE.6 
.................... #BIT UIE_STALL = UIE.5 
.................... #BIT UIE_IDLE = UIE.4 
.................... #BIT UIE_TRN = UIE.3 
.................... #BIT UIE_ACTV = UIE.2 
.................... #BIT UIE_UERR = UIE.1 
.................... #BIT UIE_URST = UIE.0 
....................  
.................... #bit UCON_PBRST=UCON.6 
.................... #bit UCON_SE0=UCON.5 
.................... #bit UCON_PKTDIS=UCON.4 
.................... #bit UCON_USBEN=UCON.3 
.................... #bit UCON_RESUME=UCON.2 
.................... #bit UCON_SUSPND=UCON.1 
....................  
.................... #if (USB_PING_PONG_MODE==USB_PING_PONG_MODE_OFF) 
....................  #define EP_BDxST_O(x)    *(BD0STAT_LOC + x*8) 
....................  #define EP_BDxCNT_O(x)    *(BD0CNT_LOC + x*8) 
....................  #define EP_BDxADR_O(x)   *(int16 *)(BD0ADRL_LOC + x*8) 
....................  #define EP_BDxST_I(x)    *(BD0STAT_LOC + 4 + x*8) 
....................  #define EP_BDxCNT_I(x)    *(BD0CNT_LOC + 4 + x*8) 
....................  #define EP_BDxADR_I(x)   *(int16 *)(BD0ADRL_LOC + 4 + x*8) 
.................... #else 
.................... #error Right now this driver only supports no ping pong 
.................... #endif 
....................  
.................... //See UEPn (0xF70-0xF7F) 
.................... #define ENDPT_DISABLED   0x00   //endpoint not used 
.................... #define ENDPT_IN_ONLY   0x02    //endpoint supports IN transactions only 
.................... #define ENDPT_OUT_ONLY   0x04    //endpoint supports OUT transactions only 
.................... #define ENDPT_CONTROL   0x06    //Supports IN, OUT and CONTROL transactions - Only use with EP0 
.................... #define ENDPT_NON_CONTROL 0x0E  //Supports both IN and OUT transactions 
....................  
.................... //Define the states that the USB interface can be in 
.................... enum {USB_STATE_DETACHED=0, USB_STATE_ATTACHED=1, USB_STATE_POWERED=2, USB_STATE_DEFAULT=3, 
....................     USB_STATE_ADDRESS=4, USB_STATE_CONFIGURED=5} usb_state=0; 
....................  
.................... //--BDendST has their PIDs upshifed 2 
.................... #define USB_PIC_PID_IN       0x24  //device to host transactions 
.................... #define USB_PIC_PID_OUT      0x04  //host to device transactions 
.................... #define USB_PIC_PID_SETUP    0x34  //host to device setup transaction 
....................  
.................... #define USTAT_IN_E0        4 
.................... #define USTAT_OUT_SETUP_E0 0 
....................  
.................... #define __USB_UIF_RESET    0x01 
.................... #define __USB_UIF_ERROR    0x02 
.................... #define __USB_UIF_ACTIVE   0x04 
.................... #define __USB_UIF_TOKEN    0x08 
.................... #define __USB_UIF_IDLE     0x10 
.................... #define __USB_UIF_STALL    0x20 
.................... #define __USB_UIF_SOF      0x40 
....................  
.................... #if USB_USE_ERROR_COUNTER 
....................  #define STANDARD_INTS 0x3F 
.................... #else 
....................  #define STANDARD_INTS 0x3D 
.................... #endif 
....................  
.................... #define __USB_UCFG_UTEYE   0x80 
.................... #if defined(__USB_4550__) 
....................  #define __USB_UCFG_UOEMON  0x40 
.................... #endif 
.................... #define __USB_UCFG_UPUEN   0x10 
.................... #define __USB_UCFG_UTRDIS  0x08 
.................... #define __USB_UCFG_FSEN    0x04 
....................  
.................... #if USB_USE_FULL_SPEED 
....................    #define __UCFG_VAL_ENABLED__ (__USB_UCFG_UPUEN | __USB_UCFG_FSEN | USB_PING_PONG_MODE) 
.................... #else 
....................    #define __UCFG_VAL_ENABLED__ (__USB_UCFG_UPUEN | USB_PING_PONG_MODE); 
.................... #endif 
....................  
.................... #define __UCFG_VAL_DISABLED__ 0x08 
....................  
.................... char usb_ep0_rx_buffer[USB_MAX_EP0_PACKET_LENGTH]; 
.................... #locate usb_ep0_rx_buffer=USB_BUFFER 
....................  
.................... char usb_ep0_tx_buffer[USB_MAX_EP0_PACKET_LENGTH]; 
.................... #locate usb_ep0_tx_buffer=USB_BUFFER+USB_MAX_EP0_PACKET_LENGTH 
....................  
.................... char usb_data_buffer[USB_TOTAL_BUFFER_SPACE-USB_MAX_EP0_PACKET_LENGTH-USB_MAX_EP0_PACKET_LENGTH]; 
.................... #locate usb_data_buffer=USB_BUFFER+USB_MAX_EP0_PACKET_LENGTH+USB_MAX_EP0_PACKET_LENGTH 
....................  
.................... int8 __setup_0_tx_size; 
....................  
.................... //interrupt handler, specific to PIC18Fxx5x peripheral only 
.................... void usb_handle_interrupt(); 
.................... void usb_isr_rst(); 
.................... void usb_isr_uerr(); 
.................... void usb_isr_sof(void); 
.................... void usb_isr_activity(); 
.................... void usb_isr_uidle(); 
.................... void usb_isr_tok_dne(); 
.................... void usb_isr_stall(void); 
.................... void usb_init_ep0_setup(void); 
....................  
.................... //following functions standard part of CCS PIC USB driver, and used by usb.c 
.................... void usb_init(); 
.................... void usb_detach(); 
.................... int1 usb_put_packet(int endpoint, int * ptr, int16 len, USB_DTS_BIT tgl); 
.................... int1 usb_flush_in(int8 endpoint, int16 len, USB_DTS_BIT tgl); //marks the transmit buffer as ready for transmission 
.................... int16 usb_get_packet(int8 endpoint, int8 * ptr, int16 max); 
.................... int16 usb_rx_packet_size(int8 endpoint); 
.................... int16 usb_get_packet_buffer(int8 endpoint, int8 *ptr, int16 max); 
.................... void usb_flush_out(int8 endpoint, USB_DTS_BIT tgl); 
.................... void usb_stall_ep(int8 endpoint); 
.................... void usb_unstall_ep(int8 endpoint); 
.................... int1 usb_endpoint_stalled(int8 endpoint); 
.................... void usb_set_address(int8 address); 
.................... void usb_set_configured(int config); 
.................... void usb_disable_endpoints(void); 
....................  
.................... //// BEGIN User Functions: 
....................  
.................... /****************************************************************************** 
.................... /* usb_attached() 
.................... /* 
.................... /* Summary: Returns TRUE if the device is attached to a USB cable 
.................... /* 
.................... /*****************************************************************************/ 
.................... #if USB_CON_SENSE_PIN 
....................  #define usb_attached() input(USB_CON_SENSE_PIN) 
.................... #else 
....................  #define usb_attached() TRUE 
.................... #endif 
....................  
.................... /****************************************************************************** 
.................... /* usb_detach() 
.................... /* 
.................... /* Summary: Remove the D+/D- lines from the USB bus.  Basically, disable USB. 
.................... /* 
.................... /*****************************************************************************/ 
.................... void usb_detach(void) {  //done 
....................    UCON=0;  //disable USB hardware 
*
2B1A:  CLRF   F6D
....................    UIE=0;   //disable USB interrupts 
2B1C:  CLRF   F69
....................    UCFG = __UCFG_VAL_DISABLED__; 
2B1E:  MOVLW  08
2B20:  MOVWF  F6F
....................    set_tris_c(*0xF94 | 0x30); 
2B22:  MOVF   F94,W
2B24:  IORLW  30
2B26:  MOVLB  1
2B28:  MOVWF  F94
....................    usb_state=USB_STATE_DETACHED; 
2B2A:  CLRF   26
2B2C:  CLRF   18
2B2E:  BTFSC  FF2.7
2B30:  BSF    18.7
2B32:  BCF    FF2.7
....................    usb_token_reset();              //clear the chapter9 stack 
2B34:  MOVLB  0
2B36:  CALL   1A66
2B3A:  BTFSC  18.7
2B3C:  BSF    FF2.7
....................    __usb_kbhit_status=0; 
2B3E:  CLRF   24
2B40:  CLRF   23
.................... } 
2B42:  GOTO   2B8C (RETURN)
....................  
.................... /****************************************************************************** 
.................... /* usb_attach() 
.................... /* 
.................... /* Summary: Attach the D+/D- lines to the USB bus.  Enable the USB peripheral. 
.................... /* 
.................... /* You should wait until UCON_SE0 is clear before enabling reset/idle interrupt 
.................... /* 
.................... /*****************************************************************************/ 
.................... void usb_attach(void) { 
2B46:  CLRF   18
2B48:  BTFSC  FF2.7
2B4A:  BSF    18.7
2B4C:  BCF    FF2.7
....................    usb_token_reset(); 
2B4E:  CALL   1A66
2B52:  BTFSC  18.7
2B54:  BSF    FF2.7
....................     UCON = 0; 
2B56:  CLRF   F6D
....................    UCFG = __UCFG_VAL_ENABLED__; 
2B58:  MOVLW  14
2B5A:  MOVWF  F6F
....................     UIE = 0;                                // Mask all USB interrupts 
2B5C:  CLRF   F69
....................     UCON_USBEN = 1;                     // Enable module & attach to bus 
2B5E:  BSF    F6D.3
....................     usb_state = USB_STATE_ATTACHED;      // Defined in usbmmap.c & .h 
2B60:  MOVLW  01
2B62:  MOVWF  26
.................... } 
2B64:  GOTO   2B6E (RETURN)
....................  
.................... /***************************************************************************** 
.................... /* usb_init_cs() 
.................... /* 
.................... /* Summary: Resets and initalizes USB peripheral.  Does not attach the peripheral 
.................... /*          to the USB bus.  See usb_attach() and usb_task() on how to 
.................... /*          attach to the USB bus. 
.................... /* 
.................... /*          You must call this before any other USB code. 
.................... /* 
.................... /*          NOTE: an alternative function, usb_init(), is provided that 
.................... /*                initializes the USB and then connects. 
.................... /* 
.................... /*****************************************************************************/ 
.................... #define usb_init_cs usb_detach 
....................  
.................... /***************************************************************************** 
.................... /* usb_task() 
.................... /* 
.................... /* Summary: Keeps an eye on the connection sense pin to determine if we are 
.................... /*          attached to a USB cable or not.  If we are attached to a USB cable, 
.................... /*          initialize the USB peripheral if needed.  If we are disconnected 
.................... /*          from the USB cable, disable the USB peripheral. 
.................... /* 
.................... /*          NOTE: If you are not using a connection sense pin, will automatically 
.................... /*                enable the USB peripheral. 
.................... /* 
.................... /*          NOTE: this enables interrupts once the USB peripheral is ready 
.................... /* 
.................... /*****************************************************************************/ 
.................... void usb_task(void) { 
....................    if (usb_attached()) { 
....................       if (UCON_USBEN==0) { 
2B68:  BTFSC  F6D.3
2B6A:  BRA    2B6E
....................          debug_usb(debug_putc, "\r\n\nUSB TASK: ATTACH"); 
....................          usb_attach(); 
2B6C:  BRA    2B46
....................       } 
....................    } 
....................    else { 
....................       if (UCON_USBEN==1)  { 
....................          debug_usb(debug_putc, "\r\n\nUSB TASK: DE-ATTACH"); 
....................          usb_detach(); 
....................       } 
....................    } 
....................  
....................    if ((usb_state == USB_STATE_ATTACHED)&&(!UCON_SE0)) { 
2B6E:  DECFSZ 26,W
2B70:  BRA    2B88
2B72:  BTFSC  F6D.5
2B74:  BRA    2B88
....................       UIR=0; 
2B76:  CLRF   F68
....................       UIE=0; 
2B78:  CLRF   F69
....................       enable_interrupts(INT_USB); 
2B7A:  BSF    FA0.5
....................       enable_interrupts(GLOBAL); 
2B7C:  MOVLW  C0
2B7E:  IORWF  FF2,F
....................       UIE=__USB_UIF_IDLE | __USB_UIF_RESET;  //enable IDLE and RESET USB interrupt 
2B80:  MOVLW  11
2B82:  MOVWF  F69
....................       usb_state=USB_STATE_POWERED; 
2B84:  MOVLW  02
2B86:  MOVWF  26
....................       debug_usb(debug_putc, "\r\n\nUSB TASK: POWERED"); 
....................    } 
.................... } 
2B88:  RETLW  00
....................  
.................... /***************************************************************************** 
.................... /* usb_init() 
.................... /* 
.................... /* Summary: Resets and initalizes USB hardware.  You must call this first before 
.................... /*          using code.  Will attach the USB periperhal to the USB bus. 
.................... /* 
.................... /*          NOTE: If you are using a connection sense pin, this will wait in 
.................... /*                an infinite loop until the device is connected to a USB cable. 
.................... /* 
.................... /*          NOTE: If you are not using a connection sense pin, this will wait 
.................... /*                in an infinte loop until the SE0 condition clears, which usually 
.................... /*                doesn't take long 
.................... /* 
.................... /*          NOTE: this enables interrupts. 
.................... /* 
.................... /*****************************************************************************/ 
.................... void usb_init(void) { 
....................    usb_init_cs(); 
2B8A:  BRA    2B1A
....................  
....................    do { 
....................       usb_task(); 
2B8C:  RCALL  2B68
....................    } while (usb_state != USB_STATE_POWERED); 
2B8E:  MOVF   26,W
2B90:  SUBLW  02
2B92:  BNZ   2B8C
.................... } 
2B94:  GOTO   3CFA (RETURN)
....................  
....................  
.................... /************************************************************** 
.................... /* usb_flush_in() 
.................... /* 
.................... /* Input: endpoint - which endpoint to mark for transfer 
.................... /*        len - length of data that is being tramsferred 
.................... /*        tgl - Data toggle synchronization for this packet 
.................... /* 
.................... /* Output: TRUE if success, FALSE if error (we don't control the endpoint) 
.................... /* 
.................... /* Summary: Marks the endpoint ready for transmission.  You must 
.................... /*          have already loaded the endpoint buffer with data. 
.................... /*          (IN is PIC -> PC) 
.................... /***************************************************************/ 
.................... int1 usb_flush_in(int8 endpoint, int16 len, USB_DTS_BIT tgl) { 
....................    int8 i; 
....................  
....................    debug_usb(debug_putc,"\r\nPUT %X %U %LU",endpoint, tgl, len); 
....................  
....................    i=EP_BDxST_I(endpoint); 
*
22CA:  MOVLB  1
22CC:  MOVF   xBD,W
22CE:  MULLW  08
22D0:  MOVF   FF3,W
22D2:  ADDLW  04
22D4:  MOVWF  01
22D6:  MOVLW  04
22D8:  MOVWF  03
22DA:  BTFSC  FD8.0
22DC:  INCF   03,F
22DE:  MOVFF  01,FE9
22E2:  MOVFF  03,FEA
22E6:  MOVFF  FEF,1C1
....................    if (!bit_test(i,7)) { 
22EA:  BTFSC  xC1.7
22EC:  BRA    23A4
....................  
....................       EP_BDxCNT_I(endpoint)=len; 
22EE:  MOVF   xBD,W
22F0:  MULLW  08
22F2:  MOVF   FF3,W
22F4:  ADDLW  05
22F6:  MOVWF  01
22F8:  MOVLW  04
22FA:  MOVWF  03
22FC:  BTFSC  FD8.0
22FE:  INCF   03,F
2300:  MOVFF  01,FE9
2304:  MOVFF  03,FEA
2308:  MOVFF  1BE,FEF
....................  
....................      debug_display_ram(len, EP_BDxADR_I(endpoint)); 
....................  
....................      #if USB_IGNORE_TX_DTS 
....................       i=0x80; 
....................      #else 
....................       if (tgl == USB_DTS_TOGGLE) { 
230C:  MOVF   xC0,W
230E:  SUBLW  02
2310:  BNZ   233E
....................          i=EP_BDxST_I(endpoint); 
2312:  MOVF   xBD,W
2314:  MULLW  08
2316:  MOVF   FF3,W
2318:  ADDLW  04
231A:  MOVWF  01
231C:  MOVLW  04
231E:  MOVWF  03
2320:  BTFSC  FD8.0
2322:  INCF   03,F
2324:  MOVFF  01,FE9
2328:  MOVFF  03,FEA
232C:  MOVFF  FEF,1C1
....................          if (bit_test(i,6)) 
2330:  BTFSS  xC1.6
2332:  BRA    2338
....................             tgl=USB_DTS_DATA0;  //was DATA1, goto DATA0 
2334:  CLRF   xC0
....................          else 
2336:  BRA    233C
....................             tgl=USB_DTS_DATA1;  //was DATA0, goto DATA1 
2338:  MOVLW  01
233A:  MOVWF  xC0
....................       } 
....................       else if (tgl == USB_DTS_USERX) { 
233C:  BRA    2364
233E:  MOVF   xC0,W
2340:  SUBLW  04
2342:  BNZ   2364
....................          i=EP_BDxST_O(endpoint); 
2344:  MOVF   xBD,W
2346:  MULLW  08
2348:  MOVFF  FF3,01
234C:  MOVLW  04
234E:  MOVFF  01,FE9
2352:  MOVWF  FEA
2354:  MOVFF  FEF,1C1
....................          if (bit_test(i,6)) 
2358:  BTFSS  xC1.6
235A:  BRA    2362
....................             tgl=USB_DTS_DATA1; 
235C:  MOVLW  01
235E:  MOVWF  xC0
....................          else 
2360:  BRA    2364
....................             tgl=USB_DTS_DATA0; 
2362:  CLRF   xC0
....................       } 
....................       if (tgl == USB_DTS_DATA1) { 
2364:  DECFSZ xC0,W
2366:  BRA    236E
....................          i=0xC8;  //DATA1, UOWN 
2368:  MOVLW  C8
236A:  MOVWF  xC1
....................       } 
....................       else if (tgl == USB_DTS_DATA0) { 
236C:  BRA    2376
236E:  MOVF   xC0,F
2370:  BNZ   2376
....................          i=0x88; //DATA0, UOWN 
2372:  MOVLW  88
2374:  MOVWF  xC1
....................       } 
....................      #endif 
....................  
....................       //set BC8 and BC9 
....................       if (bit_test(len,8)) {bit_set(i,0);} 
2376:  BTFSC  xBF.0
2378:  BSF    xC1.0
....................       if (bit_test(len,9)) {bit_set(i,1);} 
237A:  BTFSC  xBF.1
237C:  BSF    xC1.1
....................  
....................       debug_usb(debug_putc," %X",i); 
....................  
....................       EP_BDxST_I(endpoint)=i;//save changes 
237E:  MOVF   xBD,W
2380:  MULLW  08
2382:  MOVF   FF3,W
2384:  ADDLW  04
2386:  MOVWF  01
2388:  MOVLW  04
238A:  MOVWF  03
238C:  BTFSC  FD8.0
238E:  INCF   03,F
2390:  MOVFF  01,FE9
2394:  MOVFF  03,FEA
2398:  MOVFF  1C1,FEF
....................  
....................       return(1); 
239C:  MOVLW  01
239E:  MOVWF  01
23A0:  BRA    23A8
....................    } 
....................     else { 
23A2:  BRA    23A4
....................          debug_usb(debug_putc,"\r\nPUT ERR"); 
....................     } 
....................    return(0); 
23A4:  MOVLW  00
23A6:  MOVWF  01
.................... } 
23A8:  MOVLB  0
23AA:  RETLW  00
....................  
.................... /******************************************************************************* 
.................... /* usb_put_packet(endpoint,*ptr,len,toggle) 
.................... /* 
.................... /* Input: endpoint - endpoint to send packet to 
.................... /*        ptr - points to data to send 
.................... /*        len - amount of data to send 
.................... /*        toggle - whether to send data with a DATA0 pid, a DATA1 pid, or toggle from the last DATAx pid. 
.................... /* 
.................... /* Output: TRUE if data was sent correctly, FALSE if it was not.  The only reason it will 
.................... /*         return FALSE is if because the TX buffer is still full from the last time you 
.................... /*         tried to send a packet. 
.................... /* 
.................... /* Summary: Sends one packet out the EP to the host.  Notice that there is a difference 
.................... /*          between a packet and a message.  If you wanted to send a 512 byte message you 
.................... /*          would accomplish this by sending 8 64-byte packets, followed by a 0 length packet. 
.................... /*          If the last (or only packet) being sent is less than the max packet size defined 
.................... /*          in your descriptor then you do not need to send a 0 length packet to identify 
.................... /*          an end of message. 
.................... /* 
.................... /*          usb_puts() (provided in usb.c) will send a multi-packet message correctly. 
.................... /* 
.................... /********************************************************************************/ 
.................... int1 usb_put_packet(int8 endpoint, int8 * ptr, int16 len, USB_DTS_BIT tgl) { //done 
....................    int16 j; 
....................    int8 i; 
....................    int8 * buff_add;     
....................  
....................    i=EP_BDxST_I(endpoint); 
*
24B8:  MOVLB  1
24BA:  MOVF   xB2,W
24BC:  MULLW  08
24BE:  MOVF   FF3,W
24C0:  ADDLW  04
24C2:  MOVWF  01
24C4:  MOVLW  04
24C6:  MOVWF  03
24C8:  BTFSC  FD8.0
24CA:  INCF   03,F
24CC:  MOVFF  01,FE9
24D0:  MOVFF  03,FEA
24D4:  MOVFF  FEF,1BA
....................    if (!bit_test(i,7)) { 
24D8:  BTFSC  xBA.7
24DA:  BRA    255E
....................  
....................       buff_add=EP_BDxADR_I(endpoint); 
24DC:  MOVF   xB2,W
24DE:  MULLW  08
24E0:  MOVF   FF3,W
24E2:  ADDLW  06
24E4:  MOVWF  01
24E6:  MOVLW  04
24E8:  MOVWF  03
24EA:  BTFSC  FD8.0
24EC:  INCF   03,F
24EE:  MOVFF  01,FE9
24F2:  MOVFF  03,FEA
24F6:  MOVFF  FEC,03
24FA:  MOVF   FED,F
24FC:  MOVFF  FEF,1BB
2500:  MOVFF  03,1BC
....................  
....................       for (j=0;j<len;j++) { 
2504:  CLRF   xB9
2506:  CLRF   xB8
2508:  MOVF   xB9,W
250A:  SUBWF  xB6,W
250C:  BNC   2542
250E:  BNZ   2516
2510:  MOVF   xB5,W
2512:  SUBWF  xB8,W
2514:  BC    2542
....................          *buff_add=*ptr; 
2516:  MOVFF  1B3,FE9
251A:  MOVFF  1B4,FEA
251E:  MOVFF  FEF,1BF
2522:  MOVFF  1BC,FEA
2526:  MOVFF  1BB,FE9
252A:  MOVFF  1BF,FEF
....................          buff_add++; 
252E:  INCF   xBB,F
2530:  BTFSC  FD8.2
2532:  INCF   xBC,F
....................          ptr++; 
2534:  INCF   xB3,F
2536:  BTFSC  FD8.2
2538:  INCF   xB4,F
....................       } 
253A:  INCF   xB8,F
253C:  BTFSC  FD8.2
253E:  INCF   xB9,F
2540:  BRA    2508
....................  
....................       return(usb_flush_in(endpoint, len, tgl)); 
2542:  MOVFF  1B2,1BD
2546:  MOVFF  1B6,1BF
254A:  MOVFF  1B5,1BE
254E:  MOVFF  1B7,1C0
2552:  MOVLB  0
2554:  RCALL  22CA
2556:  MOVF   01,W
2558:  BRA    2562
....................     } 
....................     else { 
255A:  BRA    255C
255C:  MOVLB  1
....................         debug_usb(debug_putc,"\r\nPUT ERR"); 
....................     } 
....................     return(0); 
255E:  MOVLW  00
2560:  MOVWF  01
2562:  MOVLB  0
.................... } 
2564:  RETLW  00
....................  
.................... /// END User Functions 
....................  
....................  
.................... /// BEGIN Hardware layer functions required by USB.C 
....................  
.................... /************************************************************** 
.................... /* usb_flush_out() 
.................... /* 
.................... /* Input: endpoint - which endpoint to mark for transfer 
.................... /*        tgl - Data toggle synchronization to expect in the next packet 
.................... /* 
.................... /* Output: NONE 
.................... /* 
.................... /* Summary: Clears the previously received packet, and then marks this 
.................... /*          endpoint's receive buffer as ready for more data. 
.................... /*          (OUT is PC -> PIC) 
.................... /***************************************************************/ 
.................... void usb_flush_out(int8 endpoint, USB_DTS_BIT tgl) { 
....................    int8 i; 
....................    int16 len; 
....................  
....................      #if USB_IGNORE_RX_DTS 
....................       if (tgl == USB_DTS_STALL) { 
....................          debug_usb(debug_putc, '*'); 
....................          i=0x84; 
....................          EP_BDxST_I(endpoint)=0x84; 
....................          return; 
....................       } 
....................       else 
....................          i=0x80; 
....................      #else 
....................       i=EP_BDxST_O(endpoint); 
*
21DC:  MOVLB  1
21DE:  MOVF   xB1,W
21E0:  MULLW  08
21E2:  MOVFF  FF3,01
21E6:  MOVLW  04
21E8:  MOVFF  01,FE9
21EC:  MOVWF  FEA
21EE:  MOVFF  FEF,1B3
....................       if (tgl == USB_DTS_TOGGLE) { 
21F2:  MOVF   xB2,W
21F4:  SUBLW  02
21F6:  BNZ   2204
....................          if (bit_test(i,6)) 
21F8:  BTFSS  xB3.6
21FA:  BRA    2200
....................             tgl=USB_DTS_DATA0;  //was DATA1, goto DATA0 
21FC:  CLRF   xB2
....................          else 
21FE:  BRA    2204
....................             tgl=USB_DTS_DATA1;  //was DATA0, goto DATA1 
2200:  MOVLW  01
2202:  MOVWF  xB2
....................       } 
....................       if (tgl == USB_DTS_STALL) { 
2204:  MOVF   xB2,W
2206:  SUBLW  03
2208:  BNZ   222E
....................          i=0x84; 
220A:  MOVLW  84
220C:  MOVWF  xB3
....................          EP_BDxST_I(endpoint)=0x84; //stall both in and out endpoints 
220E:  MOVF   xB1,W
2210:  MULLW  08
2212:  MOVF   FF3,W
2214:  ADDLW  04
2216:  MOVWF  01
2218:  MOVLW  04
221A:  MOVWF  03
221C:  BTFSC  FD8.0
221E:  INCF   03,F
2220:  MOVFF  01,FE9
2224:  MOVFF  03,FEA
2228:  MOVLW  84
222A:  MOVWF  FEF
....................       } 
....................       else if (tgl == USB_DTS_DATA1) { 
222C:  BRA    2240
222E:  DECFSZ xB2,W
2230:  BRA    2238
....................          i=0xC8;  //DATA1, UOWN 
2232:  MOVLW  C8
2234:  MOVWF  xB3
....................       } 
....................       else if (tgl == USB_DTS_DATA0) { 
2236:  BRA    2240
2238:  MOVF   xB2,F
223A:  BNZ   2240
....................          i=0x88; //DATA0, UOWN 
223C:  MOVLW  88
223E:  MOVWF  xB3
....................       } 
....................      #endif 
....................  
....................    bit_clear(__usb_kbhit_status,endpoint); 
2240:  CLRF   03
2242:  MOVLW  01
2244:  MOVWF  02
2246:  MOVF   xB1,W
2248:  MOVWF  00
224A:  BZ    2256
224C:  BCF    FD8.0
224E:  RLCF   02,F
2250:  RLCF   03,F
2252:  DECFSZ 00,F
2254:  BRA    224C
2256:  MOVF   02,W
2258:  XORLW  FF
225A:  MOVWF  00
225C:  MOVLW  FF
225E:  XORWF  03,F
2260:  MOVF   00,W
2262:  ANDWF  23,F
2264:  MOVF   03,W
2266:  ANDWF  24,F
....................  
....................    len=usb_ep_rx_size[endpoint]; 
2268:  BCF    FD8.0
226A:  RLCF   xB1,W
226C:  CLRF   03
226E:  MOVFF  FF2,1B6
2272:  BCF    FF2.7
2274:  MOVLB  0
2276:  CALL   190E
227A:  TBLRD*+
227C:  MOVFF  FF5,03
2280:  MOVLB  1
2282:  BTFSC  xB6.7
2284:  BSF    FF2.7
2286:  MOVWF  xB4
2288:  MOVFF  03,1B5
....................    EP_BDxCNT_O(endpoint)=len; 
228C:  MOVF   xB1,W
228E:  MULLW  08
2290:  MOVF   FF3,W
2292:  ADDLW  01
2294:  MOVWF  01
2296:  MOVLW  04
2298:  MOVWF  03
229A:  BTFSC  FD8.0
229C:  INCF   03,F
229E:  MOVFF  01,FE9
22A2:  MOVFF  03,FEA
22A6:  MOVFF  1B4,FEF
....................    if (bit_test(len,8)) {bit_set(i,0);} 
22AA:  BTFSC  xB5.0
22AC:  BSF    xB3.0
....................    if (bit_test(len,9)) {bit_set(i,1);} 
22AE:  BTFSC  xB5.1
22B0:  BSF    xB3.1
....................  
....................  
....................    EP_BDxST_O(endpoint)=i; 
22B2:  MOVF   xB1,W
22B4:  MULLW  08
22B6:  MOVFF  FF3,01
22BA:  MOVLW  04
22BC:  MOVFF  01,FE9
22C0:  MOVWF  FEA
22C2:  MOVFF  1B3,FEF
.................... } 
22C6:  MOVLB  0
22C8:  RETLW  00
....................  
.................... int16 usb_rx_packet_size(int8 endpoint) { 
....................    return(EP_BDxCNT_O(endpoint)); 
*
2410:  MOVLB  1
2412:  MOVF   xB2,W
2414:  MULLW  08
2416:  MOVF   FF3,W
2418:  ADDLW  01
241A:  MOVWF  01
241C:  MOVLW  04
241E:  MOVWF  03
2420:  BTFSC  FD8.0
2422:  INCF   03,F
2424:  MOVFF  01,FE9
2428:  MOVFF  03,FEA
242C:  CLRF   03
242E:  MOVFF  FEF,01
2432:  MOVFF  03,02
.................... } 
2436:  MOVLB  0
2438:  GOTO   244A (RETURN)
....................  
.................... /******************************************************************************* 
.................... /* usb_get_packet_buffer(endpoint, *ptr, max) 
.................... /* 
.................... /* Input: endpoint - endpoint to get data from 
.................... /*        ptr - where to save data to local PIC RAM 
.................... /*        max - max amount of data to receive from buffer 
.................... /* 
.................... /* Output: the amount of data taken from the buffer. 
.................... /* 
.................... /* Summary: Gets a packet of data from the USB buffer and puts into local PIC RAM. 
.................... /*          Does not mark the endpoint as ready for more data.  Once you are 
.................... /*          done with data, call usb_flush_out() to mark the endpoint ready 
.................... /*          to receive more data. 
.................... /* 
.................... /********************************************************************************/ 
.................... int16 usb_get_packet_buffer(int8 endpoint, int8 *ptr, int16 max) { 
....................    int8 * al; 
....................    int8 st; 
....................    int16 i; 
....................  
....................    al=EP_BDxADR_O(endpoint); 
....................    i=EP_BDxCNT_O(endpoint); 
....................    st=EP_BDxST_O(endpoint); 
....................  
....................    //read BC8 and BC9 
....................    if (bit_test(st,0)) {bit_set(i,8);} 
....................    if (bit_test(st,1)) {bit_set(i,9);} 
....................  
....................    if (i<max) {max=i;} 
....................  
....................    i=0; 
....................  
....................    while (i<max) { 
....................        *ptr=*al; 
....................        ptr++; 
....................        al++; 
....................        i++; 
....................    } 
....................  
....................    return(max); 
.................... } 
....................  
.................... /******************************************************************************* 
.................... /* usb_get_packet(endpoint, *ptr, max) 
.................... /* 
.................... /* Input: endpoint - endpoint to get data from 
.................... /*        ptr - where to save data to local PIC RAM 
.................... /*        max - max amount of data to receive from buffer 
.................... /* 
.................... /* Output: the amount of data taken from the buffer. 
.................... /* 
.................... /*         NOTE - IF THERE IS NO PACKET TO GET YOU WILL GET INVALID RESULTS! 
.................... /*                VERIFY WITH USB_KBHIT() BEFORE YOU CALL USB_GET_PACKET()! 
.................... /* 
.................... /* Summary: Gets a packet of data from the USB buffer and puts into local PIC RAM. 
.................... /*          Until you call usb_get_packet() the data will sit in the endpoint 
.................... /*          buffer and the PC will get NAKs when it tries to write more data 
.................... /*          to the endpoint. 
.................... /* 
.................... /********************************************************************************/ 
.................... int16 usb_get_packet(int8 endpoint, int8 * ptr, int16 max) { 
....................  
....................    max=usb_get_packet_buffer(endpoint,ptr,max); 
....................    usb_flush_out(endpoint, USB_DTS_TOGGLE); 
....................  
....................    return(max); 
.................... } 
....................  
.................... /******************************************************************************* 
.................... /* usb_tbe(endpoint) 
.................... /* 
.................... /* Input: endpoint - endpoint to check 
.................... /*        ptr - where to save data to local PIC RAM 
.................... /*        max - max amount of data to receive from buffer 
.................... /* 
.................... /* Output: returns TRUE if this endpoint's IN buffer (PIC-PC) is empty and ready 
.................... /*         returns FALSE if this endpoint's IN buffer is still processing the last 
.................... /*         transmit or if this endpoint is invalid. 
.................... /* 
.................... /********************************************************************************/ 
.................... int8 usb_tbe(int8 endpoint) { 
....................    int8 st; 
....................    st=EP_BDxST_I(endpoint); 
....................    if (!bit_test(st,7)) 
....................       return(TRUE); 
....................    return(FALSE); 
.................... } 
....................  
.................... /******************************************************************************* 
.................... /* usb_stall_ep(endpoint,direction) 
.................... /* 
.................... /* Input: endpoint - endpoint to stall. 
.................... /*                   top most bit indicates direction (set is IN, clear is OUT) 
.................... /* 
.................... /* Summary: Stalls specified endpoint.  If endpoint is stalled it will send STALL packet 
.................... /*          if the host tries to access this endpoint's buffer. 
.................... /* 
.................... /* 
.................... /* NOTE: WE ASSUME ENDPOINT IS VALID.  USB.C SHOULD CHECK THIS 
.................... /* 
.................... /********************************************************************************/ 
.................... void usb_stall_ep(int8 endpoint) {  //done 
....................    int1 direction; 
....................    direction=bit_test(endpoint,7); 
*
1FF4:  MOVLB  1
1FF6:  BCF    xB2.0
1FF8:  BTFSC  xB1.7
1FFA:  BSF    xB2.0
....................    endpoint&=0x7F; 
1FFC:  BCF    xB1.7
....................    if (direction) { 
1FFE:  BTFSS  xB2.0
2000:  BRA    2022
....................       EP_BDxST_I(endpoint)=0x84; 
2002:  MOVF   xB1,W
2004:  MULLW  08
2006:  MOVF   FF3,W
2008:  ADDLW  04
200A:  MOVWF  01
200C:  MOVLW  04
200E:  MOVWF  03
2010:  BTFSC  FD8.0
2012:  INCF   03,F
2014:  MOVFF  01,FE9
2018:  MOVFF  03,FEA
201C:  MOVLW  84
201E:  MOVWF  FEF
....................    } 
....................    else { 
2020:  BRA    2036
....................       EP_BDxST_O(endpoint)=0x84; 
2022:  MOVF   xB1,W
2024:  MULLW  08
2026:  MOVFF  FF3,01
202A:  MOVLW  04
202C:  MOVFF  01,FE9
2030:  MOVWF  FEA
2032:  MOVLW  84
2034:  MOVWF  FEF
....................    } 
.................... } 
2036:  MOVLB  0
2038:  GOTO   20C8 (RETURN)
....................  
.................... /******************************************************************************* 
.................... /* usb_unstall_ep(endpoint, direction) 
.................... /* 
.................... /* Input: endpoint - endpoint to un-stall. 
.................... /*                   top most bit indicates direction (set is IN, clear is OUT) 
.................... /* 
.................... /* Summary: Un-stalls endpoint. 
.................... /* 
.................... /* NOTE: WE ASSUME ENDPOINT IS VALID.  USB.C SHOULD CHECK THIS 
.................... /********************************************************************************/ 
.................... void usb_unstall_ep(int8 endpoint) {   //done 
....................    int1 direction; 
....................    direction=bit_test(endpoint,7); 
*
1FAE:  MOVLB  1
1FB0:  BCF    xB2.0
1FB2:  BTFSC  xB1.7
1FB4:  BSF    xB2.0
....................    endpoint&=0x7F; 
1FB6:  BCF    xB1.7
....................    if (direction) { 
1FB8:  BTFSS  xB2.0
1FBA:  BRA    1FDC
....................       #if USB_IGNORE_RX_DTS 
....................       EP_BDxST_I(endpoint)=0x80; 
....................       #else 
....................       EP_BDxST_I(endpoint)=0x88; 
1FBC:  MOVF   xB1,W
1FBE:  MULLW  08
1FC0:  MOVF   FF3,W
1FC2:  ADDLW  04
1FC4:  MOVWF  01
1FC6:  MOVLW  04
1FC8:  MOVWF  03
1FCA:  BTFSC  FD8.0
1FCC:  INCF   03,F
1FCE:  MOVFF  01,FE9
1FD2:  MOVFF  03,FEA
1FD6:  MOVLW  88
1FD8:  MOVWF  FEF
....................       #endif 
....................    } 
....................    else { 
1FDA:  BRA    1FEE
....................       EP_BDxST_O(endpoint)=0x00; 
1FDC:  MOVF   xB1,W
1FDE:  MULLW  08
1FE0:  MOVFF  FF3,01
1FE4:  MOVLW  04
1FE6:  MOVFF  01,FE9
1FEA:  MOVWF  FEA
1FEC:  CLRF   FEF
....................    } 
.................... } 
1FEE:  MOVLB  0
1FF0:  GOTO   20B8 (RETURN)
....................  
.................... /******************************************************************************* 
.................... /* usb_endpoint_stalled(endpoint) 
.................... /* 
.................... /* Input: endpoint - endpoint to check 
.................... /*                   top most bit indicates direction (set is IN, clear is OUT) 
.................... /* 
.................... /* Output: returns a TRUE if endpoint is stalled, FALSE if it is not. 
.................... /* 
.................... /* Summary: Looks to see if an endpoint is stalled, or not.  Does not look to 
.................... /*          see if endpoint has been issued a STALL, just whether or not it is 
.................... /*          configured to STALL on the next packet.  See Set_Feature and Clear_Feature 
.................... /*          Chapter 9 requests. 
.................... /* 
.................... /* NOTE: WE ASSUME ENDPOINT IS VALID.  USB.C SHOULD CHECK THIS 
.................... /********************************************************************************/ 
.................... int1 usb_endpoint_stalled(int8 endpoint) {   //done 
....................    int1 direction; 
....................    int8 st; 
....................    direction=bit_test(endpoint,7); 
*
203C:  MOVLB  1
203E:  BCF    xB2.0
2040:  BTFSC  xB1.7
2042:  BSF    xB2.0
....................    endpoint&=0x7F; 
2044:  BCF    xB1.7
....................    if (direction) { 
2046:  BTFSS  xB2.0
2048:  BRA    206A
....................       st=EP_BDxST_I(endpoint); 
204A:  MOVF   xB1,W
204C:  MULLW  08
204E:  MOVF   FF3,W
2050:  ADDLW  04
2052:  MOVWF  01
2054:  MOVLW  04
2056:  MOVWF  03
2058:  BTFSC  FD8.0
205A:  INCF   03,F
205C:  MOVFF  01,FE9
2060:  MOVFF  03,FEA
2064:  MOVFF  FEF,1B3
....................    } 
....................    else { 
2068:  BRA    207E
....................       st=EP_BDxST_O(endpoint); 
206A:  MOVF   xB1,W
206C:  MULLW  08
206E:  MOVFF  FF3,01
2072:  MOVLW  04
2074:  MOVFF  01,FE9
2078:  MOVWF  FEA
207A:  MOVFF  FEF,1B3
....................    } 
....................    return(bit_test(st,7) && bit_test(st,2)); 
207E:  BTFSS  xB3.7
2080:  BRA    2086
2082:  BTFSC  xB3.2
2084:  BRA    208A
2086:  MOVLW  00
2088:  BRA    208C
208A:  MOVLW  01
208C:  MOVWF  01
.................... } 
208E:  MOVLB  0
2090:  GOTO   20E0 (RETURN)
....................  
....................  
.................... /******************************************************************************* 
.................... /* usb_set_address(address) 
.................... /* 
.................... /* Input: address - address the host specified that we use 
.................... /* 
.................... /* Summary: Configures the USB Peripheral for the specified device address.  The host 
.................... /*          will now talk to use with the following address. 
.................... /* 
.................... /********************************************************************************/ 
.................... void usb_set_address(int8 address) {   //done 
....................    UADDR=address; 
*
2490:  MOVFF  1B2,F6E
....................    if (address) { 
2494:  MOVLB  1
2496:  MOVF   xB2,F
2498:  BZ    24A0
....................       usb_state=USB_STATE_ADDRESS; 
249A:  MOVLW  04
249C:  MOVWF  26
....................    } 
....................    else { 
249E:  BRA    24A4
....................       usb_state=USB_STATE_POWERED; 
24A0:  MOVLW  02
24A2:  MOVWF  26
....................    } 
.................... } 
24A4:  MOVLB  0
24A6:  GOTO   24B4 (RETURN)
....................  
....................  
.................... /******************************************************************************* 
.................... /* usb_set_configured(config) 
.................... /* 
.................... /* Input: config - Configuration to use.  0 to uncofigure device. 
.................... /* 
.................... /* Summary: Configures or unconfigures device.  If configuring device it will 
.................... /*          enable all the endpoints the user specified for this configuration. 
.................... /*          If un-configuring device it will disable all endpoints. 
.................... /* 
.................... /*          NOTE: CCS only provides code to handle 1 configuration. 
.................... /* 
.................... /********************************************************************************/ 
.................... void usb_set_configured(int config) { 
....................    int8 en; 
....................    int16 addy; 
....................    int8 new_uep; 
....................    int16 len; 
....................    int8 i; 
....................       if (config==0) { 
*
1C46:  MOVLB  1
1C48:  MOVF   xB1,F
1C4A:  BNZ   1C58
....................          //if config=0 then set addressed state 
....................          usb_state=USB_STATE_ADDRESS; 
1C4C:  MOVLW  04
1C4E:  MOVWF  26
....................          usb_disable_endpoints(); 
1C50:  MOVLB  0
1C52:  RCALL  1A92
....................       } 
....................       else { 
1C54:  BRA    1DF2
1C56:  MOVLB  1
....................          usb_state=USB_STATE_CONFIGURED; //else set configed state 
1C58:  MOVLW  05
1C5A:  MOVWF  26
....................          addy=(int16)USB_BUFFER+(2*USB_MAX_EP0_PACKET_LENGTH); 
1C5C:  MOVWF  xB4
1C5E:  MOVLW  80
1C60:  MOVWF  xB3
....................          for (en=1;en<16;en++) { 
1C62:  MOVLW  01
1C64:  MOVWF  xB2
1C66:  MOVF   xB2,W
1C68:  SUBLW  0F
1C6A:  BTFSS  FD8.0
1C6C:  BRA    1DF2
....................             new_uep=0; 
1C6E:  CLRF   xB5
....................             if (usb_ep_rx_type[en]!=USB_ENABLE_DISABLED) { 
1C70:  CLRF   03
1C72:  MOVF   xB2,W
1C74:  MOVFF  FF2,1B9
1C78:  BCF    FF2.7
1C7A:  MOVLB  0
1C7C:  RCALL  18BE
1C7E:  MOVLB  1
1C80:  BTFSC  xB9.7
1C82:  BSF    FF2.7
1C84:  XORLW  00
1C86:  BZ    1D32
....................                new_uep=0x04; 
1C88:  MOVLW  04
1C8A:  MOVWF  xB5
....................                len=usb_ep_rx_size[en]; 
1C8C:  BCF    FD8.0
1C8E:  RLCF   xB2,W
1C90:  CLRF   03
1C92:  MOVFF  FF2,1B9
1C96:  BCF    FF2.7
1C98:  MOVLB  0
1C9A:  RCALL  190E
1C9C:  TBLRD*+
1C9E:  MOVFF  FF5,03
1CA2:  MOVLB  1
1CA4:  BTFSC  xB9.7
1CA6:  BSF    FF2.7
1CA8:  MOVWF  xB6
1CAA:  MOVFF  03,1B7
....................                EP_BDxCNT_O(en)=len; 
1CAE:  MOVF   xB2,W
1CB0:  MULLW  08
1CB2:  MOVF   FF3,W
1CB4:  ADDLW  01
1CB6:  MOVWF  01
1CB8:  MOVLW  04
1CBA:  MOVWF  03
1CBC:  BTFSC  FD8.0
1CBE:  INCF   03,F
1CC0:  MOVFF  01,FE9
1CC4:  MOVFF  03,FEA
1CC8:  MOVFF  1B6,FEF
....................                EP_BDxADR_O(en)=addy; 
1CCC:  MOVF   xB2,W
1CCE:  MULLW  08
1CD0:  MOVF   FF3,W
1CD2:  ADDLW  02
1CD4:  MOVWF  01
1CD6:  MOVLW  04
1CD8:  MOVWF  03
1CDA:  BTFSC  FD8.0
1CDC:  INCF   03,F
1CDE:  MOVFF  01,FE9
1CE2:  MOVFF  03,FEA
1CE6:  MOVFF  1B4,FEC
1CEA:  MOVF   FED,F
1CEC:  MOVFF  1B3,FEF
....................                addy+=usb_ep_rx_size[en]; 
1CF0:  BCF    FD8.0
1CF2:  RLCF   xB2,W
1CF4:  CLRF   03
1CF6:  MOVFF  FF2,1B9
1CFA:  BCF    FF2.7
1CFC:  MOVLB  0
1CFE:  RCALL  190E
1D00:  TBLRD*+
1D02:  MOVFF  FF5,03
1D06:  MOVLB  1
1D08:  BTFSC  xB9.7
1D0A:  BSF    FF2.7
1D0C:  ADDWF  xB3,F
1D0E:  MOVF   03,W
1D10:  ADDWFC xB4,F
....................                #if USB_IGNORE_RX_DTS 
....................                   i=0x80; 
....................                #else 
....................                   i=0x88; 
1D12:  MOVLW  88
1D14:  MOVWF  xB8
....................                #endif 
....................                if (bit_test(len,8)) {bit_set(i,0);} 
1D16:  BTFSC  xB7.0
1D18:  BSF    xB8.0
....................                if (bit_test(len,9)) {bit_set(i,1);} 
1D1A:  BTFSC  xB7.1
1D1C:  BSF    xB8.1
....................                EP_BDxST_O(en)=i; 
1D1E:  MOVF   xB2,W
1D20:  MULLW  08
1D22:  MOVFF  FF3,01
1D26:  MOVLW  04
1D28:  MOVFF  01,FE9
1D2C:  MOVWF  FEA
1D2E:  MOVFF  1B8,FEF
....................             } 
....................             if (usb_ep_tx_type[en]!=USB_ENABLE_DISABLED) { 
1D32:  CLRF   03
1D34:  MOVF   xB2,W
1D36:  MOVFF  FF2,1B9
1D3A:  BCF    FF2.7
1D3C:  MOVLB  0
1D3E:  RCALL  189E
1D40:  MOVLB  1
1D42:  BTFSC  xB9.7
1D44:  BSF    FF2.7
1D46:  XORLW  00
1D48:  BZ    1DB0
....................                new_uep|=0x02; 
1D4A:  BSF    xB5.1
....................                EP_BDxADR_I(en)=addy; 
1D4C:  MOVF   xB2,W
1D4E:  MULLW  08
1D50:  MOVF   FF3,W
1D52:  ADDLW  06
1D54:  MOVWF  01
1D56:  MOVLW  04
1D58:  MOVWF  03
1D5A:  BTFSC  FD8.0
1D5C:  INCF   03,F
1D5E:  MOVFF  01,FE9
1D62:  MOVFF  03,FEA
1D66:  MOVFF  1B4,FEC
1D6A:  MOVF   FED,F
1D6C:  MOVFF  1B3,FEF
....................                addy+=usb_ep_tx_size[en]; 
1D70:  BCF    FD8.0
1D72:  RLCF   xB2,W
1D74:  CLRF   03
1D76:  MOVFF  FF2,1B9
1D7A:  BCF    FF2.7
1D7C:  MOVLB  0
1D7E:  RCALL  18DE
1D80:  TBLRD*+
1D82:  MOVFF  FF5,03
1D86:  MOVLB  1
1D88:  BTFSC  xB9.7
1D8A:  BSF    FF2.7
1D8C:  ADDWF  xB3,F
1D8E:  MOVF   03,W
1D90:  ADDWFC xB4,F
....................                EP_BDxST_I(en)=0x40; 
1D92:  MOVF   xB2,W
1D94:  MULLW  08
1D96:  MOVF   FF3,W
1D98:  ADDLW  04
1D9A:  MOVWF  01
1D9C:  MOVLW  04
1D9E:  MOVWF  03
1DA0:  BTFSC  FD8.0
1DA2:  INCF   03,F
1DA4:  MOVFF  01,FE9
1DA8:  MOVFF  03,FEA
1DAC:  MOVLW  40
1DAE:  MOVWF  FEF
....................             } 
....................             if (new_uep==0x06) {new_uep=0x0E;} 
1DB0:  MOVF   xB5,W
1DB2:  SUBLW  06
1DB4:  BNZ   1DBA
1DB6:  MOVLW  0E
1DB8:  MOVWF  xB5
....................             if (usb_ep_tx_type[en]!=USB_ENABLE_ISOCHRONOUS) { 
1DBA:  CLRF   03
1DBC:  MOVF   xB2,W
1DBE:  MOVFF  FF2,1B9
1DC2:  BCF    FF2.7
1DC4:  MOVLB  0
1DC6:  RCALL  189E
1DC8:  MOVLB  1
1DCA:  BTFSC  xB9.7
1DCC:  BSF    FF2.7
1DCE:  SUBLW  02
1DD0:  BZ    1DD4
....................                new_uep|=0x10; 
1DD2:  BSF    xB5.4
....................             } 
....................             UEP(en)=new_uep; 
1DD4:  MOVLW  70
1DD6:  ADDWF  xB2,W
1DD8:  MOVWF  01
1DDA:  MOVLW  0F
1DDC:  MOVWF  03
1DDE:  BTFSC  FD8.0
1DE0:  INCF   03,F
1DE2:  MOVFF  01,FE9
1DE6:  MOVFF  03,FEA
1DEA:  MOVFF  1B5,FEF
....................          } 
1DEE:  INCF   xB2,F
1DF0:  BRA    1C66
1DF2:  MOVLB  0
....................       } 
.................... } 
1DF4:  GOTO   1E98 (RETURN)
....................  
.................... /// END Hardware layer functions required by USB.C 
....................  
....................  
.................... /// BEGIN USB Interrupt Service Routine 
....................  
.................... /******************************************************************************* 
.................... /* usb_handle_interrupt() 
.................... /* 
.................... /* Summary: Checks the interrupt, and acts upon event.  Processing finished 
.................... /*          tokens is the majority of this code, and is handled by usb.c 
.................... /* 
.................... /* NOTE: If you wish to change to a polling method (and not an interrupt method), 
.................... /*       then you must call this function rapidly.  If there is more than 10ms 
.................... /*       latency the PC may think the USB device is stalled and disable it. 
.................... /*       To switch to a polling method, remove the #int_usb line above this fuction. 
.................... /*       Also, goto usb_init() and remove the code that enables the USB interrupt. 
.................... /********************************************************************************/ 
.................... #int_usb 
.................... void usb_isr() { 
....................    if (usb_state==USB_STATE_DETACHED) return;   //should never happen, though 
*
26BA:  MOVF   26,F
26BC:  BNZ   26C0
26BE:  BRA    271E
....................    if (UIR) { 
26C0:  MOVF   F68,F
26C2:  BZ    271E
....................       debug_usb(debug_putc,"\r\n\n[%X] ",UIR); 
....................       if (UIR_ACTV && UIE_ACTV) {usb_isr_activity();}  //activity detected.  (only enable after sleep) 
26C4:  BTFSS  F68.2
26C6:  BRA    26D0
26C8:  BTFSS  F69.2
26CA:  BRA    26D0
26CC:  GOTO   1A30
....................  
....................       if (UCON_SUSPND) return; 
26D0:  BTFSS  F6D.1
26D2:  BRA    26D6
26D4:  BRA    271E
....................  
....................       if (UIR_UERR && UIE_UERR) {usb_isr_uerr();}          //error has been detected 
26D6:  BTFSS  F68.1
26D8:  BRA    26E2
26DA:  BTFSS  F69.1
26DC:  BRA    26E2
26DE:  GOTO   1A3A
....................  
....................       if (UIR_URST && UIE_URST) {usb_isr_rst();}        //usb reset has been detected 
26E2:  BTFSS  F68.0
26E4:  BRA    26EE
26E6:  BTFSS  F69.0
26E8:  BRA    26EE
26EA:  GOTO   1AE0
....................  
....................       if (UIR_IDLE && UIE_IDLE) {usb_isr_uidle();}        //idle time, we can go to sleep 
26EE:  BTFSS  F68.4
26F0:  BRA    26FA
26F2:  BTFSS  F69.4
26F4:  BRA    26FA
26F6:  GOTO   1B0A
....................       if (UIR_SOF && UIE_SOF) {usb_isr_sof();} 
26FA:  BTFSS  F68.6
26FC:  BRA    2706
26FE:  BTFSS  F69.6
2700:  BRA    2706
2702:  GOTO   1B14
....................       if (UIR_STALL && UIE_STALL) {usb_isr_stall();}        //a stall handshake was sent 
2706:  BTFSS  F68.5
2708:  BRA    2712
270A:  BTFSS  F69.5
270C:  BRA    2712
270E:  GOTO   1B1A
....................  
....................       if (UIR_TRN && UIE_TRN) { 
2712:  BTFSS  F68.3
2714:  BRA    271E
2716:  BTFSS  F69.3
2718:  BRA    271E
....................          usb_isr_tok_dne(); 
271A:  BRA    25CA
....................          UIR_TRN=0;    // clear the token done interrupt., 0x190.3 
271C:  BCF    F68.3
....................       }    //a token has been detected (majority of isrs) 
....................    } 
.................... } 
....................  
.................... //SOF interrupt not handled.  user must add this depending on application 
271E:  BCF    FA1.5
2720:  GOTO   1858
.................... void usb_isr_sof(void) { 
....................    debug_usb(debug_putc,"\r\nSOF"); 
....................    UIR_SOF=0; 
*
1B14:  BCF    F68.6
.................... } 
1B16:  GOTO   2706 (RETURN)
....................  
.................... /******************************************************************************* 
.................... /* usb_disable_endpoints() 
.................... /* 
.................... /* Summary: Disables endpoints 1 thru 15 
.................... /* 
.................... /********************************************************************************/ 
.................... void usb_disable_endpoints(void) { 
....................    int8 i; 
....................    for (i=1;i<16;i++) { 
*
1A92:  MOVLW  01
1A94:  MOVLB  1
1A96:  MOVWF  xB9
1A98:  MOVF   xB9,W
1A9A:  SUBLW  0F
1A9C:  BNC   1ABA
....................       UEP(i)=ENDPT_DISABLED; 
1A9E:  MOVLW  70
1AA0:  ADDWF  xB9,W
1AA2:  MOVWF  01
1AA4:  MOVLW  0F
1AA6:  MOVWF  03
1AA8:  BTFSC  FD8.0
1AAA:  INCF   03,F
1AAC:  MOVFF  01,FE9
1AB0:  MOVFF  03,FEA
1AB4:  CLRF   FEF
....................    } 
1AB6:  INCF   xB9,F
1AB8:  BRA    1A98
....................    __usb_kbhit_status=0; 
1ABA:  CLRF   24
1ABC:  CLRF   23
.................... } 
1ABE:  MOVLB  0
1AC0:  RETLW  00
....................  
.................... /******************************************************************************* 
.................... /* usb_isr_rst() 
.................... /* 
.................... /* Summary: The host (computer) sent us a RESET command.  Reset USB device 
.................... /*          and token handler code to initial state. 
.................... /* 
.................... /********************************************************************************/ 
.................... void usb_isr_rst() { 
....................    debug_usb(debug_putc,"R"); 
....................  
....................    UEIR=0; 
*
1AE0:  CLRF   F6A
....................    UIR=0; 
1AE2:  CLRF   F68
....................    UEIE=0x9F; 
1AE4:  MOVLW  9F
1AE6:  MOVWF  F6B
....................    UIE=STANDARD_INTS & ~__USB_UIF_ACTIVE; 
1AE8:  MOVLW  39
1AEA:  MOVWF  F69
....................  
....................    UADDR=0; 
1AEC:  CLRF   F6E
....................  
....................    usb_token_reset(); 
1AEE:  RCALL  1A66
....................  
....................    usb_disable_endpoints(); 
1AF0:  RCALL  1A92
....................  
....................    UEP(0)=ENDPT_CONTROL | 0x10; 
1AF2:  MOVLW  16
1AF4:  MOVWF  F70
....................  
....................    while (UIR_TRN) { 
1AF6:  BTFSS  F68.3
1AF8:  BRA    1AFE
....................       UIR_TRN=0;    //do this to clear out the ustat fifo 
1AFA:  BCF    F68.3
....................    } 
1AFC:  BRA    1AF6
....................  
....................    UCON_PKTDIS=0; //SIE token and packet processing enabled 
1AFE:  BCF    F6D.4
....................  
....................    usb_init_ep0_setup(); 
1B00:  RCALL  1AC2
....................  
....................    usb_state=USB_STATE_DEFAULT; //put usb mcu into default state 
1B02:  MOVLW  03
1B04:  MOVWF  26
.................... } 
1B06:  GOTO   26EE (RETURN)
....................  
.................... /***************************************************************************** 
.................... /* usb_init_ep0_setup() 
.................... /* 
.................... /* Summary: Configure EP0 to receive setup packets 
.................... /* 
.................... /*****************************************************************************/ 
.................... void usb_init_ep0_setup(void) { 
....................     EP_BDxCNT_O(0) = USB_MAX_EP0_PACKET_LENGTH; 
*
1AC2:  MOVLW  40
1AC4:  MOVLB  4
1AC6:  MOVWF  x01
....................     EP_BDxADR_O(0) = USB_BUFFER; 
1AC8:  MOVLW  05
1ACA:  MOVWF  x03
1ACC:  CLRF   x02
....................    #if USB_IGNORE_RX_DTS 
....................     EP_BDxST_O(0) = 0x80; //give control to SIE, data toggle synch off 
....................    #else 
....................     EP_BDxST_O(0) = 0x88; //give control to SIE, DATA0, data toggle synch on 
1ACE:  MOVLW  88
1AD0:  MOVWF  x00
....................    #endif 
....................  
....................     EP_BDxST_I(0) = 0; 
1AD2:  CLRF   x04
....................     EP_BDxADR_I(0) = USB_BUFFER + (int16)USB_MAX_EP0_PACKET_LENGTH; 
1AD4:  MOVLW  05
1AD6:  MOVWF  x07
1AD8:  MOVLW  40
1ADA:  MOVWF  x06
.................... } 
1ADC:  MOVLB  0
1ADE:  RETLW  00
....................  
.................... /******************************************************************************* 
.................... /* usb_isr_uerr() 
.................... /* 
.................... /* Summary: The USB peripheral had an error.  If user specified, error counter 
.................... /*          will incerement.  If having problems check the status of these 8 bytes. 
.................... /* 
.................... /* NOTE: This code is not enabled by default. 
.................... /********************************************************************************/ 
.................... void usb_isr_uerr() { 
.................... #if USB_USE_ERROR_COUNTER 
....................    int ints; 
.................... #endif 
....................  
....................    debug_usb(debug_putc,"E %X ",UEIR); 
....................  
.................... #if USB_USE_ERROR_COUNTER 
....................  
....................    ints=UEIR & UEIE; //mask off the flags with the ones that are enabled 
....................  
....................    if ( bit_test(ints,0) ) { //increment pid_error counter 
....................       debug_usb(debug_putc,"PID "); 
....................       ERROR_COUNTER[0]++; 
....................    } 
....................  
....................    if ( bit_test(ints,1) ) {  //increment crc5 error counter 
....................       debug_usbdebug_putc,"CRC5 "); 
....................       ERROR_COUNTER[1]++; 
....................    } 
....................  
....................    if ( bit_test(ints,2) ) {  //increment crc16 error counter 
....................       debug_usb(debug_putc,"CRC16 "); 
....................       ERROR_COUNTER[2]++; 
....................    } 
....................  
....................    if ( bit_test(ints,3) ) {  //increment dfn8 error counter 
....................       debug_usb(debug_putc,"DFN8 "); 
....................       ERROR_COUNTER[3]++; 
....................    } 
....................  
....................    if ( bit_test(ints,4) ) {  //increment bto error counter 
....................       debug_usb(debug_putc,"BTO "); 
....................       ERROR_COUNTER[4]++; 
....................    } 
....................  
....................    if ( bit_test(ints,7) ) { //increment bts error counter 
....................       debug_usb(debug_putc,"BTS "); 
....................       ERROR_COUNTER[5]++; 
....................    } 
.................... #endif 
....................  
....................    UEIR=0; 
*
1A3A:  CLRF   F6A
....................    UIR_UERR=0; 
1A3C:  BCF    F68.1
.................... } 
1A3E:  GOTO   26E2 (RETURN)
....................  
.................... /******************************************************************************* 
.................... /* usb_isr_uidle() 
.................... /* 
.................... /* Summary: USB peripheral detected IDLE.  Put the USB peripheral to sleep. 
.................... /* 
.................... /********************************************************************************/ 
.................... void usb_isr_uidle() { 
....................    debug_usb(debug_putc,"I"); 
....................  
....................    UIE_ACTV=1;   //enable activity interrupt flag. (we are now suspended until we get an activity interrupt. nice) 
*
1B0A:  BSF    F69.2
....................    UIR_IDLE=0; //clear idle interrupt flag 
1B0C:  BCF    F68.4
....................    UCON_SUSPND=1; //set suspend. we are now suspended 
1B0E:  BSF    F6D.1
.................... } 
1B10:  GOTO   26FA (RETURN)
....................  
....................  
.................... /******************************************************************************* 
.................... /* usb_isr_activity() 
.................... /* 
.................... /* Summary: USB peripheral detected activity on the USB device.  Wake-up the USB 
.................... /*          peripheral. 
.................... /* 
.................... /********************************************************************************/ 
.................... void usb_isr_activity() { 
....................    debug_usb(debug_putc,"A"); 
....................  
....................    UCON_SUSPND=0; //turn off low power suspending 
*
1A30:  BCF    F6D.1
....................    UIE_ACTV=0; //clear activity interupt enabling 
1A32:  BCF    F69.2
....................    UIR_ACTV=0; 
1A34:  BCF    F68.2
.................... } 
1A36:  GOTO   26D0 (RETURN)
....................  
.................... /******************************************************************************* 
.................... /* usb_isr_stall() 
.................... /* 
.................... /* Summary: Stall handshake detected. 
.................... /* 
.................... /********************************************************************************/ 
.................... void usb_isr_stall(void) { 
....................    debug_usb(debug_putc,"S"); 
....................  
....................    if (bit_test(UEP(0),0)) { 
*
1B1A:  BTFSS  F70.0
1B1C:  BRA    1B22
....................       usb_init_ep0_setup(); 
1B1E:  RCALL  1AC2
....................       bit_clear(UEP(0),0); 
1B20:  BCF    F70.0
....................    } 
....................    UIR_STALL=0; 
1B22:  BCF    F68.5
.................... } 
1B24:  GOTO   2712 (RETURN)
....................  
....................  
.................... /******************************************************************************* 
.................... /* usb_isr_tok_dne() 
.................... /* 
.................... /* Summary: A Token (IN/OUT/SETUP) has been received by the USB peripheral. 
.................... /*          If a setup token on EP0 was received, run the chapter 9 code and 
.................... /*          handle the request. 
.................... /*          If an IN token on EP0 was received, continue transmitting any 
.................... /*          unfinished requests that may take more than one packet to transmit 
.................... /*          (if necessary). 
.................... /*          If an OUT token on any other EP was received, mark that EP as ready 
.................... /*          for a usb_get_packet(). 
.................... /*          Does not handle any IN or OUT tokens on EP0. 
.................... /* 
.................... /********************************************************************************/ 
.................... void usb_isr_tok_dne() { 
....................    int8 en; 
....................  
....................    en=USTAT>>3; 
*
25CA:  RRCF   F6C,W
25CC:  MOVLB  1
25CE:  MOVWF  xB0
25D0:  RRCF   xB0,F
25D2:  RRCF   xB0,F
25D4:  MOVLW  1F
25D6:  ANDWF  xB0,F
....................  
....................          debug_usb(debug_putc,"T "); 
....................          debug_usb(debug_putc,"%X ", USTAT); 
....................  
....................       if (USTAT==USTAT_OUT_SETUP_E0) {   //new out or setup token in the buffer 
25D8:  MOVF   F6C,F
25DA:  BNZ   2668
....................          debug_usb(debug_putc,"%X ", EP_BDxST_O(0)); 
....................          if ((EP_BDxST_O(0) & 0x3C)==USB_PIC_PID_SETUP) { 
25DC:  MOVLB  4
25DE:  MOVF   x00,W
25E0:  ANDLW  3C
25E2:  SUBLW  34
25E4:  BNZ   2628
....................             EP_BDxST_I(0)=0;   // return the in buffer to us (dequeue any pending requests) 
25E6:  CLRF   x04
....................  
....................             debug_usb(debug_putc,"(%U) ", EP_BDxCNT_O(0)); 
....................             debug_display_ram(EP_BDxCNT_O(0), usb_ep0_rx_buffer); 
....................  
....................             usb_isr_tok_setup_dne(); 
25E8:  MOVLB  0
25EA:  BRA    21B2
....................  
....................             //if setup_0_tx_size==0xFF - stall ep0 (unhandled request) 
....................             //if setup_0_tx_size==0xFE - get EP0OUT ready for a data packet, leave EP0IN alone 
....................             //else setup_0_tx_size=size of response, get EP0OUT ready for a setup packet, mark EPOIN ready for transmit 
....................             if (__setup_0_tx_size==0xFF) 
25EC:  INCFSZ 27,W
25EE:  BRA    25FE
....................                usb_flush_out(0,USB_DTS_STALL); 
25F0:  MOVLB  1
25F2:  CLRF   xB1
25F4:  MOVLW  03
25F6:  MOVWF  xB2
25F8:  MOVLB  0
25FA:  RCALL  21DC
....................             else { 
25FC:  BRA    2622
....................                usb_flush_out(0,USB_DTS_TOGGLE); 
25FE:  MOVLB  1
2600:  CLRF   xB1
2602:  MOVLW  02
2604:  MOVWF  xB2
2606:  MOVLB  0
2608:  RCALL  21DC
....................                if (__setup_0_tx_size!=0xFE) { 
260A:  MOVF   27,W
260C:  SUBLW  FE
260E:  BZ    2622
....................                   usb_flush_in(0,__setup_0_tx_size,USB_DTS_USERX); 
2610:  MOVLB  1
2612:  CLRF   xBD
2614:  CLRF   xBF
2616:  MOVFF  27,1BE
261A:  MOVLW  04
261C:  MOVWF  xC0
261E:  MOVLB  0
2620:  RCALL  22CA
....................                } 
....................             } 
....................             UCON_PKTDIS=0;       // UCON,PKT_DIS ; Assuming there is nothing to dequeue, clear the packet disable bit 
2622:  BCF    F6D.4
....................          } 
....................          else if ((EP_BDxST_O(0) & 0x3C)==USB_PIC_PID_OUT) { 
2624:  BRA    2662
2626:  MOVLB  4
2628:  MOVF   x00,W
262A:  ANDLW  3C
262C:  SUBLW  04
262E:  BNZ   2664
....................             usb_isr_tok_out_dne(0); 
2630:  MOVLB  1
2632:  CLRF   xB1
2634:  MOVLB  0
2636:  RCALL  2452
....................             usb_flush_out(0,USB_DTS_TOGGLE); 
2638:  MOVLB  1
263A:  CLRF   xB1
263C:  MOVLW  02
263E:  MOVWF  xB2
2640:  MOVLB  0
2642:  RCALL  21DC
....................             if ((__setup_0_tx_size!=0xFE)&&(__setup_0_tx_size!=0xFF)) { 
2644:  MOVF   27,W
2646:  SUBLW  FE
2648:  BZ    2662
264A:  INCFSZ 27,W
264C:  BRA    2650
264E:  BRA    2662
....................                usb_flush_in(0,__setup_0_tx_size,USB_DTS_DATA1);   //send response (usually a 0len) 
2650:  MOVLB  1
2652:  CLRF   xBD
2654:  CLRF   xBF
2656:  MOVFF  27,1BE
265A:  MOVLW  01
265C:  MOVWF  xC0
265E:  MOVLB  0
2660:  RCALL  22CA
2662:  MOVLB  4
....................             } 
....................          } 
....................       } 
....................  
....................       else if (USTAT==USTAT_IN_E0) {   //pic -> host transfer completed 
2664:  BRA    26B4
2666:  MOVLB  1
2668:  MOVF   F6C,W
266A:  SUBLW  04
266C:  BNZ   269A
....................          __setup_0_tx_size=0xFF; 
266E:  MOVLW  FF
2670:  MOVWF  27
....................          usb_isr_tok_in_dne(0); 
2672:  CLRF   xB1
2674:  MOVLB  0
2676:  RCALL  2598
....................          if (__setup_0_tx_size!=0xFF) 
2678:  INCFSZ 27,W
267A:  BRA    267E
267C:  BRA    2692
....................             usb_flush_in(0,__setup_0_tx_size,USB_DTS_TOGGLE); 
267E:  MOVLB  1
2680:  CLRF   xBD
2682:  CLRF   xBF
2684:  MOVFF  27,1BE
2688:  MOVLW  02
268A:  MOVWF  xC0
268C:  MOVLB  0
268E:  RCALL  22CA
....................          else 
2690:  BRA    2696
....................             usb_init_ep0_setup(); 
2692:  CALL   1AC2
....................       } 
....................  
....................       else { 
2696:  BRA    26B2
2698:  MOVLB  1
....................          if (!bit_test(USTAT,2)) { 
269A:  BTFSC  F6C.2
269C:  BRA    26AA
....................             usb_isr_tok_out_dne(en); 
269E:  MOVFF  1B0,1B1
26A2:  MOVLB  0
26A4:  RCALL  2452
....................          } 
....................          else { 
26A6:  BRA    26B2
26A8:  MOVLB  1
....................             usb_isr_tok_in_dne(en); 
26AA:  MOVFF  1B0,1B1
26AE:  MOVLB  0
26B0:  RCALL  2598
26B2:  MOVLB  4
....................          } 
....................       } 
.................... } 
26B4:  MOVLB  0
26B6:  GOTO   271C (RETURN)
....................  
.................... /************************************************************** 
.................... /* usb_request_send_response(len) 
.................... /* usb_request_get_data() 
.................... /* usb_request_stall() 
.................... /* 
.................... /* Input: len - size of packet to send 
.................... /* 
.................... /* Summary: After we process a SETUP request, we have 1 of three responses: 
.................... /*            1.) send a response IN packet 
.................... /*            2.) wait for followup OUT packet(s) with data 
.................... /*            3.) stall because we don't support that SETUP request 
.................... /* 
.................... /*          If we are sending data, the array usb_ep0_tx_buffer[] will hold 
.................... /*          the response and the USB Request handler code will call 
.................... /*          usb_request_send_response() to let us know how big the packet is. 
.................... /* 
.................... /*          If we are waiting for more data, usb_request_get_data() will 
.................... /*          be called by the USB request handler code to configure the EP0 OUT 
.................... /*          endpoint to be ready for more data 
.................... /* 
.................... /*          If we don't support a request, usb_request_stall() will be called 
.................... /*          by the USB request handler code to stall the endpoint 0. 
.................... /* 
.................... /***************************************************************/ 
.................... void usb_request_send_response(int len) { 
....................    __setup_0_tx_size=len; 
*
1B28:  MOVFF  1B4,27
.................... } 
1B2C:  RETLW  00
....................  
.................... void usb_request_get_data(void) { 
....................    __setup_0_tx_size=0xFE; 
*
20FE:  MOVLW  FE
2100:  MOVWF  27
.................... } 
2102:  RETLW  00
....................  
.................... void usb_request_stall(void) { 
....................    __setup_0_tx_size=0xFF; 
*
1B2E:  MOVLW  FF
1B30:  MOVWF  27
.................... } 
1B32:  RETLW  00
....................  
.................... /// END USB Interrupt Service Routine 
....................  
.................... #ENDIF 
....................  
....................  #endif 
.................... #else 
....................  #include <usbn960x.c>   //National 960x hardware layer for usb.c 
.................... #endif 
.................... #include "usb_desc_cdc.h"	//USB Configuration and Device descriptors for this UBS device 
.................... /* 
....................  * Copylight (C) 2009, Shunichi Yamamoto, tkrworks.net 
....................  * 
....................  * This file is part of PICnome. 
....................  * 
....................  * PICnome is free software: you can redistribute it and/or modify 
....................  * it under the terms of the GNU General Public License as published by 
....................  * the Free Software Foundation, either version 3 of the License, or 
....................  * (at your option ) any later version. 
....................  * 
....................  * PICnome is distributed in the hope that it will be useful, 
....................  * but WITHIOUT ANY WARRANTY; without even the implied warranty of 
....................  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.   See the 
....................  * GNU General Public License for more details. 
....................  * 
....................  * You should have received a copy of the GNU General Public License 
....................  * along with PICnome. if not, see <http:/www.gnu.org/licenses/>. 
....................  * 
....................  * usb_desc_cdc.h,v.1.0.23 2010/07/05 
....................  */ 
....................  
.................... #IFNDEF __USB_DESCRIPTORS__ 
.................... #DEFINE __USB_DESCRIPTORS__ 
....................  
.................... #include <usb.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                              usb.h                                //// 
.................... ////                                                                   //// 
.................... //// Function protypes, defintions and globals used by CCS USB driver  //// 
.................... ////                                                                   //// 
.................... //// This file is part of CCS's PIC USB driver code, which includes:   //// 
.................... ////   usb_desc_*.h - an example set of config and device descriptor   //// 
.................... ////   usb.c - USB token and request handler code                      //// 
.................... ////   usb.h - definitions, prototypes and global variables            //// 
.................... ////                                                                   //// 
.................... //// The following examples are provided by CCS:                       //// 
.................... ////   ex_usb_mouse.c - A HID Mouse.                                   //// 
.................... ////   ex_usb_hid.c - A custom application using HID protocol.         //// 
.................... ////   ex_usb_kbmouse.c - A HID Mouse/Keyboard combo using multiple    //// 
.................... ////                      interfaces.                                  //// 
.................... ////   ex_usb_kbmouse.c - A HID Mouse/Keyboard combo using multiple    //// 
.................... ////                      HID Reports.                                 //// 
.................... ////   ex_usb_scope.c - A digital oscilloscope using a custom          //// 
.................... ////                    protocol requiring custom Windows drivers.     //// 
.................... ////                                                                   //// 
.................... ////                   **** DEFINITIONS *****                          //// 
.................... //// The following definitions are declared here, but can be           //// 
.................... //// overwritten in your code.  Unless needed otherwise, leave         //// 
.................... //// to default value.  If confused about a definition read the        //// 
.................... //// comments at each defintion                                        //// 
.................... ////                                                                   //// 
.................... //// USB_HID_IDLE (FALSE) - Set to TRUE if your device supports        //// 
.................... ////                            Set_Idle HID class request.  Set to    //// 
.................... ////                            False if you do not (device will       //// 
.................... ////                            send a Wrong-state if computer         //// 
.................... ////                            sends a Set_Idle / Get_Idle command)   //// 
.................... ////                            NOTE: If you set to TRUE you must      //// 
.................... ////                            provide your own code.  See            //// 
.................... ////                            usb_isr_tkn_setup_ClassInterface() in  //// 
.................... ////                            usb.c                                  //// 
.................... ////                                                                   //// 
.................... //// USB_HID_BOOT_PROTOCOL (FALSE) - Set to TRUE if your device supports   //// 
.................... ////                            Set_Protocl HID class request. Set to  //// 
.................... ////                            False if you do not (device will       //// 
.................... ////                            send a Wrong-state if computer         //// 
.................... ////                            sends a Set_Protocl / Get_Protocol     //// 
.................... ////                            command).                              //// 
.................... ////                            NOTE: If you set to TRUE you must      //// 
.................... ////                            provide your own code in the           //// 
.................... ////                            application that properly send boot    //// 
.................... ////                            or HID packets.                        //// 
.................... ////                                                                   //// 
.................... //// USB_MAX_EP0_PACKET_LENGTH (8) - Max Packet size for Endpoint 0.   //// 
.................... ////                            Only the 18Fxx5x USB peripheral can    //// 
.................... ////                            have a value larger than 8.            //// 
.................... ////                                                                   //// 
.................... //// USB_EPx_RX_ENABLE (USB_ENABLE_DISABLED) - Where x is the          //// 
.................... ////                         endpoint number. Change this define       //// 
.................... ////                         to specify what kind of transfer method   //// 
.................... ////                         this RX (PC to device) endpoint uses.     //// 
.................... ////                       Here is the list of valid transfer methods: //// 
.................... ////                             USB_ENABLE_CONTROL                    //// 
.................... ////                             USB_ENABLE_ISOCHRONOUS                //// 
.................... ////                             USB_ENABLE_BULK                       //// 
.................... ////                             USB_ENABLE_INTERRUPT                  //// 
.................... ////                             USB_ENABLE_DISABLED                   //// 
.................... ////                        Don't forget that you must specify the     //// 
.................... ////                        transfer method properly in your endpoint  //// 
.................... ////                        descriptor, too.                           //// 
.................... ////                                                                   //// 
.................... //// USB_EPx_RX_SIZE (0) - For some hardware it is important to know   //// 
.................... ////                       how much memory to reserve for receiving    //// 
.................... ////                       packets.                                    //// 
.................... ////                                                                   //// 
.................... ////  *** NOTE *** You must have both USB_EPx_RX_ENABLE defined and    //// 
.................... ////               USB_EPx_RX_SIZE defined (non 0) to enable a RX      //// 
.................... ////               endpoint.                                           //// 
.................... ////  *** NOTE *** Endpoint 0 is always enabled.                       //// 
.................... ////                                                                   //// 
.................... //// USB_EPx_TX_ENABLE (USB_ENABLE_DISABLED) - Where x is the          //// 
.................... ////                         endpoint number. Change this define       //// 
.................... ////                         to specify what kind of transfer method   //// 
.................... ////                         this TX (device to PC) endpoint uses.     //// 
.................... ////                       Here is the list of valid transfer methods: //// 
.................... ////                             USB_ENABLE_CONTROL                    //// 
.................... ////                             USB_ENABLE_ISOCHRONOUS                //// 
.................... ////                             USB_ENABLE_BULK                       //// 
.................... ////                             USB_ENABLE_INTERRUPT                  //// 
.................... ////                             USB_ENABLE_DISABLED                   //// 
.................... ////                        Don't forget that you must specify the     //// 
.................... ////                        transfer method properly in your endpoint  //// 
.................... ////                        descriptor, too.                           //// 
.................... ////                                                                   //// 
.................... //// USB_EPx_TX_SIZE (0) - For some hardware it is important to know   //// 
.................... ////                       how much memory to reserve for transmitting //// 
.................... ////                       packets.                                    //// 
.................... ////                                                                   //// 
.................... ////  *** NOTE *** You must have both USB_EPx_TX_ENABLE defined and    //// 
.................... ////               USB_EPx_TX_SIZE defined (non 0) to enable a TX      //// 
.................... ////               endpoint.                                           //// 
.................... ////                                                                   //// 
.................... ////                                                                   //// 
.................... //// USB_HID_DEVICE (TRUE) - HID devices require extra code to handle  //// 
.................... ////                         HID requests.  You can disable to save    //// 
.................... ////                         ROM space if you are not using a HID      //// 
.................... ////                         device.  If you are not using a HID       //// 
.................... ////                         device you must provide your own O/S      //// 
.................... ////                         (Windows) driver.                         //// 
.................... ////                                                                   //// 
.................... //// The other definitions should not be changed.                      //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... //// Version History:                                                  //// 
.................... ////                                                                   //// 
.................... //// July 13th, 2005:                                                  //// 
.................... ////  usb_ep_tx_size[] and usb_ep_rx_size[] changed to 16bits          //// 
.................... ////                                                                   //// 
.................... //// June 20th, 2005:                                                  //// 
.................... ////  Initial 18fxx5x release                                          //// 
.................... ////                                                                   //// 
.................... //// May 13th, 2005:                                                   //// 
.................... ////  Beta release, only works with 18Fxx5x hardware layer.            //// 
.................... ////  Now supports multiple interfaces (many defines in descriptors    //// 
.................... ////   will have to be changed, see examples)                          //// 
.................... ////                                                                   //// 
.................... //// Mar 21st, 2005:                                                   //// 
.................... ////  Initial Alpha Release with PIC18Fxx5x support.  (ONLY TESTED     //// 
.................... ////   WITH 18F4550)                                                   //// 
.................... ////  usb_gets() and usb_puts() changed (see usb.c)                    //// 
.................... ////                                                                   //// 
.................... //// June 24th, 2004:                                                  //// 
.................... ////  Optimization and cleanup.                                        //// 
.................... ////                The following definitions changed:                 //// 
.................... ////  USB_EPx_TX_ENABLE and USB_EPx_RX_ENABLE have changed. See usb.h  //// 
.................... ////  USB_CONFIG_DESCRIPTORS[] removed                                 //// 
.................... ////  USB_CONFIG_DESC_LEN changed to USB_DESC_CONFIG_LEN               //// 
.................... ////  USB_INTERFACE_DESC_LEN changed to USB_DESC_INTERFACE_LEN         //// 
.................... ////  USB_CLASS_DESC_LEN changed to USB_DESC_CLASS_LEN                 //// 
.................... ////  USB_ENDPOINT_DESC_LEN changed to USB_DESC_ENDPOINT_LEN           //// 
.................... ////  USB_CONFIG_DESC_KEY changed to USB_DESC_CONFIG_TYPE              //// 
.................... ////  USB_INTERFACE_DESC_KEY changed to USB_DESC_INTERFACE_TYPE        //// 
.................... ////  USB_CLASS_DESC_KEY changed to USB_DESC_CLASS_TYPE                //// 
.................... ////  USB_ENDPOINT_DESC_KEY changed to USB_DESC_ENDPOINT_TYPE          //// 
.................... ////  USB_STRING_X[] arrays removed, see USB_STRING_DESC[] and         //// 
.................... ////                                 USB_STRING_DESC_OFFSET[]          //// 
.................... ////  dev_req, curr_config, status_device and getdesc_type global      //// 
.................... ////        variables moved into struct USB_stack_status               //// 
.................... ////                                                                   //// 
.................... //// October 15th, 2003: Support for boot protocol added.              //// 
.................... ////         Set USB_HID_BOOT_PROTOCOL to TRUE to support this.        //// 
.................... ////         The array hid_protocol[] saves which protocol mode each   //// 
.................... ////         interface is in.  It is your applications job to send     //// 
.................... ////         data that either fit the boot protocol or HID protocol.   //// 
.................... ////                                                                   //// 
.................... //// May 6th, 2003: Fixed a potential stack overflow using PCM         //// 
.................... ////                                                                   //// 
.................... //// October 29th, 2002: New definition added to USB_STATES            //// 
.................... ////                                                                   //// 
.................... //// August 2nd, 2002: Initial Public Release                          //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2005 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS    //// 
.................... //// C compiler.  This source code may only be distributed to other    //// 
.................... //// licensed users of the CCS C compiler.  No other use,              //// 
.................... //// reproduction or distribution is permitted without written         //// 
.................... //// permission.  Derivative programs created using this software      //// 
.................... //// in object code form are not restricted in any way.                //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
....................  
.................... #IFNDEF __USB_PROTOTYPES__ 
.................... #DEFINE __USB_PROTOTYPES__ 
....................  
.................... #IFNDEF USB_HID_BOOT_PROTOCOL 
....................    #DEFINE USB_HID_BOOT_PROTOCOL FALSE 
.................... #ENDIF 
....................  
.................... #IFNDEF USB_HID_IDLE 
....................    #DEFINE USB_HID_IDLE FALSE 
.................... #ENDIF 
....................  
.................... //should the compiler add the extra HID handler code?  Defaults to yes. 
.................... #IFNDEF USB_HID_DEVICE 
....................    #DEFINE USB_HID_DEVICE TRUE 
.................... #ENDIF 
....................  
.................... #IFNDEF USB_CDC_DEVICE 
....................    #DEFINE USB_CDC_DEVICE FALSE 
.................... #ENDIF 
....................  
.................... #ifndef USB_OPT_FOR_ROM 
....................    #define USB_OPT_FOR_ROM TRUE  //set to false to opt for less RAM, true to opt for less ROM 
.................... #endif 
....................  
.................... #IFNDEF USB_MAX_EP0_PACKET_LENGTH 
....................   #DEFINE USB_MAX_EP0_PACKET_LENGTH 8 
.................... #ENDIF 
....................  
.................... //CCS only supports one configuration at this time 
.................... #DEFINE USB_NUM_CONFIGURATIONS 1 //DO NOT CHANGE 
....................  
.................... //PID values for tokens (see page 48 of USB Complete ed.1) 
.................... #define PID_IN       0x09  //device to host transactions 
.................... #define PID_OUT      0x01  //host to device transactions 
.................... #define PID_SETUP    0x0D  //host to device setup transaction 
.................... #define PID_ACK      0x02  //receiver accepts error-free data packet 
.................... #define PID_DATA0    0x03  //data packet with even sync bit 
.................... #define PID_SOF      0x05  //start of framer marker and frame number 
.................... #define PID_NAK      0x0A  //receiver can't accept data or sender cant send data or has no data to transmit 
.................... #define PID_DATA1    0x0B  //data packet with odd sync bit 
.................... #define PID_PRE      0x0C  //preamble issued by host.  enables downstream traffic to low-speed device 
.................... #define PID_STALL    0x0E  //a control request isnt supported or the endpoint is halted 
....................  
.................... //Key which identifies descritpors 
.................... #DEFINE USB_DESC_DEVICE_TYPE     0x01  //#DEFINE USB_DEVICE_DESC_KEY      0x01 
.................... #DEFINE USB_DESC_CONFIG_TYPE     0x02  //#DEFINE USB_CONFIG_DESC_KEY      0x02 
.................... #DEFINE USB_DESC_STRING_TYPE     0x03  //#DEFINE USB_STRING_DESC_KEY      0x03 
.................... #DEFINE USB_DESC_INTERFACE_TYPE  0x04  //#DEFINE USB_INTERFACE_DESC_KEY   0x04 
.................... #DEFINE USB_DESC_ENDPOINT_TYPE   0x05  //#DEFINE USB_ENDPOINT_DESC_KEY    0x05 
.................... #DEFINE USB_DESC_CLASS_TYPE      0x21  //#DEFINE USB_CLASS_DESC_KEY       0x21 
.................... #DEFINE USB_DESC_HIDREPORT_TYPE  0x22 
....................  
.................... //The length of each descriptor 
.................... #DEFINE USB_DESC_DEVICE_LEN      18 //#DEFINE USB_DEVICE_DESC_LEN      18 
.................... #DEFINE USB_DESC_CONFIG_LEN      9  //#DEFINE USB_CONFIG_DESC_LEN      9 
.................... #DEFINE USB_DESC_INTERFACE_LEN   9  //#DEFINE USB_INTERFACE_DESC_LEN   9 
.................... #DEFINE USB_DESC_CLASS_LEN       9  //#DEFINE USB_CLASS_DESC_LEN       9 
.................... #DEFINE USB_DESC_ENDPOINT_LEN    7  //#DEFINE USB_ENDPOINT_DESC_LEN    7 
....................  
.................... //Standard USB Setup bRequest Codes 
.................... #define USB_STANDARD_REQUEST_GET_STATUS         0x00 
.................... #define USB_STANDARD_REQUEST_CLEAR_FEATURE      0x01 
.................... #define USB_STANDARD_REQUEST_SET_FEATURE        0x03 
.................... #define USB_STANDARD_REQUEST_SET_ADDRESS        0x05 
.................... #define USB_STANDARD_REQUEST_GET_DESCRIPTOR     0x06 
.................... #define USB_STANDARD_REQUEST_SET_DESCRIPTOR     0x07 
.................... #define USB_STANDARD_REQUEST_GET_CONFIGURATION  0x08 
.................... #define USB_STANDARD_REQUEST_SET_CONFIGURATION  0x09 
.................... #define USB_STANDARD_REQUEST_GET_INTERFACE      0x0A 
.................... #define USB_STANDARD_REQUEST_SET_INTERFACE      0x0B 
.................... #define USB_STANDARD_REQUEST_SYNCH_FRAME        0x0C 
....................  
.................... //HID Class Setup bRequest Codes 
.................... #define USB_HID_REQUEST_GET_REPORT     0x01 
.................... #define USB_HID_REQUEST_GET_IDLE       0x02 
.................... #define USB_HID_REQUEST_GET_PROTOCOL   0x03 
.................... #define USB_HID_REQUEST_SET_REPORT     0x09 
.................... #define USB_HID_REQUEST_SET_IDLE       0x0A 
.................... #define USB_HID_REQUEST_SET_PROTOCOL   0x0B 
....................  
.................... //types of endpoints as defined in the descriptor 
.................... #define USB_ENDPOINT_TYPE_CONTROL      0x00 
.................... #define USB_ENDPOINT_TYPE_ISOCHRONOUS  0x01 
.................... #define USB_ENDPOINT_TYPE_BULK         0x02 
.................... #define USB_ENDPOINT_TYPE_INTERRUPT    0x03 
....................  
.................... //types of endpoints used internally in this api 
.................... #define USB_ENABLE_DISABLED     0 
.................... #define USB_ENABLE_BULK         0x01 
.................... #define USB_ENABLE_ISOCHRONOUS  0x02 
.................... #define USB_ENABLE_INTERRUPT    0x03 
.................... #define USB_ENABLE_CONTROL      0x04 
....................  
.................... //// DO NOT CHANGE THE FOLLOWING VALUES: 
....................  
.................... enum USB_STATES {GET_DESCRIPTOR=1,SET_ADDRESS=2,NONE=0}; 
....................  
.................... enum USB_DTS_BIT {USB_DTS_DATA1=1, USB_DTS_TOGGLE=2, USB_DTS_DATA0=0, 
....................                    USB_DTS_STALL=3, USB_DTS_USERX=4}; 
....................  
.................... enum USB_GETDESC_TYPES {USB_GETDESC_CONFIG_TYPE=0,USB_GETDESC_HIDREPORT_TYPE=1,USB_GETDESC_STRING_TYPE=2,USB_GETDESC_DEVICE_TYPE=3}; 
....................  
.................... #if USB_OPT_FOR_ROM 
.................... struct { 
....................    USB_STATES dev_req;   //what did the last setup token set us up to do?.  init at none 
....................    int  curr_config;  //our current config.  start at none/powered (NOT THAT THIS LIMITS US TO 3 CONFIGURATIONS) 
....................    int status_device; //Holds our state for Set_Feature and Clear_Feature 
....................    USB_GETDESC_TYPES getdesc_type;   //which get_descriptor() we are handling 
.................... } USB_stack_status; 
.................... #else 
.................... struct { 
....................    USB_STATES dev_req:2;   //what did the last setup token set us up to do?.  init at none 
....................    int  Curr_config:2;  //our current config.  start at none/powered (NOT THAT THIS LIMITS US TO 3 CONFIGURATIONS) 
....................    int status_device:2; //Holds our state for Set_Feature and Clear_Feature 
....................    USB_GETDESC_TYPES getdesc_type:2;   //which get_descriptor() we are handling 
.................... } USB_stack_status; 
.................... #endif 
....................  
.................... int16 __usb_kbhit_status; 
....................  
.................... /// *** User function prototypes 
.................... void usb_wait_for_enumeration(void); 
.................... int1 usb_unermated(void); 
.................... int8 usb_gets(int8 endpoint, int8 * ptr, int16 max, int16 timeout); 
.................... int1 usb_puts(int8 endpoint, int8 * ptr, int16 len, int8 timeout); 
....................  
.................... /// *** Token and request hanlder function prototypes 
.................... void usb_token_reset(); 
....................  
.................... void usb_put_0len_0(void); 
.................... void usb_request_send_response(int len);   //always sends usb_ep0_rx_buffer[] to endpoint 0 with a toggle of DATA 
....................  
.................... void usb_match_registers(int8 endpoint, int16 *status, int16 *buffer, int8 *size); 
....................  
.................... void usb_isr_tok_in_dne(int8 endpoint); 
.................... void usb_isr_tok_out_dne(int8 endpoint); 
.................... void usb_isr_tok_setup_dne(void); 
....................  
.................... void usb_isr_tkn_setup_StandardEndpoint(void); 
.................... void usb_isr_tkn_setup_StandardDevice(void); 
.................... void usb_isr_tkn_setup_StandardInterface(void); 
....................  
.................... #IF USB_HID_DEVICE 
....................    void usb_isr_tkn_setup_ClassInterface(void); 
.................... #ENDIF 
....................  
.................... void usb_Get_Descriptor(void); 
.................... void usb_copy_desc_seg_to_ep(void); 
....................  
.................... void usb_finish_set_address(void); 
....................  
.................... //*** ENABLE RX ENDPOINTS AND BUFFERS 
....................  
.................... //--------- endpoint 0 defines ---------- 
.................... #define USB_EP0_TX_ENABLE  USB_ENABLE_CONTROL 
.................... #define USB_EP0_RX_ENABLE  USB_ENABLE_CONTROL 
.................... #define USB_EP0_RX_SIZE    USB_MAX_EP0_PACKET_LENGTH  //endpoint 0 is setup, and should always be the MAX_PACKET_LENGTH.  Slow speed specifies 8 
.................... #define USB_EP0_TX_SIZE    USB_MAX_EP0_PACKET_LENGTH  //endpoint 0 is setup, and should always be the MAX_PACKET_LENGTH.  Slow speed specifies 8 
....................  
.................... //--------- endpoint 1 defines ---------- 
.................... #ifndef USB_EP1_TX_ENABLE 
....................  #define USB_EP1_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP1_RX_ENABLE 
....................  #define USB_EP1_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP1_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP1_RX_SIZE 
....................   #undef USB_EP1_RX_SIZE 
....................  #endif 
....................  #define USB_EP1_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP1_RX_SIZE 
....................   #error You enabled EP1 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP1_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP1_TX_SIZE 
....................   #undef USB_EP1_TX_SIZE 
....................  #endif 
....................  #define USB_EP1_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP1_TX_SIZE 
....................   #error You enabled EP1 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 2 defines ---------- 
.................... #ifndef USB_EP2_TX_ENABLE 
....................  #define USB_EP2_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP2_RX_ENABLE 
....................  #define USB_EP2_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP2_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP2_RX_SIZE 
....................   #undef USB_EP2_RX_SIZE 
....................  #endif 
....................  #define USB_EP2_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP2_RX_SIZE 
....................   #error You enabled EP2 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP2_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP2_TX_SIZE 
....................   #undef USB_EP2_TX_SIZE 
....................  #endif 
....................  #define USB_EP2_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP2_TX_SIZE 
....................   #error You enabled EP2 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 3 defines ---------- 
.................... #ifndef USB_EP3_TX_ENABLE 
....................  #define USB_EP3_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP3_RX_ENABLE 
....................  #define USB_EP3_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP3_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP3_RX_SIZE 
....................   #undef USB_EP3_RX_SIZE 
....................  #endif 
....................  #define USB_EP3_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP3_RX_SIZE 
....................   #error You enabled EP3 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP3_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP3_TX_SIZE 
....................   #undef USB_EP3_TX_SIZE 
....................  #endif 
....................  #define USB_EP3_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP3_TX_SIZE 
....................   #error You enabled EP3 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 4 defines ---------- 
.................... #ifndef USB_EP4_TX_ENABLE 
....................  #define USB_EP4_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP4_RX_ENABLE 
....................  #define USB_EP4_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP4_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP4_RX_SIZE 
....................   #undef USB_EP4_RX_SIZE 
....................  #endif 
....................  #define USB_EP4_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP4_RX_SIZE 
....................   #error You enabled EP4 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP4_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP4_TX_SIZE 
....................   #undef USB_EP4_TX_SIZE 
....................  #endif 
....................  #define USB_EP4_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP4_TX_SIZE 
....................   #error You enabled EP4 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 5 defines ---------- 
.................... #ifndef USB_EP5_TX_ENABLE 
....................  #define USB_EP5_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP5_RX_ENABLE 
....................  #define USB_EP5_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP5_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP5_RX_SIZE 
....................   #undef USB_EP5_RX_SIZE 
....................  #endif 
....................  #define USB_EP5_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP5_RX_SIZE 
....................   #error You enabled EP5 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP5_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP5_TX_SIZE 
....................   #undef USB_EP5_TX_SIZE 
....................  #endif 
....................  #define USB_EP5_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP5_TX_SIZE 
....................   #error You enabled EP5 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 6 defines ---------- 
.................... #ifndef USB_EP6_TX_ENABLE 
....................  #define USB_EP6_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP6_RX_ENABLE 
....................  #define USB_EP6_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP6_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP6_RX_SIZE 
....................   #undef USB_EP6_RX_SIZE 
....................  #endif 
....................  #define USB_EP6_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP6_RX_SIZE 
....................   #error You enabled EP6 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP6_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP6_TX_SIZE 
....................   #undef USB_EP6_TX_SIZE 
....................  #endif 
....................  #define USB_EP6_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP6_TX_SIZE 
....................   #error You enabled EP6 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 7 defines ---------- 
.................... #ifndef USB_EP7_TX_ENABLE 
....................  #define USB_EP7_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP7_RX_ENABLE 
....................  #define USB_EP7_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP7_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP7_RX_SIZE 
....................   #undef USB_EP7_RX_SIZE 
....................  #endif 
....................  #define USB_EP7_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP7_RX_SIZE 
....................   #error You enabled EP7 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP7_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP7_TX_SIZE 
....................   #undef USB_EP7_TX_SIZE 
....................  #endif 
....................  #define USB_EP7_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP7_TX_SIZE 
....................   #error You enabled EP7 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 8 defines ---------- 
.................... #ifndef USB_EP8_TX_ENABLE 
....................  #define USB_EP8_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP8_RX_ENABLE 
....................  #define USB_EP8_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP8_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP8_RX_SIZE 
....................   #undef USB_EP8_RX_SIZE 
....................  #endif 
....................  #define USB_EP8_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP8_RX_SIZE 
....................   #error You enabled EP8 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP8_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP8_TX_SIZE 
....................   #undef USB_EP8_TX_SIZE 
....................  #endif 
....................  #define USB_EP8_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP8_TX_SIZE 
....................   #error You enabled EP8 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 9 defines ---------- 
.................... #ifndef USB_EP9_TX_ENABLE 
....................  #define USB_EP9_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP9_RX_ENABLE 
....................  #define USB_EP9_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP9_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP9_RX_SIZE 
....................   #undef USB_EP9_RX_SIZE 
....................  #endif 
....................  #define USB_EP9_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP9_RX_SIZE 
....................   #error You enabled EP9 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP9_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP9_TX_SIZE 
....................   #undef USB_EP9_TX_SIZE 
....................  #endif 
....................  #define USB_EP9_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP9_TX_SIZE 
....................   #error You enabled EP9 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 10 defines ---------- 
.................... #ifndef USB_EP10_TX_ENABLE 
....................  #define USB_EP10_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP10_RX_ENABLE 
....................  #define USB_EP10_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP10_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP10_RX_SIZE 
....................   #undef USB_EP10_RX_SIZE 
....................  #endif 
....................  #define USB_EP10_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP10_RX_SIZE 
....................   #error You enabled EP10 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP10_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP10_TX_SIZE 
....................   #undef USB_EP10_TX_SIZE 
....................  #endif 
....................  #define USB_EP10_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP10_TX_SIZE 
....................   #error You enabled EP10 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 11 defines ---------- 
.................... #ifndef USB_EP11_TX_ENABLE 
....................  #define USB_EP11_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP11_RX_ENABLE 
....................  #define USB_EP11_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP11_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP11_RX_SIZE 
....................   #undef USB_EP11_RX_SIZE 
....................  #endif 
....................  #define USB_EP11_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP11_RX_SIZE 
....................   #error You enabled EP11 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP11_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP11_TX_SIZE 
....................   #undef USB_EP11_TX_SIZE 
....................  #endif 
....................  #define USB_EP11_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP11_TX_SIZE 
....................   #error You enabled EP11 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 12 defines ---------- 
.................... #ifndef USB_EP12_TX_ENABLE 
....................  #define USB_EP12_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP12_RX_ENABLE 
....................  #define USB_EP12_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP12_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP12_RX_SIZE 
....................   #undef USB_EP12_RX_SIZE 
....................  #endif 
....................  #define USB_EP12_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP12_RX_SIZE 
....................   #error You enabled EP12 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP12_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP12_TX_SIZE 
....................   #undef USB_EP12_TX_SIZE 
....................  #endif 
....................  #define USB_EP12_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP12_TX_SIZE 
....................   #error You enabled EP12 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 13 defines ---------- 
.................... #ifndef USB_EP13_TX_ENABLE 
....................  #define USB_EP13_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP13_RX_ENABLE 
....................  #define USB_EP13_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP13_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP13_RX_SIZE 
....................   #undef USB_EP13_RX_SIZE 
....................  #endif 
....................  #define USB_EP13_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP13_RX_SIZE 
....................   #error You enabled EP13 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP13_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP13_TX_SIZE 
....................   #undef USB_EP13_TX_SIZE 
....................  #endif 
....................  #define USB_EP13_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP13_TX_SIZE 
....................   #error You enabled EP13 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 14 defines ---------- 
.................... #ifndef USB_EP14_TX_ENABLE 
....................  #define USB_EP14_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP14_RX_ENABLE 
....................  #define USB_EP14_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP14_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP14_RX_SIZE 
....................   #undef USB_EP14_RX_SIZE 
....................  #endif 
....................  #define USB_EP14_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP14_RX_SIZE 
....................   #error You enabled EP14 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP14_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP14_TX_SIZE 
....................   #undef USB_EP14_TX_SIZE 
....................  #endif 
....................  #define USB_EP14_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP14_TX_SIZE 
....................   #error You enabled EP14 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 15 defines ---------- 
.................... #ifndef USB_EP15_TX_ENABLE 
....................  #define USB_EP15_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP15_RX_ENABLE 
....................  #define USB_EP15_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP15_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP15_RX_SIZE 
....................   #undef USB_EP15_RX_SIZE 
....................  #endif 
....................  #define USB_EP15_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP15_RX_SIZE 
....................   #error You enabled EP15 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP15_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP15_TX_SIZE 
....................   #undef USB_EP15_TX_SIZE 
....................  #endif 
....................  #define USB_EP15_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP15_TX_SIZE 
....................   #error You enabled EP15 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... const int8 usb_ep_tx_type[16]={ 
....................   USB_EP0_TX_ENABLE, USB_EP1_TX_ENABLE, USB_EP2_TX_ENABLE, 
....................   USB_EP3_TX_ENABLE, USB_EP4_TX_ENABLE, USB_EP5_TX_ENABLE, 
....................   USB_EP6_TX_ENABLE, USB_EP7_TX_ENABLE, USB_EP8_TX_ENABLE, 
....................   USB_EP9_TX_ENABLE, USB_EP10_TX_ENABLE, USB_EP11_TX_ENABLE, 
....................   USB_EP12_TX_ENABLE, USB_EP13_TX_ENABLE, USB_EP14_TX_ENABLE, 
....................   USB_EP15_TX_ENABLE 
.................... }; 
....................  
.................... const int8 usb_ep_rx_type[16]={ 
....................   USB_EP0_RX_ENABLE, USB_EP1_RX_ENABLE, USB_EP2_RX_ENABLE, 
....................   USB_EP3_RX_ENABLE, USB_EP4_RX_ENABLE, USB_EP5_RX_ENABLE, 
....................   USB_EP6_RX_ENABLE, USB_EP7_RX_ENABLE, USB_EP8_RX_ENABLE, 
....................   USB_EP9_RX_ENABLE, USB_EP10_RX_ENABLE, USB_EP11_RX_ENABLE, 
....................   USB_EP12_RX_ENABLE, USB_EP13_RX_ENABLE, USB_EP14_RX_ENABLE, 
....................   USB_EP15_RX_ENABLE 
.................... }; 
....................  
.................... const int16 usb_ep_tx_size[16]={ 
....................   USB_EP0_TX_SIZE, USB_EP1_TX_SIZE, USB_EP2_TX_SIZE, 
....................   USB_EP3_TX_SIZE, USB_EP4_TX_SIZE, USB_EP5_TX_SIZE, 
....................   USB_EP6_TX_SIZE, USB_EP7_TX_SIZE, USB_EP8_TX_SIZE, 
....................   USB_EP9_TX_SIZE, USB_EP10_TX_SIZE, USB_EP11_TX_SIZE, 
....................   USB_EP12_TX_SIZE, USB_EP13_TX_SIZE, USB_EP14_TX_SIZE, 
....................   USB_EP15_TX_SIZE 
.................... }; 
....................  
.................... const int16 usb_ep_rx_size[16]={ 
....................   USB_EP0_RX_SIZE, USB_EP1_RX_SIZE, USB_EP2_RX_SIZE, 
....................   USB_EP3_RX_SIZE, USB_EP4_RX_SIZE, USB_EP5_RX_SIZE, 
....................   USB_EP6_RX_SIZE, USB_EP7_RX_SIZE, USB_EP8_RX_SIZE, 
....................   USB_EP9_RX_SIZE, USB_EP10_RX_SIZE, USB_EP11_RX_SIZE, 
....................   USB_EP12_RX_SIZE, USB_EP13_RX_SIZE, USB_EP14_RX_SIZE, 
....................   USB_EP15_RX_SIZE 
.................... }; 
....................  
.................... #ENDIF 
....................  
....................  
....................  
.................... ////////////////////////////////////////////////////////////////// 
.................... /// 
.................... ///   start config descriptor 
.................... ///   right now we only support one configuration descriptor. 
.................... ///   the config, interface, class, and endpoint goes into this array. 
.................... /// 
.................... ////////////////////////////////////////////////////////////////// 
....................  
....................    #DEFINE USB_TOTAL_CONFIG_LEN      67  //config+interface+class+endpoint+endpoint (2 endpoints) 
....................  
....................    const char USB_CONFIG_DESC[] = { 
....................    //IN ORDER TO COMPLY WITH WINDOWS HOSTS, THE ORDER OF THIS ARRAY MUST BE: 
....................       //    config(s) 
....................       //    interface(s) 
....................       //    class(es) 
....................       //    endpoint(s) 
....................  
....................    //config_descriptor for config index 1 
....................          USB_DESC_CONFIG_LEN, //length of descriptor size          ==0 
....................          USB_DESC_CONFIG_TYPE, //constant CONFIGURATION (CONFIGURATION 0x02)     ==1 
....................          USB_TOTAL_CONFIG_LEN,0, //size of all data returned for this config      ==2,3 
....................          2, //number of interfaces this device supports       ==4 
....................          0x01, //identifier for this configuration.  (IF we had more than one configurations)      ==5 
....................          0x00, //index of string descriptor for this configuration      ==6 
....................          0xC0, //bit 6=1 if self powered, bit 5=1 if supports remote wakeup (we don't), bits 0-4 unused and bit7=1         ==7 
....................          0xFA, //sy 500mA 0x32, //maximum bus power required (maximum milliamperes/2)  (0x32 = 100mA)  ==8 
....................  
....................    //interface descriptor 0 (comm class interface) 
....................          USB_DESC_INTERFACE_LEN, //length of descriptor      =9 
....................          USB_DESC_INTERFACE_TYPE, //constant INTERFACE (INTERFACE 0x04)       =10 
....................          0x00, //number defining this interface (IF we had more than one interface)    ==11 
....................          0x00, //alternate setting     ==12 
....................          1, //number of endpoints   ==13 
....................          0x02, //class code, 02 = Comm Interface Class     ==14 
....................          0x02, //subclass code, 2 = Abstract     ==15 
....................          0x01, //protocol code, 1 = v.25ter      ==16 
....................          0x00, //index of string descriptor for interface      ==17 
....................  
....................    //class descriptor [functional header] 
....................          5, //length of descriptor    ==18 
....................          0x24, //dscriptor type (0x24 == )      ==19 
....................          0, //sub type (0=functional header) ==20 
....................          0x10,0x01, //      ==21,22 //cdc version 
....................  
....................    //class descriptor [acm header] 
....................          4, //length of descriptor    ==23 
....................          0x24, //dscriptor type (0x24 == )      ==24 
....................          2, //sub type (2=ACM)   ==25 
....................          2, //capabilities    ==26  //we support Set_Line_Coding, Set_Control_Line_State, Get_Line_Coding, and the notification Serial_State. 
....................  
....................    //class descriptor [union header] 
....................          5, //length of descriptor    ==27 
....................          0x24, //dscriptor type (0x24 == )      ==28 
....................          6, //sub type (6=union)    ==29 
....................          0, //master intf     ==30  //The interface number of the Communication or Dat a Cl ass interface, designated as the masteror controlling interface for the union. 
....................          1, //save intf0      ==31  //Interface number of first slave or associated interface in the union. * 
....................  
....................    //class descriptor [call mgmt header] 
....................          5, //length of descriptor    ==32 
....................          0x24, //dscriptor type (0x24 == )      ==33 
....................          1, //sub type (1=call mgmt)   ==34 
....................          0, //capabilities          ==35  //device does not handle call management itself 
....................          1, //data interface        ==36  //interface number of data class interface 
....................  
....................    //endpoint descriptor 
....................          USB_DESC_ENDPOINT_LEN, //length of descriptor                   ==37 
....................          USB_DESC_ENDPOINT_TYPE, //constant ENDPOINT (ENDPOINT 0x05)          ==38 
....................          USB_CDC_COMM_IN_ENDPOINT | 0x80, //endpoint number and direction 
....................          0x03, //transfer type supported (0x03 is interrupt)         ==40 
....................          USB_CDC_COMM_IN_SIZE,0x00, //maximum packet size supported                  ==41,42 
....................          250,  //polling interval, in ms.  (cant be smaller than 10)      ==43 
....................  
....................    //interface descriptor 1 (data class interface) 
....................          USB_DESC_INTERFACE_LEN, //length of descriptor      =44 
....................          USB_DESC_INTERFACE_TYPE, //constant INTERFACE (INTERFACE 0x04)       =45 
....................          0x01, //number defining this interface (IF we had more than one interface)    ==46 
....................          0x00, //alternate setting     ==47 
....................          2, //number of endpoints   ==48 
....................          0x0A, //class code, 0A = Data Interface Class     ==49 
....................          0x00, //subclass code      ==50 
....................          0x00, //protocol code      ==51 
....................          0x00, //index of string descriptor for interface      ==52 
....................  
....................    //endpoint descriptor 
....................          USB_DESC_ENDPOINT_LEN, //length of descriptor                   ==60 
....................          USB_DESC_ENDPOINT_TYPE, //constant ENDPOINT (ENDPOINT 0x05)          ==61 
....................          USB_CDC_DATA_OUT_ENDPOINT, //endpoint number and direction (0x02 = EP2 OUT)       ==62 
....................          0x02, //transfer type supported (0x02 is bulk)         ==63 
.................... //         make8(USB_CDC_DATA_OUT_SIZE,0),make8(USB_CDC_DATA_OUT_SIZE,1), //maximum packet size supported                  ==64, 65 
....................          USB_CDC_DATA_OUT_SIZE & 0xFF, (USB_CDC_DATA_OUT_SIZE >> 8) & 0xFF, //maximum packet size supported                  ==64, 65 
....................          250,  //polling interval, in ms.  (cant be smaller than 10)      ==66 
....................  
....................    //endpoint descriptor 
....................          USB_DESC_ENDPOINT_LEN, //length of descriptor                   ==53 
....................          USB_DESC_ENDPOINT_TYPE, //constant ENDPOINT (ENDPOINT 0x05)          ==54 
....................          USB_CDC_DATA_IN_ENDPOINT | 0x80, //endpoint number and direction (0x82 = EP2 IN)       ==55 
....................          0x02, //transfer type supported (0x02 is bulk)         ==56 
.................... //         make8(USB_CDC_DATA_IN_SIZE,0),make8(USB_CDC_DATA_IN_SIZE,1), //maximum packet size supported                  ==57, 58 
....................          USB_CDC_DATA_IN_SIZE & 0xFF, (USB_CDC_DATA_IN_SIZE >> 8) & 0xFF, //maximum packet size supported                  ==64, 65 
....................          250,  //polling interval, in ms.  (cant be smaller than 10)      ==59 
....................    }; 
....................  
....................    /****** BEGIN CONFIG DESCRIPTOR LOOKUP TABLES ********/ 
....................    //since we can't make pointers to constants in certain pic16s, this is an offset table to find 
....................    //  a specific descriptor in the above table. 
....................  
....................    //the maximum number of interfaces seen on any config 
....................    //for example, if config 1 has 1 interface and config 2 has 2 interfaces you must define this as 2 
....................    #define USB_MAX_NUM_INTERFACES   2 
....................  
....................    //define how many interfaces there are per config.  [0] is the first config, etc. 
....................    const char USB_NUM_INTERFACES[USB_NUM_CONFIGURATIONS]={2}; 
....................  
....................    //define where to find class descriptors 
....................    //first dimension is the config number 
....................    //second dimension specifies which interface 
....................    //last dimension specifies which class in this interface to get, but most will only have 1 class per interface 
....................    //if a class descriptor is not valid, set the value to 0xFFFF 
....................    const int16 USB_CLASS_DESCRIPTORS[1/*USB_NUM_CONFIGURATIONS*/][USB_MAX_NUM_INTERFACES][4]= 
....................    { 
....................    //config 1 
....................       //interface 0 
....................          //class 1-4 
....................          18,23,27,32, 
....................       //interface 1 
....................          //no classes for this interface 
....................          0xFFFF,0xFFFF,0xFFFF,0xFFFF 
....................    }; 
....................  
....................    #if (sizeof(USB_CONFIG_DESC) != USB_TOTAL_CONFIG_LEN) 
....................       #error USB_TOTAL_CONFIG_LEN not defined correctly 
....................    #endif 
....................  
....................  
.................... ////////////////////////////////////////////////////////////////// 
.................... /// 
.................... ///   start device descriptors 
.................... /// 
.................... ////////////////////////////////////////////////////////////////// 
....................  
....................    const char USB_DEVICE_DESC[USB_DESC_DEVICE_LEN] ={ 
....................       //starts of with device configuration. only one possible 
....................          USB_DESC_DEVICE_LEN, //the length of this report   ==0 
....................          0x01, //the constant DEVICE (DEVICE 0x01)  ==1 
....................          0x10,0x01, //usb version in bcd  ==2,3 
....................          0x02, //class code. 0x02=Communication Device Class ==4 
....................          0x00, //subclass code ==5 
....................          0x00, //protocol code ==6 
....................          USB_MAX_EP0_PACKET_LENGTH, //max packet size for endpoint 0. (SLOW SPEED SPECIFIES 8) ==7 
....................          0xD8,0x04, //vendor id (0x04D8 is Microchip, or is it 0x0461 ??)  ==8,9 
.................... #ifndef ONE_TWENTY_EIGHT 
....................          0xC5,0xFF, //product id   ==10,11 
.................... #else 
....................          0x00,0xFD, //product id   ==10,11 
.................... #endif 
....................          0x02,0x00, //device release number  ==12,13 
....................          0x01, //index of string description of manufacturer. therefore we point to string_1 array (see below)  ==14 
....................          0x02, //index of string descriptor of the product  ==15 
....................          0x00, //index of string descriptor of serial number  ==16 
....................          USB_NUM_CONFIGURATIONS  //number of possible configurations  ==17 
....................    }; 
....................  
....................  
.................... ////////////////////////////////////////////////////////////////// 
.................... /// 
.................... ///   start string descriptors 
.................... ///   String 0 is a special language string, and must be defined.  People in U.S.A. can leave this alone. 
.................... /// 
.................... ///   You must define the length else get_next_string_character() will not see the string 
.................... ///   Current code only supports 10 strings (0 thru 9) 
.................... /// 
.................... ////////////////////////////////////////////////////////////////// 
....................  
.................... //the offset of the starting location of each string.  offset[0] is the start of string 0, offset[1] is the start of string 1, etc. 
.................... char USB_STRING_DESC_OFFSET[]={0,4,22}; 
....................  
.................... char const USB_STRING_DESC[]={ 
....................    //string 0 
....................          4, //length of string index 
....................          USB_DESC_STRING_TYPE, //descriptor type 0x03 (STRING) 
....................          0x09,0x04,   //Microsoft Defined for US-English 
....................    //string 1 
....................          18, //length of string index 
....................          USB_DESC_STRING_TYPE, //descriptor type 0x03 (STRING) 
....................          't',0, 
....................          'k',0, 
....................          'r',0, 
....................          'w',0, 
....................          'o',0, 
....................          'r',0, 
....................          'k',0, 
....................          's',0, 
....................    //string 2 
.................... #ifndef ONE_TWENTY_EIGHT 
....................          16, //length of string index 
.................... #else 
....................          22, //length of string index 
.................... #endif 
....................          USB_DESC_STRING_TYPE, //descriptor type 0x03 (STRING) 
....................          'P',0, 
....................          'I',0, 
....................          'C',0, 
....................          'n',0, 
....................          'o',0, 
....................          'm',0, 
....................          'e',0, 
.................... #ifdef ONE_TWENTY_EIGHT 
....................          '1',0, 
....................          '2',0, 
....................          '8',0, 
.................... #endif 
.................... }; 
....................  
.................... //sy #ENDIF 
....................  
.................... #include <usb.c>        //handles usb setup tokens and get descriptor reports 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                             usb.c                                 //// 
.................... ////                                                                   //// 
.................... //// Standard USB request and token handler code.                      //// 
.................... ////                                                                   //// 
.................... //// This file is part of CCS's PIC USB driver code, which includes:   //// 
.................... ////   usb_desc_*.h - an example set of config and device descriptor   //// 
.................... ////   usb.c - USB token and request handler code                      //// 
.................... ////   usb.h - definitions, prototypes and global variables            //// 
.................... ////                                                                   //// 
.................... //// The following examples are provided by CCS:                       //// 
.................... ////   ex_usb_mouse.c - A HID Mouse.                                   //// 
.................... ////   ex_usb_hid.c - A custom application using HID protocol.         //// 
.................... ////   ex_usb_kbmouse.c - A HID Mouse/Keyboard combo using multiple    //// 
.................... ////                      interfaces.                                  //// 
.................... ////   ex_usb_kbmouse.c - A HID Mouse/Keyboard combo using multiple    //// 
.................... ////                      HID Reports.                                 //// 
.................... ////   ex_usb_scope.c - A digital oscilloscope using a custom          //// 
.................... ////                    protocol requiring custom Windows drivers.     //// 
.................... ////                                                                   //// 
.................... //// Many settings important to the USB API are defined in usb.h.      //// 
.................... //// See the documentation in usb.h about these settings.              //// 
.................... ////                                                                   //// 
.................... //// The majority of this code is called and used by the interrupt     //// 
.................... //// generated by the hardware level, and therefore it is not meant    //// 
.................... //// to be called by the user.  The following functions are of use to  //// 
.................... //// the user (for more docs on the functions, read the comments at    //// 
.................... //// each function):                                                   //// 
.................... ////                                                                   //// 
.................... ////    **********************  FUNCTIONS  ***********************     //// 
.................... ////                                                                   //// 
.................... //// usb_enumerated() - returns TRUE if device has been enumerated     //// 
.................... ////                    (configured) by host, FALSE if it has not.     //// 
.................... ////                    Do not try to use the USB peripheral until you //// 
.................... ////                    are enumerated.                                //// 
.................... ////                                                                   //// 
.................... //// usb_wait_for_enumeration() - Sits in an infinte loop until device //// 
.................... ////                              is enumerated.                       //// 
.................... ////                                                                   //// 
.................... //// usb_kbhit() - Returns true if OUT endpoint contains data from     //// 
.................... ////               host.                                               //// 
.................... ////                                                                   //// 
.................... //// usb_puts() - Sends a multiple packet message to the host          //// 
.................... ////                                                                   //// 
.................... //// usb_gets() - Gets multiple packets from the host                  //// 
.................... ////                                                                   //// 
.................... //// The rest of the functions in this file are part of the USB        //// 
.................... //// interrupt service routine and are not meant to be called by the   //// 
.................... //// user.                                                             //// 
.................... ////                                                                   //// 
.................... ////   *************************  NOTE  **************************     //// 
.................... ////    This code will not create a multiple configuration device.     //// 
.................... ////    If you wish to create a multiple configuration device then you //// 
.................... ////    will have to modify these drivers.                             //// 
.................... ////                                                                   //// 
.................... ////   *************************  NOTE  **************************     //// 
.................... ////   This code does not support Get_Idle or Set_Idle HID-specific    //// 
.................... ////   requests.  These requests are optional.  If you want to support //// 
.................... ////   these requests you must provide the code yourself.  See         //// 
.................... ////   usb_isr_tkn_setup_ClassInterface() if you wish to add this      //// 
.................... ////   support.                                                        //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... //// If you wish to provide your own USB peripheral hardware layer, it //// 
.................... //// must include the following functions:                             //// 
.................... ////                                                                   //// 
.................... //// void usb_stall_ep(int8 endpoint);                                 //// 
.................... //// void usb_unstall_ep(int8 endpoint);                               //// 
.................... //// int1 usb_endpoint_stalled(int8 endpoint);                         //// 
.................... //// void usb_set_address(int8 address);                               //// 
.................... //// void usb_set_configured(int config);                              //// 
.................... //// int8 usb_get_packet(int8 endpoint, int8 * ptr, int8 max);         //// 
.................... //// int1 usb_put_packet(int endpoint, int * ptr, int len, USB_DTS_BIT toggle); //// 
.................... //// void usb_request_send_response(int8 len);                                //// 
.................... //// int1 usb_kbhit(int8 endpoint);                                    //// 
.................... ////                                                                   //// 
.................... //// CCS provides a USB peripheral hardware layer for PIC16C7x5        //// 
.................... //// (pic_usb.h), 18Fxx5x (pic18_usb.h) and National's USBN960x        //// 
.................... //// (usbn960x.c).  See these files for more documentation.            //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... //// Version History:                                                  //// 
.................... ////                                                                   //// 
.................... //// July 13th, 2005:                                                  //// 
.................... ////  usb_puts() packet_size and this_packet_len changed to 16bits.    //// 
.................... ////  usb_gets() len, packet_size and this_packet_len to 16bits.       //// 
.................... ////                                                                   //// 
.................... //// June 20th, 2005:                                                  //// 
.................... ////  Initial 18fxx5x release.                                         //// 
.................... ////  usb_kbhit() removed, usb_kbhit() now implemented in hardware     //// 
.................... ////    layer.                                                         //// 
.................... ////                                                                   //// 
.................... //// May 13th, 2005:                                                   //// 
.................... ////  Beta release, only works with 18Fxx5x hardware layer.            //// 
.................... ////  Now supports multiple interfaces (many defines in descriptors    //// 
.................... ////   will have to be changed, see examples)                          //// 
.................... ////  TODO: alot of indexing and length handling for descriptors is    //// 
.................... ////   only 8bit, so make sure all descriptor tables are less than     //// 
.................... ////   256 bytes long.                                                 //// 
.................... ////                                                                   //// 
.................... //// Apr 21st, 2005:                                                   //// 
.................... ////  Initial Alpha Release with PIC18Fxx5x support.  (ONLY TESTED     //// 
.................... ////   WITH 18F4550)                                                   //// 
.................... ////  usb_puts() doesn't need max packet size as a paremeter, uses     //// 
.................... ////   usb_ep_tx_size[] defined in usb.h                               //// 
.................... ////  usb_puts() timeout parameter now in ms, not seconds.             //// 
.................... ////  USB Stack no longer buffers incoming data.  If there is data to  //// 
.................... ////   get usb_kbhit(en) will return TRUE and the data will sit in     //// 
.................... ////   the endpoint buffer until you usb_get_packet(), which will      //// 
.................... ////   then free the endpoint buffer for more data.  This affects      //// 
.................... ////   routines such as usb_gets() and usb_kbhit().                    //// 
.................... ////  usb_gets() no longer reads buffered data (see above note),       //// 
.................... ////   now it reads multiple packets in the same way usb_puts()        //// 
.................... ////   writes multiple packets                                         //// 
.................... ////  usb_kbhit() is hardware specific, so has been moved to hardware  //// 
.................... ////   layer.                                                          //// 
.................... ////                                                                   //// 
.................... //// Nov 11th, 2004:                                                   //// 
.................... ////  No longer includes wrong descriptor header.                      //// 
.................... ////                                                                   //// 
.................... //// June 24th, 2004:                                                  //// 
.................... ////  Optimization and cleanup.                                        //// 
.................... ////                The following definitions changed:                 //// 
.................... ////  USB_EPx_TX_ENABLE and USB_EPx_RX_ENABLE have changed. See usb.h  //// 
.................... ////  USB_CONFIG_DESCRIPTORS[] removed                                 //// 
.................... ////  USB_CONFIG_DESC_LEN changed to USB_DESC_CONFIG_LEN               //// 
.................... ////  USB_INTERFACE_DESC_LEN changed to USB_DESC_INTERFACE_LEN         //// 
.................... ////  USB_CLASS_DESC_LEN changed to USB_DESC_CLASS_LEN                 //// 
.................... ////  USB_ENDPOINT_DESC_LEN changed to USB_DESC_ENDPOINT_LEN           //// 
.................... ////  USB_CONFIG_DESC_KEY changed to USB_DESC_CONFIG_TYPE              //// 
.................... ////  USB_INTERFACE_DESC_KEY changed to USB_DESC_INTERFACE_TYPE        //// 
.................... ////  USB_CLASS_DESC_KEY changed to USB_DESC_CLASS_TYPE                //// 
.................... ////  USB_ENDPOINT_DESC_KEY changed to USB_DESC_ENDPOINT_TYPE          //// 
.................... ////  USB_STRING_X[] arrays removed, see USB_STRING_DESC[] and         //// 
.................... ////                                 USB_STRING_DESC_OFFSET[]          //// 
.................... ////  dev_req, curr_config, status_device and getdesc_type global      //// 
.................... ////        variables moved into struct USB_stack_status               //// 
.................... ////                                                                   //// 
.................... //// December 5th, 2003: Fixed a potential bug where descriptors are   //// 
.................... ////         evenly dividable by 8 (MAX_EP0_PACKET_SIZE)               //// 
.................... ////                                                                   //// 
.................... //// October 15th, 2003: Support for boot protocol added.              //// 
.................... ////         Set USB_HID_BOOT_PROTOCOL to TRUE to support this.        //// 
.................... ////         The array hid_protocol[] saves which protocol mode each   //// 
.................... ////         interface is in.  It is your applications job to send     //// 
.................... ////         data that either fit the boot protocol or HID protocol.   //// 
.................... ////                                                                   //// 
.................... //// May 6th, 2003: Fixed a potential stack overflow using PCM         //// 
.................... ////                                                                   //// 
.................... //// October 28th, 2002: Problem with usb_puts and timeout fixed.      //// 
.................... ////                                                                   //// 
.................... //// October 28th, 2002: Typo fixed in get_next_string_character(),    //// 
.................... ////                     although it didn't cause any serious problems //// 
.................... ////                                                                   //// 
.................... //// October 25th, 2002: Another change to usb_puts() was made to fix  //// 
.................... ////                     problems with multiple packet messages        //// 
.................... //// October 29th, 2002: Fixed a problem with multiple packet string   //// 
.................... ////                     descriptors that require a 0 len packet to    //// 
.................... ////                     end message.                                  //// 
.................... ////                                                                   //// 
.................... //// October 23rd, 2002: usb_puts() will bomb out of error quicker     //// 
.................... ////                                                                   //// 
.................... //// August 2nd, 2002: Initial Public Release                          //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2005 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS    //// 
.................... //// C compiler.  This source code may only be distributed to other    //// 
.................... //// licensed users of the CCS C compiler.  No other use,              //// 
.................... //// reproduction or distribution is permitted without written         //// 
.................... //// permission.  Derivative programs created using this software      //// 
.................... //// in object code form are not restricted in any way.                //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #IFNDEF __USB_DRIVER__ 
.................... #DEFINE __USB_DRIVER__ 
....................  
.................... #include <usb.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                              usb.h                                //// 
.................... ////                                                                   //// 
.................... //// Function protypes, defintions and globals used by CCS USB driver  //// 
.................... ////                                                                   //// 
.................... //// This file is part of CCS's PIC USB driver code, which includes:   //// 
.................... ////   usb_desc_*.h - an example set of config and device descriptor   //// 
.................... ////   usb.c - USB token and request handler code                      //// 
.................... ////   usb.h - definitions, prototypes and global variables            //// 
.................... ////                                                                   //// 
.................... //// The following examples are provided by CCS:                       //// 
.................... ////   ex_usb_mouse.c - A HID Mouse.                                   //// 
.................... ////   ex_usb_hid.c - A custom application using HID protocol.         //// 
.................... ////   ex_usb_kbmouse.c - A HID Mouse/Keyboard combo using multiple    //// 
.................... ////                      interfaces.                                  //// 
.................... ////   ex_usb_kbmouse.c - A HID Mouse/Keyboard combo using multiple    //// 
.................... ////                      HID Reports.                                 //// 
.................... ////   ex_usb_scope.c - A digital oscilloscope using a custom          //// 
.................... ////                    protocol requiring custom Windows drivers.     //// 
.................... ////                                                                   //// 
.................... ////                   **** DEFINITIONS *****                          //// 
.................... //// The following definitions are declared here, but can be           //// 
.................... //// overwritten in your code.  Unless needed otherwise, leave         //// 
.................... //// to default value.  If confused about a definition read the        //// 
.................... //// comments at each defintion                                        //// 
.................... ////                                                                   //// 
.................... //// USB_HID_IDLE (FALSE) - Set to TRUE if your device supports        //// 
.................... ////                            Set_Idle HID class request.  Set to    //// 
.................... ////                            False if you do not (device will       //// 
.................... ////                            send a Wrong-state if computer         //// 
.................... ////                            sends a Set_Idle / Get_Idle command)   //// 
.................... ////                            NOTE: If you set to TRUE you must      //// 
.................... ////                            provide your own code.  See            //// 
.................... ////                            usb_isr_tkn_setup_ClassInterface() in  //// 
.................... ////                            usb.c                                  //// 
.................... ////                                                                   //// 
.................... //// USB_HID_BOOT_PROTOCOL (FALSE) - Set to TRUE if your device supports   //// 
.................... ////                            Set_Protocl HID class request. Set to  //// 
.................... ////                            False if you do not (device will       //// 
.................... ////                            send a Wrong-state if computer         //// 
.................... ////                            sends a Set_Protocl / Get_Protocol     //// 
.................... ////                            command).                              //// 
.................... ////                            NOTE: If you set to TRUE you must      //// 
.................... ////                            provide your own code in the           //// 
.................... ////                            application that properly send boot    //// 
.................... ////                            or HID packets.                        //// 
.................... ////                                                                   //// 
.................... //// USB_MAX_EP0_PACKET_LENGTH (8) - Max Packet size for Endpoint 0.   //// 
.................... ////                            Only the 18Fxx5x USB peripheral can    //// 
.................... ////                            have a value larger than 8.            //// 
.................... ////                                                                   //// 
.................... //// USB_EPx_RX_ENABLE (USB_ENABLE_DISABLED) - Where x is the          //// 
.................... ////                         endpoint number. Change this define       //// 
.................... ////                         to specify what kind of transfer method   //// 
.................... ////                         this RX (PC to device) endpoint uses.     //// 
.................... ////                       Here is the list of valid transfer methods: //// 
.................... ////                             USB_ENABLE_CONTROL                    //// 
.................... ////                             USB_ENABLE_ISOCHRONOUS                //// 
.................... ////                             USB_ENABLE_BULK                       //// 
.................... ////                             USB_ENABLE_INTERRUPT                  //// 
.................... ////                             USB_ENABLE_DISABLED                   //// 
.................... ////                        Don't forget that you must specify the     //// 
.................... ////                        transfer method properly in your endpoint  //// 
.................... ////                        descriptor, too.                           //// 
.................... ////                                                                   //// 
.................... //// USB_EPx_RX_SIZE (0) - For some hardware it is important to know   //// 
.................... ////                       how much memory to reserve for receiving    //// 
.................... ////                       packets.                                    //// 
.................... ////                                                                   //// 
.................... ////  *** NOTE *** You must have both USB_EPx_RX_ENABLE defined and    //// 
.................... ////               USB_EPx_RX_SIZE defined (non 0) to enable a RX      //// 
.................... ////               endpoint.                                           //// 
.................... ////  *** NOTE *** Endpoint 0 is always enabled.                       //// 
.................... ////                                                                   //// 
.................... //// USB_EPx_TX_ENABLE (USB_ENABLE_DISABLED) - Where x is the          //// 
.................... ////                         endpoint number. Change this define       //// 
.................... ////                         to specify what kind of transfer method   //// 
.................... ////                         this TX (device to PC) endpoint uses.     //// 
.................... ////                       Here is the list of valid transfer methods: //// 
.................... ////                             USB_ENABLE_CONTROL                    //// 
.................... ////                             USB_ENABLE_ISOCHRONOUS                //// 
.................... ////                             USB_ENABLE_BULK                       //// 
.................... ////                             USB_ENABLE_INTERRUPT                  //// 
.................... ////                             USB_ENABLE_DISABLED                   //// 
.................... ////                        Don't forget that you must specify the     //// 
.................... ////                        transfer method properly in your endpoint  //// 
.................... ////                        descriptor, too.                           //// 
.................... ////                                                                   //// 
.................... //// USB_EPx_TX_SIZE (0) - For some hardware it is important to know   //// 
.................... ////                       how much memory to reserve for transmitting //// 
.................... ////                       packets.                                    //// 
.................... ////                                                                   //// 
.................... ////  *** NOTE *** You must have both USB_EPx_TX_ENABLE defined and    //// 
.................... ////               USB_EPx_TX_SIZE defined (non 0) to enable a TX      //// 
.................... ////               endpoint.                                           //// 
.................... ////                                                                   //// 
.................... ////                                                                   //// 
.................... //// USB_HID_DEVICE (TRUE) - HID devices require extra code to handle  //// 
.................... ////                         HID requests.  You can disable to save    //// 
.................... ////                         ROM space if you are not using a HID      //// 
.................... ////                         device.  If you are not using a HID       //// 
.................... ////                         device you must provide your own O/S      //// 
.................... ////                         (Windows) driver.                         //// 
.................... ////                                                                   //// 
.................... //// The other definitions should not be changed.                      //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... //// Version History:                                                  //// 
.................... ////                                                                   //// 
.................... //// July 13th, 2005:                                                  //// 
.................... ////  usb_ep_tx_size[] and usb_ep_rx_size[] changed to 16bits          //// 
.................... ////                                                                   //// 
.................... //// June 20th, 2005:                                                  //// 
.................... ////  Initial 18fxx5x release                                          //// 
.................... ////                                                                   //// 
.................... //// May 13th, 2005:                                                   //// 
.................... ////  Beta release, only works with 18Fxx5x hardware layer.            //// 
.................... ////  Now supports multiple interfaces (many defines in descriptors    //// 
.................... ////   will have to be changed, see examples)                          //// 
.................... ////                                                                   //// 
.................... //// Mar 21st, 2005:                                                   //// 
.................... ////  Initial Alpha Release with PIC18Fxx5x support.  (ONLY TESTED     //// 
.................... ////   WITH 18F4550)                                                   //// 
.................... ////  usb_gets() and usb_puts() changed (see usb.c)                    //// 
.................... ////                                                                   //// 
.................... //// June 24th, 2004:                                                  //// 
.................... ////  Optimization and cleanup.                                        //// 
.................... ////                The following definitions changed:                 //// 
.................... ////  USB_EPx_TX_ENABLE and USB_EPx_RX_ENABLE have changed. See usb.h  //// 
.................... ////  USB_CONFIG_DESCRIPTORS[] removed                                 //// 
.................... ////  USB_CONFIG_DESC_LEN changed to USB_DESC_CONFIG_LEN               //// 
.................... ////  USB_INTERFACE_DESC_LEN changed to USB_DESC_INTERFACE_LEN         //// 
.................... ////  USB_CLASS_DESC_LEN changed to USB_DESC_CLASS_LEN                 //// 
.................... ////  USB_ENDPOINT_DESC_LEN changed to USB_DESC_ENDPOINT_LEN           //// 
.................... ////  USB_CONFIG_DESC_KEY changed to USB_DESC_CONFIG_TYPE              //// 
.................... ////  USB_INTERFACE_DESC_KEY changed to USB_DESC_INTERFACE_TYPE        //// 
.................... ////  USB_CLASS_DESC_KEY changed to USB_DESC_CLASS_TYPE                //// 
.................... ////  USB_ENDPOINT_DESC_KEY changed to USB_DESC_ENDPOINT_TYPE          //// 
.................... ////  USB_STRING_X[] arrays removed, see USB_STRING_DESC[] and         //// 
.................... ////                                 USB_STRING_DESC_OFFSET[]          //// 
.................... ////  dev_req, curr_config, status_device and getdesc_type global      //// 
.................... ////        variables moved into struct USB_stack_status               //// 
.................... ////                                                                   //// 
.................... //// October 15th, 2003: Support for boot protocol added.              //// 
.................... ////         Set USB_HID_BOOT_PROTOCOL to TRUE to support this.        //// 
.................... ////         The array hid_protocol[] saves which protocol mode each   //// 
.................... ////         interface is in.  It is your applications job to send     //// 
.................... ////         data that either fit the boot protocol or HID protocol.   //// 
.................... ////                                                                   //// 
.................... //// May 6th, 2003: Fixed a potential stack overflow using PCM         //// 
.................... ////                                                                   //// 
.................... //// October 29th, 2002: New definition added to USB_STATES            //// 
.................... ////                                                                   //// 
.................... //// August 2nd, 2002: Initial Public Release                          //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2005 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS    //// 
.................... //// C compiler.  This source code may only be distributed to other    //// 
.................... //// licensed users of the CCS C compiler.  No other use,              //// 
.................... //// reproduction or distribution is permitted without written         //// 
.................... //// permission.  Derivative programs created using this software      //// 
.................... //// in object code form are not restricted in any way.                //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
....................  
.................... #IFNDEF __USB_PROTOTYPES__ 
.................... #DEFINE __USB_PROTOTYPES__ 
....................  
.................... #IFNDEF USB_HID_BOOT_PROTOCOL 
....................    #DEFINE USB_HID_BOOT_PROTOCOL FALSE 
.................... #ENDIF 
....................  
.................... #IFNDEF USB_HID_IDLE 
....................    #DEFINE USB_HID_IDLE FALSE 
.................... #ENDIF 
....................  
.................... //should the compiler add the extra HID handler code?  Defaults to yes. 
.................... #IFNDEF USB_HID_DEVICE 
....................    #DEFINE USB_HID_DEVICE TRUE 
.................... #ENDIF 
....................  
.................... #IFNDEF USB_CDC_DEVICE 
....................    #DEFINE USB_CDC_DEVICE FALSE 
.................... #ENDIF 
....................  
.................... #ifndef USB_OPT_FOR_ROM 
....................    #define USB_OPT_FOR_ROM TRUE  //set to false to opt for less RAM, true to opt for less ROM 
.................... #endif 
....................  
.................... #IFNDEF USB_MAX_EP0_PACKET_LENGTH 
....................   #DEFINE USB_MAX_EP0_PACKET_LENGTH 8 
.................... #ENDIF 
....................  
.................... //CCS only supports one configuration at this time 
.................... #DEFINE USB_NUM_CONFIGURATIONS 1 //DO NOT CHANGE 
....................  
.................... //PID values for tokens (see page 48 of USB Complete ed.1) 
.................... #define PID_IN       0x09  //device to host transactions 
.................... #define PID_OUT      0x01  //host to device transactions 
.................... #define PID_SETUP    0x0D  //host to device setup transaction 
.................... #define PID_ACK      0x02  //receiver accepts error-free data packet 
.................... #define PID_DATA0    0x03  //data packet with even sync bit 
.................... #define PID_SOF      0x05  //start of framer marker and frame number 
.................... #define PID_NAK      0x0A  //receiver can't accept data or sender cant send data or has no data to transmit 
.................... #define PID_DATA1    0x0B  //data packet with odd sync bit 
.................... #define PID_PRE      0x0C  //preamble issued by host.  enables downstream traffic to low-speed device 
.................... #define PID_STALL    0x0E  //a control request isnt supported or the endpoint is halted 
....................  
.................... //Key which identifies descritpors 
.................... #DEFINE USB_DESC_DEVICE_TYPE     0x01  //#DEFINE USB_DEVICE_DESC_KEY      0x01 
.................... #DEFINE USB_DESC_CONFIG_TYPE     0x02  //#DEFINE USB_CONFIG_DESC_KEY      0x02 
.................... #DEFINE USB_DESC_STRING_TYPE     0x03  //#DEFINE USB_STRING_DESC_KEY      0x03 
.................... #DEFINE USB_DESC_INTERFACE_TYPE  0x04  //#DEFINE USB_INTERFACE_DESC_KEY   0x04 
.................... #DEFINE USB_DESC_ENDPOINT_TYPE   0x05  //#DEFINE USB_ENDPOINT_DESC_KEY    0x05 
.................... #DEFINE USB_DESC_CLASS_TYPE      0x21  //#DEFINE USB_CLASS_DESC_KEY       0x21 
.................... #DEFINE USB_DESC_HIDREPORT_TYPE  0x22 
....................  
.................... //The length of each descriptor 
.................... #DEFINE USB_DESC_DEVICE_LEN      18 //#DEFINE USB_DEVICE_DESC_LEN      18 
.................... #DEFINE USB_DESC_CONFIG_LEN      9  //#DEFINE USB_CONFIG_DESC_LEN      9 
.................... #DEFINE USB_DESC_INTERFACE_LEN   9  //#DEFINE USB_INTERFACE_DESC_LEN   9 
.................... #DEFINE USB_DESC_CLASS_LEN       9  //#DEFINE USB_CLASS_DESC_LEN       9 
.................... #DEFINE USB_DESC_ENDPOINT_LEN    7  //#DEFINE USB_ENDPOINT_DESC_LEN    7 
....................  
.................... //Standard USB Setup bRequest Codes 
.................... #define USB_STANDARD_REQUEST_GET_STATUS         0x00 
.................... #define USB_STANDARD_REQUEST_CLEAR_FEATURE      0x01 
.................... #define USB_STANDARD_REQUEST_SET_FEATURE        0x03 
.................... #define USB_STANDARD_REQUEST_SET_ADDRESS        0x05 
.................... #define USB_STANDARD_REQUEST_GET_DESCRIPTOR     0x06 
.................... #define USB_STANDARD_REQUEST_SET_DESCRIPTOR     0x07 
.................... #define USB_STANDARD_REQUEST_GET_CONFIGURATION  0x08 
.................... #define USB_STANDARD_REQUEST_SET_CONFIGURATION  0x09 
.................... #define USB_STANDARD_REQUEST_GET_INTERFACE      0x0A 
.................... #define USB_STANDARD_REQUEST_SET_INTERFACE      0x0B 
.................... #define USB_STANDARD_REQUEST_SYNCH_FRAME        0x0C 
....................  
.................... //HID Class Setup bRequest Codes 
.................... #define USB_HID_REQUEST_GET_REPORT     0x01 
.................... #define USB_HID_REQUEST_GET_IDLE       0x02 
.................... #define USB_HID_REQUEST_GET_PROTOCOL   0x03 
.................... #define USB_HID_REQUEST_SET_REPORT     0x09 
.................... #define USB_HID_REQUEST_SET_IDLE       0x0A 
.................... #define USB_HID_REQUEST_SET_PROTOCOL   0x0B 
....................  
.................... //types of endpoints as defined in the descriptor 
.................... #define USB_ENDPOINT_TYPE_CONTROL      0x00 
.................... #define USB_ENDPOINT_TYPE_ISOCHRONOUS  0x01 
.................... #define USB_ENDPOINT_TYPE_BULK         0x02 
.................... #define USB_ENDPOINT_TYPE_INTERRUPT    0x03 
....................  
.................... //types of endpoints used internally in this api 
.................... #define USB_ENABLE_DISABLED     0 
.................... #define USB_ENABLE_BULK         0x01 
.................... #define USB_ENABLE_ISOCHRONOUS  0x02 
.................... #define USB_ENABLE_INTERRUPT    0x03 
.................... #define USB_ENABLE_CONTROL      0x04 
....................  
.................... //// DO NOT CHANGE THE FOLLOWING VALUES: 
....................  
.................... enum USB_STATES {GET_DESCRIPTOR=1,SET_ADDRESS=2,NONE=0}; 
....................  
.................... enum USB_DTS_BIT {USB_DTS_DATA1=1, USB_DTS_TOGGLE=2, USB_DTS_DATA0=0, 
....................                    USB_DTS_STALL=3, USB_DTS_USERX=4}; 
....................  
.................... enum USB_GETDESC_TYPES {USB_GETDESC_CONFIG_TYPE=0,USB_GETDESC_HIDREPORT_TYPE=1,USB_GETDESC_STRING_TYPE=2,USB_GETDESC_DEVICE_TYPE=3}; 
....................  
.................... #if USB_OPT_FOR_ROM 
.................... struct { 
....................    USB_STATES dev_req;   //what did the last setup token set us up to do?.  init at none 
....................    int  curr_config;  //our current config.  start at none/powered (NOT THAT THIS LIMITS US TO 3 CONFIGURATIONS) 
....................    int status_device; //Holds our state for Set_Feature and Clear_Feature 
....................    USB_GETDESC_TYPES getdesc_type;   //which get_descriptor() we are handling 
.................... } USB_stack_status; 
.................... #else 
.................... struct { 
....................    USB_STATES dev_req:2;   //what did the last setup token set us up to do?.  init at none 
....................    int  Curr_config:2;  //our current config.  start at none/powered (NOT THAT THIS LIMITS US TO 3 CONFIGURATIONS) 
....................    int status_device:2; //Holds our state for Set_Feature and Clear_Feature 
....................    USB_GETDESC_TYPES getdesc_type:2;   //which get_descriptor() we are handling 
.................... } USB_stack_status; 
.................... #endif 
....................  
.................... int16 __usb_kbhit_status; 
....................  
.................... /// *** User function prototypes 
.................... void usb_wait_for_enumeration(void); 
.................... int1 usb_unermated(void); 
.................... int8 usb_gets(int8 endpoint, int8 * ptr, int16 max, int16 timeout); 
.................... int1 usb_puts(int8 endpoint, int8 * ptr, int16 len, int8 timeout); 
....................  
.................... /// *** Token and request hanlder function prototypes 
.................... void usb_token_reset(); 
....................  
.................... void usb_put_0len_0(void); 
.................... void usb_request_send_response(int len);   //always sends usb_ep0_rx_buffer[] to endpoint 0 with a toggle of DATA 
....................  
.................... void usb_match_registers(int8 endpoint, int16 *status, int16 *buffer, int8 *size); 
....................  
.................... void usb_isr_tok_in_dne(int8 endpoint); 
.................... void usb_isr_tok_out_dne(int8 endpoint); 
.................... void usb_isr_tok_setup_dne(void); 
....................  
.................... void usb_isr_tkn_setup_StandardEndpoint(void); 
.................... void usb_isr_tkn_setup_StandardDevice(void); 
.................... void usb_isr_tkn_setup_StandardInterface(void); 
....................  
.................... #IF USB_HID_DEVICE 
....................    void usb_isr_tkn_setup_ClassInterface(void); 
.................... #ENDIF 
....................  
.................... void usb_Get_Descriptor(void); 
.................... void usb_copy_desc_seg_to_ep(void); 
....................  
.................... void usb_finish_set_address(void); 
....................  
.................... //*** ENABLE RX ENDPOINTS AND BUFFERS 
....................  
.................... //--------- endpoint 0 defines ---------- 
.................... #define USB_EP0_TX_ENABLE  USB_ENABLE_CONTROL 
.................... #define USB_EP0_RX_ENABLE  USB_ENABLE_CONTROL 
.................... #define USB_EP0_RX_SIZE    USB_MAX_EP0_PACKET_LENGTH  //endpoint 0 is setup, and should always be the MAX_PACKET_LENGTH.  Slow speed specifies 8 
.................... #define USB_EP0_TX_SIZE    USB_MAX_EP0_PACKET_LENGTH  //endpoint 0 is setup, and should always be the MAX_PACKET_LENGTH.  Slow speed specifies 8 
....................  
.................... //--------- endpoint 1 defines ---------- 
.................... #ifndef USB_EP1_TX_ENABLE 
....................  #define USB_EP1_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP1_RX_ENABLE 
....................  #define USB_EP1_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP1_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP1_RX_SIZE 
....................   #undef USB_EP1_RX_SIZE 
....................  #endif 
....................  #define USB_EP1_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP1_RX_SIZE 
....................   #error You enabled EP1 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP1_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP1_TX_SIZE 
....................   #undef USB_EP1_TX_SIZE 
....................  #endif 
....................  #define USB_EP1_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP1_TX_SIZE 
....................   #error You enabled EP1 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 2 defines ---------- 
.................... #ifndef USB_EP2_TX_ENABLE 
....................  #define USB_EP2_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP2_RX_ENABLE 
....................  #define USB_EP2_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP2_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP2_RX_SIZE 
....................   #undef USB_EP2_RX_SIZE 
....................  #endif 
....................  #define USB_EP2_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP2_RX_SIZE 
....................   #error You enabled EP2 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP2_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP2_TX_SIZE 
....................   #undef USB_EP2_TX_SIZE 
....................  #endif 
....................  #define USB_EP2_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP2_TX_SIZE 
....................   #error You enabled EP2 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 3 defines ---------- 
.................... #ifndef USB_EP3_TX_ENABLE 
....................  #define USB_EP3_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP3_RX_ENABLE 
....................  #define USB_EP3_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP3_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP3_RX_SIZE 
....................   #undef USB_EP3_RX_SIZE 
....................  #endif 
....................  #define USB_EP3_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP3_RX_SIZE 
....................   #error You enabled EP3 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP3_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP3_TX_SIZE 
....................   #undef USB_EP3_TX_SIZE 
....................  #endif 
....................  #define USB_EP3_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP3_TX_SIZE 
....................   #error You enabled EP3 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 4 defines ---------- 
.................... #ifndef USB_EP4_TX_ENABLE 
....................  #define USB_EP4_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP4_RX_ENABLE 
....................  #define USB_EP4_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP4_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP4_RX_SIZE 
....................   #undef USB_EP4_RX_SIZE 
....................  #endif 
....................  #define USB_EP4_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP4_RX_SIZE 
....................   #error You enabled EP4 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP4_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP4_TX_SIZE 
....................   #undef USB_EP4_TX_SIZE 
....................  #endif 
....................  #define USB_EP4_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP4_TX_SIZE 
....................   #error You enabled EP4 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 5 defines ---------- 
.................... #ifndef USB_EP5_TX_ENABLE 
....................  #define USB_EP5_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP5_RX_ENABLE 
....................  #define USB_EP5_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP5_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP5_RX_SIZE 
....................   #undef USB_EP5_RX_SIZE 
....................  #endif 
....................  #define USB_EP5_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP5_RX_SIZE 
....................   #error You enabled EP5 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP5_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP5_TX_SIZE 
....................   #undef USB_EP5_TX_SIZE 
....................  #endif 
....................  #define USB_EP5_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP5_TX_SIZE 
....................   #error You enabled EP5 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 6 defines ---------- 
.................... #ifndef USB_EP6_TX_ENABLE 
....................  #define USB_EP6_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP6_RX_ENABLE 
....................  #define USB_EP6_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP6_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP6_RX_SIZE 
....................   #undef USB_EP6_RX_SIZE 
....................  #endif 
....................  #define USB_EP6_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP6_RX_SIZE 
....................   #error You enabled EP6 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP6_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP6_TX_SIZE 
....................   #undef USB_EP6_TX_SIZE 
....................  #endif 
....................  #define USB_EP6_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP6_TX_SIZE 
....................   #error You enabled EP6 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 7 defines ---------- 
.................... #ifndef USB_EP7_TX_ENABLE 
....................  #define USB_EP7_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP7_RX_ENABLE 
....................  #define USB_EP7_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP7_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP7_RX_SIZE 
....................   #undef USB_EP7_RX_SIZE 
....................  #endif 
....................  #define USB_EP7_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP7_RX_SIZE 
....................   #error You enabled EP7 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP7_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP7_TX_SIZE 
....................   #undef USB_EP7_TX_SIZE 
....................  #endif 
....................  #define USB_EP7_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP7_TX_SIZE 
....................   #error You enabled EP7 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 8 defines ---------- 
.................... #ifndef USB_EP8_TX_ENABLE 
....................  #define USB_EP8_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP8_RX_ENABLE 
....................  #define USB_EP8_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP8_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP8_RX_SIZE 
....................   #undef USB_EP8_RX_SIZE 
....................  #endif 
....................  #define USB_EP8_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP8_RX_SIZE 
....................   #error You enabled EP8 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP8_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP8_TX_SIZE 
....................   #undef USB_EP8_TX_SIZE 
....................  #endif 
....................  #define USB_EP8_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP8_TX_SIZE 
....................   #error You enabled EP8 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 9 defines ---------- 
.................... #ifndef USB_EP9_TX_ENABLE 
....................  #define USB_EP9_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP9_RX_ENABLE 
....................  #define USB_EP9_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP9_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP9_RX_SIZE 
....................   #undef USB_EP9_RX_SIZE 
....................  #endif 
....................  #define USB_EP9_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP9_RX_SIZE 
....................   #error You enabled EP9 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP9_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP9_TX_SIZE 
....................   #undef USB_EP9_TX_SIZE 
....................  #endif 
....................  #define USB_EP9_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP9_TX_SIZE 
....................   #error You enabled EP9 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 10 defines ---------- 
.................... #ifndef USB_EP10_TX_ENABLE 
....................  #define USB_EP10_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP10_RX_ENABLE 
....................  #define USB_EP10_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP10_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP10_RX_SIZE 
....................   #undef USB_EP10_RX_SIZE 
....................  #endif 
....................  #define USB_EP10_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP10_RX_SIZE 
....................   #error You enabled EP10 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP10_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP10_TX_SIZE 
....................   #undef USB_EP10_TX_SIZE 
....................  #endif 
....................  #define USB_EP10_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP10_TX_SIZE 
....................   #error You enabled EP10 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 11 defines ---------- 
.................... #ifndef USB_EP11_TX_ENABLE 
....................  #define USB_EP11_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP11_RX_ENABLE 
....................  #define USB_EP11_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP11_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP11_RX_SIZE 
....................   #undef USB_EP11_RX_SIZE 
....................  #endif 
....................  #define USB_EP11_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP11_RX_SIZE 
....................   #error You enabled EP11 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP11_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP11_TX_SIZE 
....................   #undef USB_EP11_TX_SIZE 
....................  #endif 
....................  #define USB_EP11_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP11_TX_SIZE 
....................   #error You enabled EP11 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 12 defines ---------- 
.................... #ifndef USB_EP12_TX_ENABLE 
....................  #define USB_EP12_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP12_RX_ENABLE 
....................  #define USB_EP12_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP12_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP12_RX_SIZE 
....................   #undef USB_EP12_RX_SIZE 
....................  #endif 
....................  #define USB_EP12_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP12_RX_SIZE 
....................   #error You enabled EP12 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP12_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP12_TX_SIZE 
....................   #undef USB_EP12_TX_SIZE 
....................  #endif 
....................  #define USB_EP12_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP12_TX_SIZE 
....................   #error You enabled EP12 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 13 defines ---------- 
.................... #ifndef USB_EP13_TX_ENABLE 
....................  #define USB_EP13_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP13_RX_ENABLE 
....................  #define USB_EP13_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP13_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP13_RX_SIZE 
....................   #undef USB_EP13_RX_SIZE 
....................  #endif 
....................  #define USB_EP13_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP13_RX_SIZE 
....................   #error You enabled EP13 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP13_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP13_TX_SIZE 
....................   #undef USB_EP13_TX_SIZE 
....................  #endif 
....................  #define USB_EP13_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP13_TX_SIZE 
....................   #error You enabled EP13 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 14 defines ---------- 
.................... #ifndef USB_EP14_TX_ENABLE 
....................  #define USB_EP14_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP14_RX_ENABLE 
....................  #define USB_EP14_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP14_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP14_RX_SIZE 
....................   #undef USB_EP14_RX_SIZE 
....................  #endif 
....................  #define USB_EP14_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP14_RX_SIZE 
....................   #error You enabled EP14 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP14_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP14_TX_SIZE 
....................   #undef USB_EP14_TX_SIZE 
....................  #endif 
....................  #define USB_EP14_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP14_TX_SIZE 
....................   #error You enabled EP14 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 15 defines ---------- 
.................... #ifndef USB_EP15_TX_ENABLE 
....................  #define USB_EP15_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP15_RX_ENABLE 
....................  #define USB_EP15_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP15_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP15_RX_SIZE 
....................   #undef USB_EP15_RX_SIZE 
....................  #endif 
....................  #define USB_EP15_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP15_RX_SIZE 
....................   #error You enabled EP15 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP15_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP15_TX_SIZE 
....................   #undef USB_EP15_TX_SIZE 
....................  #endif 
....................  #define USB_EP15_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP15_TX_SIZE 
....................   #error You enabled EP15 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... const int8 usb_ep_tx_type[16]={ 
....................   USB_EP0_TX_ENABLE, USB_EP1_TX_ENABLE, USB_EP2_TX_ENABLE, 
....................   USB_EP3_TX_ENABLE, USB_EP4_TX_ENABLE, USB_EP5_TX_ENABLE, 
....................   USB_EP6_TX_ENABLE, USB_EP7_TX_ENABLE, USB_EP8_TX_ENABLE, 
....................   USB_EP9_TX_ENABLE, USB_EP10_TX_ENABLE, USB_EP11_TX_ENABLE, 
....................   USB_EP12_TX_ENABLE, USB_EP13_TX_ENABLE, USB_EP14_TX_ENABLE, 
....................   USB_EP15_TX_ENABLE 
.................... }; 
....................  
.................... const int8 usb_ep_rx_type[16]={ 
....................   USB_EP0_RX_ENABLE, USB_EP1_RX_ENABLE, USB_EP2_RX_ENABLE, 
....................   USB_EP3_RX_ENABLE, USB_EP4_RX_ENABLE, USB_EP5_RX_ENABLE, 
....................   USB_EP6_RX_ENABLE, USB_EP7_RX_ENABLE, USB_EP8_RX_ENABLE, 
....................   USB_EP9_RX_ENABLE, USB_EP10_RX_ENABLE, USB_EP11_RX_ENABLE, 
....................   USB_EP12_RX_ENABLE, USB_EP13_RX_ENABLE, USB_EP14_RX_ENABLE, 
....................   USB_EP15_RX_ENABLE 
.................... }; 
....................  
.................... const int16 usb_ep_tx_size[16]={ 
....................   USB_EP0_TX_SIZE, USB_EP1_TX_SIZE, USB_EP2_TX_SIZE, 
....................   USB_EP3_TX_SIZE, USB_EP4_TX_SIZE, USB_EP5_TX_SIZE, 
....................   USB_EP6_TX_SIZE, USB_EP7_TX_SIZE, USB_EP8_TX_SIZE, 
....................   USB_EP9_TX_SIZE, USB_EP10_TX_SIZE, USB_EP11_TX_SIZE, 
....................   USB_EP12_TX_SIZE, USB_EP13_TX_SIZE, USB_EP14_TX_SIZE, 
....................   USB_EP15_TX_SIZE 
.................... }; 
....................  
.................... const int16 usb_ep_rx_size[16]={ 
....................   USB_EP0_RX_SIZE, USB_EP1_RX_SIZE, USB_EP2_RX_SIZE, 
....................   USB_EP3_RX_SIZE, USB_EP4_RX_SIZE, USB_EP5_RX_SIZE, 
....................   USB_EP6_RX_SIZE, USB_EP7_RX_SIZE, USB_EP8_RX_SIZE, 
....................   USB_EP9_RX_SIZE, USB_EP10_RX_SIZE, USB_EP11_RX_SIZE, 
....................   USB_EP12_RX_SIZE, USB_EP13_RX_SIZE, USB_EP14_RX_SIZE, 
....................   USB_EP15_RX_SIZE 
.................... }; 
....................  
.................... #ENDIF 
....................  
....................  
.................... #IFNDEF __USB_HARDWARE__ 
....................    #ERROR You must include USB hardware driver. 
.................... #ENDIF 
....................  
.................... #IFNDEF __USB_DESCRIPTORS__ 
....................    #ERROR You must include USB descriptors. 
.................... #ENDIF 
....................  
.................... int8 USB_address_pending;                        //save previous state because packets can take several isrs 
.................... int8 usb_getdesc_ptr; int8 usb_getdesc_len=0;             //for reading string and config descriptors 
....................  
.................... #IF USB_HID_BOOT_PROTOCOL 
.................... int8 hid_protocol[USB_NUM_HID_INTERFACES]; 
.................... #ENDIF 
....................  
.................... int8 USB_Interface[USB_MAX_NUM_INTERFACES];              //config state for all of our interfaces, NUM_INTERFACES defined with descriptors 
....................  
.................... /// BEGIN User Functions 
....................  
.................... /**************************************************************************** 
.................... /* usb_kbhit(endpoint) 
.................... /* 
.................... /* Input: endpoint - endpoint to check 
.................... /* 
.................... /* Output: TRUE if there is new data in RX buffer, FALSE if there is not. 
.................... /* 
.................... /* Summary: Similar to kbhit(), sees if there is new data in the RX USB buffers. 
.................... /* 
.................... /*****************************************************************************/ 
.................... #define usb_kbhit(x) bit_test(__usb_kbhit_status,x) 
....................  
.................... /************************************************************** 
.................... /* usb_enumerated() 
.................... /* 
.................... /* Input: Global variable USB_Curr_Config 
.................... /* Returns: Returns a 1 if device is configured / enumerated, 
.................... /*          Returns a 0 if device is un-configured / not enumerated. 
.................... /* 
.................... /* Summary: Use this to see if device is configured / enumerated. 
.................... /***************************************************************/ 
.................... #define usb_enumerated() (USB_stack_status.curr_config) 
....................  
.................... /************************************************************** 
.................... /* usb_wait_for_enumeration() 
.................... /* 
.................... /* Input: Global variable USB_Curr_Config 
.................... /* 
.................... /* Summary: Waits in-definately until device is configured / enumerated. 
.................... /***************************************************************/ 
.................... void usb_wait_for_enumeration(void) { 
....................    while (USB_stack_status.curr_config == 0) {restart_wdt();} 
.................... } 
....................  
.................... /**************************************************************************** 
.................... /* usb_puts(endpoint, *ptr, len, timeout) 
.................... /* 
.................... /* Inputs: endpoint - endpoint to send data out 
.................... /*         ptr - points to array of data to send 
.................... /*         len - amount of data to send 
.................... /*         timeout - time in milli-seconds, for each packet, to wait before timeout. 
.................... /*                   set to 0 for no timeout. 
.................... /* 
.................... /* Summary: Used for sending multiple packets of data as one message.  If sending 
.................... /*          only one packet it is more effecient to use only usb_put_packet() 
.................... /* 
.................... /*****************************************************************************/ 
.................... int1 usb_puts(int8 endpoint, int8 * ptr, int16 len, int8 timeout) { 
....................    int16 i=0; 
....................    int1 res; 
....................    int16 this_packet_len; 
....................    int16 packet_size; 
....................    int32 timeout_1us; 
....................  
....................    packet_size=usb_ep_tx_size[endpoint]; 
....................  
....................    //send data packets until timeout or no more packets to send 
....................    while (i < len) { 
....................       timeout_1us=(int32)timeout*1000; 
....................       if ((len - i) > packet_size) {this_packet_len=packet_size;} 
....................       else {this_packet_len=len-i;} 
....................       do { 
....................          res=usb_put_packet(endpoint,ptr + i,this_packet_len,USB_DTS_TOGGLE);   //send 64 byte packets 
....................          if (!res) { 
....................             delay_us(1); 
....................             timeout_1us--; 
....................          } 
....................       } while (!res && timeout_1us); 
....................       i+=packet_size; 
....................    } 
....................  
....................  
....................    //send 0len packet if needed 
....................    if (i==len) { 
....................       timeout_1us=(int32)timeout*1000; 
....................       do { 
....................          res=usb_put_packet(endpoint,0,0,USB_DTS_TOGGLE);   //indicate end of message 
....................          if (!res) { 
....................             delay_us(1); 
....................             timeout_1us--; 
....................          } 
....................       } while (!res && timeout_1us); 
....................    } 
....................  
....................    return(res); 
.................... } 
....................  
.................... /**************************************************************************** 
.................... /* usb_gets(endpoint, ptr, max, timeout) 
.................... /* 
.................... /* Input: endpoint - endpoint to get data from 
.................... /*        ptr - place / array to store data to 
.................... /*        max - max amount of data to get from USB and store into ptr 
.................... /*         timeout - time in milliseconds, for each packet, to wait before timeout. 
.................... /*                   set to 0 for no timeout. 
.................... /* 
.................... /* Output: Amount of data returned.  It may be less than max. 
.................... /* 
.................... /* Summary: Gets data from the host.  Will get multiple-packet messages 
.................... /*          and finish when either it receives a 0-len packet or a packet 
.................... /*          of less size than maximum. 
.................... /* 
.................... /* NOTE: NOT THOUROUGHLY TESTED.  I AM NOT EVEN SURE IF THIS IS A GOOD IDEA 
.................... /* 
.................... /*****************************************************************************/ 
.................... int8 usb_gets(int8 endpoint, int8 * ptr, int16 max, int16 timeout) { 
....................    int16 ret=0; 
....................    int16 to; 
....................    int16 len; 
....................    int16 packet_size; 
....................    int16 this_packet_max; 
....................  
....................    packet_size=usb_ep_rx_size[endpoint]; 
....................  
....................    do { 
....................       if (packet_size < max) {this_packet_max=packet_size;} else {this_packet_max=max;} 
....................       to=0; 
....................       do { 
....................          if (usb_kbhit(endpoint)) { 
....................             len=usb_get_packet(endpoint,ptr,this_packet_max); 
....................             ptr+=len; 
....................             max-=len; 
....................             ret+=len; 
....................             break; 
....................          } 
....................          else { 
....................             to++; 
....................             delay_ms(1); 
....................          } 
....................       } while (to!=timeout); 
....................    } while ((len == packet_size) && (to!=timeout) && max); 
....................  
....................    return(ret); 
.................... } 
....................  
.................... /// END User Functions 
....................  
....................  
.................... /// BEGIN USB Token, standard and HID request handler (part of ISR) 
....................  
.................... /************************************************************** 
.................... /* usb_token_reset() 
.................... /* 
.................... /* Output: modifies global variables USB_Interface[], in[], usb_getdesc_ptr, 
.................... /*         usb_getdesc_len, USB_status_device, USB_dev_req 
.................... /* 
.................... /* Summary: Resets the token handler to initial (unconfigured) state. 
.................... /***************************************************************/ 
.................... void usb_token_reset() { 
....................    int i; 
....................  
....................  
....................  
....................       for (i=0;i<USB_MAX_NUM_INTERFACES;i++) { 
*
1A66:  MOVLB  1
1A68:  CLRF   xB0
1A6A:  MOVF   xB0,W
1A6C:  SUBLW  01
1A6E:  BNC   1A84
....................          USB_Interface[i]=0;   //reset each interface to default 
1A70:  CLRF   03
1A72:  MOVF   xB0,W
1A74:  ADDLW  2E
1A76:  MOVWF  FE9
1A78:  MOVLW  00
1A7A:  ADDWFC 03,W
1A7C:  MOVWF  FEA
1A7E:  CLRF   FEF
....................       } 
....................  
....................   #IF USB_HID_BOOT_PROTOCOL 
....................    for (i=0;i<USB_NUM_HID_INTERFACES; i++) { 
....................        hid_protocol[i]=1; 
....................    } 
....................   #endif 
....................  
....................   #if USB_CDC_DEVICE 
1A80:  INCF   xB0,F
1A82:  BRA    1A6A
....................    usb_cdc_init(); 
1A84:  MOVLB  0
1A86:  RCALL  1A42
....................   #endif 
....................  
....................     USB_stack_status.curr_config=0;      //unconfigured device 
1A88:  CLRF   20
....................  
....................     USB_stack_status.status_device=1;    //previous state.  init at none 
1A8A:  MOVLW  01
1A8C:  MOVWF  21
....................     USB_stack_status.dev_req=NONE;       //previous token request state.  init at none 
1A8E:  CLRF   1F
.................... } 
1A90:  RETLW  00
....................  
.................... //send a 0len packet to endpoint 0 (optimization) 
.................... //notice that this doesnt return the status 
.................... #define usb_put_0len_0() usb_request_send_response(0) 
....................  
.................... /************************************************************** 
.................... /* usb_endpoint_is_valid(endpoint) 
.................... /* 
.................... /* Input: endpoint - endpoint to check. 
.................... /*                   bit 7 is direction (set is IN, clear is OUT) 
.................... /* 
.................... /* Output: TRUE if endpoint is valid, FALSE if not 
.................... /* 
.................... /* Summary: Checks the dynamic configuration to see if requested 
.................... /*          endpoint is a valid endpoint. 
.................... /***************************************************************/ 
.................... // 
.................... int1 usb_endpoint_is_valid(int8 endpoint) { 
....................    int1 direction; 
....................    direction = bit_test(endpoint,7); 
*
1F54:  MOVLB  1
1F56:  BCF    xB2.0
1F58:  BTFSC  xB1.7
1F5A:  BSF    xB2.0
....................    endpoint &= 0x7F; 
1F5C:  BCF    xB1.7
....................    if (direction) { //IN 
1F5E:  BTFSS  xB2.0
1F60:  BRA    1F86
....................       return(usb_ep_tx_type[endpoint] != USB_ENABLE_DISABLED); 
1F62:  CLRF   03
1F64:  MOVF   xB1,W
1F66:  MOVFF  FF2,1B3
1F6A:  BCF    FF2.7
1F6C:  MOVLB  0
1F6E:  RCALL  189E
1F70:  MOVLB  1
1F72:  BTFSC  xB3.7
1F74:  BSF    FF2.7
1F76:  XORLW  00
1F78:  BNZ   1F7E
1F7A:  MOVLW  00
1F7C:  BRA    1F80
1F7E:  MOVLW  01
1F80:  MOVWF  01
1F82:  BRA    1FA8
....................    } 
....................    else {   //OUT 
1F84:  BRA    1FA8
....................       return(usb_ep_rx_type[endpoint] != USB_ENABLE_DISABLED); 
1F86:  CLRF   03
1F88:  MOVF   xB1,W
1F8A:  MOVFF  FF2,1B3
1F8E:  BCF    FF2.7
1F90:  MOVLB  0
1F92:  RCALL  18BE
1F94:  MOVLB  1
1F96:  BTFSC  xB3.7
1F98:  BSF    FF2.7
1F9A:  XORLW  00
1F9C:  BNZ   1FA2
1F9E:  MOVLW  00
1FA0:  BRA    1FA4
1FA2:  MOVLW  01
1FA4:  MOVWF  01
1FA6:  BRA    1FA8
....................    } 
.................... } 
1FA8:  MOVLB  0
1FAA:  GOTO   209A (RETURN)
....................  
.................... ///---------------------------------------------------------------/// 
.................... /// Processing Message stages is the biggest portion of the ISR   /// 
.................... ///---------------------------------------------------------------/// 
....................  
.................... /************************************************************** 
.................... /* usb_isr_tok_in_dne(endpoint) 
.................... /* 
.................... /* Input: endpoint - which endpoint we are processing a setup token.  Should be 0. 
.................... /* 
.................... /* Summary: When receiving an IN token from the PC on endpoint 0 that means the 
.................... /*          host is asking for a response from a setup token, or the next packet 
.................... /*          from a currently processing token.  (For example, a 24 byte descriptor 
.................... /*          would require 3 IN tokens if the packet size is 8 bytes.)  USB_dev_req 
.................... /*          is a global variable that defines what setup token we are currently processing. 
.................... /* 
.................... /* Part of USB interrupt service routine. 
.................... /* Only checks endpoint 0. 
.................... /***************************************************************/ 
.................... void usb_isr_tok_in_dne(int8 endpoint) { 
....................    if (endpoint==0) { 
*
2598:  MOVLB  1
259A:  MOVF   xB1,F
259C:  BNZ   25BA
....................       if (USB_stack_status.dev_req == GET_DESCRIPTOR) {usb_copy_desc_seg_to_ep();} //check this, we are missing report descriptor? 
259E:  DECFSZ 1F,W
25A0:  BRA    25AC
25A2:  MOVLB  0
25A4:  CALL   1B34
....................       else if (USB_stack_status.dev_req == SET_ADDRESS) {usb_finish_set_address();} 
25A8:  BRA    25B6
25AA:  MOVLB  1
25AC:  MOVF   1F,W
25AE:  SUBLW  02
25B0:  BNZ   25B8
25B2:  MOVLB  0
25B4:  BRA    24AA
25B6:  MOVLB  1
....................    } 
....................   #if USB_CDC_DEVICE 
....................   else if (endpoint==USB_CDC_DATA_IN_ENDPOINT) { //see ex_usb_serial.c example and usb_cdc.h driver 
25B8:  BRA    25C6
25BA:  MOVF   xB1,W
25BC:  SUBLW  02
25BE:  BNZ   25C6
....................       usb_isr_tok_in_cdc_data_dne(); 
25C0:  MOVLB  0
25C2:  BRA    258A
25C4:  MOVLB  1
....................   } 
....................   #endif 
.................... } 
25C6:  MOVLB  0
25C8:  RETLW  00
....................  
.................... /************************************************************** 
.................... /* usb_isr_tok_out_dne(endpoint) 
.................... /* 
.................... /* Input: endpoint contains which endpoint we are receiving data. 
.................... /*        This code doesn't allow reception of data from EP0. (Add later) 
.................... /* 
.................... /* Summary: Processes out tokens (out is respective of the host, so actualy incoming 
.................... /*          to the pic), but not out setup tokens.  Data is placed into a 
.................... /*          a buffer if it is empty, and the rx flag is set.  If the buffer 
.................... /*          is not empty then the overrun bit of that EP status byte is set it. 
.................... /***************************************************************/ 
.................... void usb_isr_tok_out_dne(int8 endpoint) { 
....................    //TODO: 
....................    if (endpoint==0) { 
*
2452:  MOVLB  1
2454:  MOVF   xB1,F
2456:  BNZ   2460
....................      debug_usb(debug_putc,"TOUT 0 "); 
....................      #if USB_CDC_DEVICE 
....................       usb_isr_tok_out_cdc_control_dne(); 
2458:  MOVLB  0
245A:  BRA    23AC
....................      #else 
....................       usb_init_ep0_setup(); 
....................      #endif 
....................    } 
....................   #if USB_CDC_DEVICE 
....................    else if (endpoint==USB_CDC_DATA_OUT_ENDPOINT) { //see ex_usb_serial.c example and usb_cdc.h driver 
245C:  BRA    248C
245E:  MOVLB  1
2460:  MOVF   xB1,W
2462:  SUBLW  02
2464:  BNZ   246E
....................       usb_isr_tok_out_cdc_data_dne(); 
2466:  MOVLB  0
2468:  BRA    243C
....................    } 
....................   #endif 
....................    else { 
246A:  BRA    248C
246C:  MOVLB  1
....................       bit_set(__usb_kbhit_status,endpoint); 
246E:  CLRF   03
2470:  MOVLW  01
2472:  MOVWF  02
2474:  MOVF   xB1,W
2476:  MOVWF  00
2478:  BZ    2484
247A:  BCF    FD8.0
247C:  RLCF   02,F
247E:  RLCF   03,F
2480:  DECFSZ 00,F
2482:  BRA    247A
2484:  MOVF   02,W
2486:  IORWF  23,F
2488:  MOVF   03,W
248A:  IORWF  24,F
248C:  MOVLB  0
....................    } 
.................... } 
248E:  RETLW  00
....................  
....................  
.................... //---- process setup message stage -----------// 
.................... ////// HUGE - most of our code is to read setup messages //// 
....................  
.................... /************************************************************** 
.................... /* usb_isr_tok_setup_dne() 
.................... /* 
.................... /* Input: usb_ep0_rx_buffer[] contains the 8 bytes of the setup packet. 
.................... /* 
.................... /* Output: The DTS we expect for the next packet on OUT 0. 
.................... /* 
.................... /* Summary: This function is the start of code that handles the setup token. 
.................... /*          We must handle all relevant requests, such as Set_Configuration, Get_Descriptor, etc. 
.................... /* 
.................... /*  usb_ep0_rx_buffer[8] now contains setup data packet, which has the following records 
.................... /*  ------------------------------------------------------------------------------------------- 
.................... /*  usb_ep0_rx_buffer[ 0 ]=bmRequestType; Where the setup packet goes 
.................... /*                              bit7   (0) host-to-device 
.................... /*                                     (1) device-to-host 
.................... /*                              bit6-5 (00) usb standard request; 
.................... /*                                     (01) class request; 
.................... /*                                     (10) vendor request 
....................                                        (11) reserved 
.................... /*                              bit4-0 (0000) device 
.................... /*                                     (0001) interface 
.................... /*                                     (0010) endpoint 
.................... /*                                     (0011) other element 
.................... /*                                     (0100) to (1111) reserved 
.................... /*  usb_ep0_rx_buffer[ 1 ]=bRequest ; the request 
.................... /*  usb_ep0_rx_buffer[2,3]=wValue ; a value which corresponds to request 
.................... /*  usb_ep0_rx_buffer[4,5]=wIndex ; could correspond to interface or endpoint... 
.................... /*  usb_ep0_rx_buffer[6,7]=wLength ; number of bytes in next data packet 
.................... /*                        for host-to-device, this exactly how many bytes in data packet 
.................... /*                        for device-to-host, this is the maximum bytes that can fit one packet 
.................... /***************************************************************/ 
.................... void usb_isr_tok_setup_dne(void) { 
....................    USB_stack_status.dev_req=NONE; // clear the device request.. 
*
21B2:  CLRF   1F
....................  
....................    switch(usb_ep0_rx_buffer[0] & 0x7F) { 
21B4:  MOVLB  5
21B6:  MOVF   x00,W
21B8:  ANDLW  7F
21BA:  MOVLB  0
21BC:  BZ    21CC
21BE:  XORLW  01
21C0:  BZ    21CE
21C2:  XORLW  03
21C4:  BZ    21D0
21C6:  XORLW  23
21C8:  BZ    21D2
21CA:  BRA    21D4
....................  
....................       case 0x00:  //standard to device 
....................          debug_usb(debug_putc," d"); 
....................          usb_isr_tkn_setup_StandardDevice(); 
21CC:  BRA    1DF8
....................          break; 
....................  
....................       case 0x01:  //standard to interface 
....................          debug_usb(debug_putc," i"); 
....................          usb_isr_tkn_setup_StandardInterface(); 
21CE:  BRA    1EAC
....................          break; 
....................  
....................       case 0x02:  //standard to endpoint 
....................          debug_usb(debug_putc," e"); 
....................          usb_isr_tkn_setup_StandardEndpoint(); 
21D0:  BRA    2094
....................          break; 
....................  
.................... #IF USB_HID_DEVICE 
....................       case 0x21:  //class specific request.  the only class this driver supports is HID 
....................          debug_usb(debug_putc," hid"); 
....................          usb_isr_tkn_setup_ClassInterface(); 
....................          break; 
.................... #endif 
....................  
.................... #if USB_CDC_DEVICE 
....................       case 0x21: 
....................          debug_usb(debug_putc," cdc"); 
....................          usb_isr_tkn_cdc(); 
21D2:  BRA    2104
....................          break; 
.................... #endif 
....................       //TODO: IF YOU WANT VENDOR SPECIFC REQUEST SUPPORT YOU MUST ADD IT HERE 
....................  
....................       default: 
....................          usb_request_stall(); 
21D4:  RCALL  1B2E
....................          break; 
21D6:  BRA    21D8
....................    } 
.................... } 
21D8:  GOTO   25EC (RETURN)
....................  
.................... /************************************************************** 
.................... /* usb_isr_tkn_setup_StandardDevice() 
.................... /* 
.................... /* Input: usb_ep0_rx_buffer[1] == bRequest 
.................... /* 
.................... /* Summary: bmRequestType told us it was a Standard Device request. 
.................... /*          bRequest says which request.  Only certain requests are valid, 
.................... /*          if a non-valid request was made then return with an Wrong-Statue (IDLE) 
.................... /* 
.................... /* Part of usb_isr_tok_setup_dne() 
.................... /***************************************************************/ 
.................... void usb_isr_tkn_setup_StandardDevice(void) { 
....................    switch(usb_ep0_rx_buffer[1]) { 
*
1DF8:  MOVLB  5
1DFA:  MOVF   x01,W
1DFC:  MOVLB  0
1DFE:  BZ    1E1A
1E00:  XORLW  01
1E02:  BZ    1E2E
1E04:  XORLW  02
1E06:  BZ    1E48
1E08:  XORLW  06
1E0A:  BZ    1E60
1E0C:  XORLW  03
1E0E:  BZ    1E72
1E10:  XORLW  0E
1E12:  BZ    1E74
1E14:  XORLW  01
1E16:  BZ    1E84
1E18:  BRA    1EA4
....................  
....................       case USB_STANDARD_REQUEST_GET_STATUS:  //0 
....................             debug_usb(debug_putc,"GS"); 
....................             usb_ep0_tx_buffer[0]=USB_stack_status.status_device; 
1E1A:  MOVFF  21,540
....................             usb_ep0_tx_buffer[1]=0; 
1E1E:  MOVLB  5
1E20:  CLRF   x41
....................             usb_request_send_response(2); 
1E22:  MOVLW  02
1E24:  MOVLB  1
1E26:  MOVWF  xB4
1E28:  MOVLB  0
1E2A:  RCALL  1B28
....................             break; 
1E2C:  BRA    1EA8
....................  
....................       case USB_STANDARD_REQUEST_CLEAR_FEATURE:  //1 
....................             if (usb_ep0_rx_buffer[2] == 1) { 
1E2E:  MOVLB  5
1E30:  DECFSZ x02,W
1E32:  BRA    1E42
....................                debug_usb(debug_putc,"CF"); 
....................                USB_stack_status.status_device &= 1; 
1E34:  MOVLW  01
1E36:  ANDWF  21,F
....................                usb_put_0len_0(); 
1E38:  MOVLB  1
1E3A:  CLRF   xB4
1E3C:  MOVLB  0
1E3E:  RCALL  1B28
....................             } 
....................             else 
1E40:  BRA    1E46
....................                usb_request_stall(); 
1E42:  MOVLB  0
1E44:  RCALL  1B2E
....................             break; 
1E46:  BRA    1EA8
....................  
....................       case USB_STANDARD_REQUEST_SET_FEATURE: //3 
....................             if (usb_ep0_rx_buffer[2] == 1) { 
1E48:  MOVLB  5
1E4A:  DECFSZ x02,W
1E4C:  BRA    1E5A
....................                debug_usb(debug_putc,"SF"); 
....................                USB_stack_status.status_device |= 2; 
1E4E:  BSF    21.1
....................                usb_put_0len_0(); 
1E50:  MOVLB  1
1E52:  CLRF   xB4
1E54:  MOVLB  0
1E56:  RCALL  1B28
....................             } 
....................             else 
1E58:  BRA    1E5E
....................                usb_request_stall(); 
1E5A:  MOVLB  0
1E5C:  RCALL  1B2E
....................             break; 
1E5E:  BRA    1EA8
....................  
....................       case USB_STANDARD_REQUEST_SET_ADDRESS: //5 
....................             debug_usb(debug_putc,"SA"); 
....................             USB_stack_status.dev_req=SET_ADDRESS; //currently processing set_address request 
1E60:  MOVLW  02
1E62:  MOVWF  1F
....................             USB_address_pending=usb_ep0_rx_buffer[2]; 
1E64:  MOVFF  502,2B
....................             #ifdef __USBN__   //NATIONAL part handles this differently than pic16c7x5 
....................             USB_stack_status.dev_req=NONE; //currently processing set_address request 
....................             usb_set_address(USB_address_pending); 
....................          	USB_stack_status.curr_config=0;	// make sure current configuration is 0 
....................             #endif 
....................             usb_put_0len_0(); 
1E68:  MOVLB  1
1E6A:  CLRF   xB4
1E6C:  MOVLB  0
1E6E:  RCALL  1B28
....................             break; 
1E70:  BRA    1EA8
....................  
....................       case USB_STANDARD_REQUEST_GET_DESCRIPTOR: //6 
....................             debug_usb(debug_putc,"GD"); 
....................             usb_Get_Descriptor(); 
1E72:  BRA    1BCC
....................             break; 
....................  
....................       case USB_STANDARD_REQUEST_GET_CONFIGURATION: //8 
....................             debug_usb(debug_putc,"GC"); 
....................             usb_ep0_tx_buffer[0]=USB_stack_status.curr_config; 
1E74:  MOVFF  20,540
....................             usb_request_send_response(1); 
1E78:  MOVLW  01
1E7A:  MOVLB  1
1E7C:  MOVWF  xB4
1E7E:  MOVLB  0
1E80:  RCALL  1B28
....................             break; 
1E82:  BRA    1EA8
....................  
....................       case USB_STANDARD_REQUEST_SET_CONFIGURATION: //9 
....................             if (usb_ep0_rx_buffer[2] <= USB_NUM_CONFIGURATIONS) { 
1E84:  MOVLB  5
1E86:  MOVF   x02,W
1E88:  SUBLW  01
1E8A:  BNC   1EA0
....................                debug_usb(debug_putc,"SC"); 
....................                USB_stack_status.curr_config=usb_ep0_rx_buffer[2]; 
1E8C:  MOVFF  502,20
....................                usb_set_configured(usb_ep0_rx_buffer[2]); 
1E90:  MOVFF  502,1B1
1E94:  MOVLB  0
1E96:  BRA    1C46
....................                usb_put_0len_0(); 
1E98:  MOVLB  1
1E9A:  CLRF   xB4
1E9C:  MOVLB  0
1E9E:  RCALL  1B28
....................             } 
....................             break; 
1EA0:  MOVLB  0
1EA2:  BRA    1EA8
....................  
....................       default: 
....................             usb_request_stall(); 
1EA4:  RCALL  1B2E
....................             break; 
1EA6:  BRA    1EA8
....................    } 
.................... } 
1EA8:  GOTO   21D8 (RETURN)
....................  
.................... /************************************************************** 
.................... /* usb_isr_tkn_setup_StandardInterface() 
.................... /* 
.................... /* Input: usb_ep0_rx_buffer[1] == bRequest 
.................... /* 
.................... /* Summary: bmRequestType told us it was a Standard Interface request. 
.................... /*          bRequest says which request.  Only certain requests are valid, 
.................... /*          if a non-valid request was made then return with an Wrong-Statue (IDLE) 
.................... /* 
.................... /* Part of usb_isr_tok_setup_dne() 
.................... /***************************************************************/ 
.................... void usb_isr_tkn_setup_StandardInterface(void) { 
....................    int8 curr_config; 
....................  
....................    curr_config=USB_stack_status.curr_config; 
1EAC:  MOVFF  20,1B1
....................  
....................    switch (usb_ep0_rx_buffer[1]) { 
1EB0:  MOVLB  5
1EB2:  MOVF   x01,W
1EB4:  MOVLB  0
1EB6:  BZ    1EC2
1EB8:  XORLW  0A
1EBA:  BZ    1ED4
1EBC:  XORLW  01
1EBE:  BZ    1F22
1EC0:  BRA    1F4C
....................       case USB_STANDARD_REQUEST_GET_STATUS: 
....................             debug_usb(debug_putc,"GS"); 
....................             usb_ep0_tx_buffer[0]=0; 
1EC2:  MOVLB  5
1EC4:  CLRF   x40
....................             usb_ep0_tx_buffer[1]=0; 
1EC6:  CLRF   x41
....................             usb_request_send_response(2); 
1EC8:  MOVLW  02
1ECA:  MOVLB  1
1ECC:  MOVWF  xB4
1ECE:  MOVLB  0
1ED0:  RCALL  1B28
....................             break; 
1ED2:  BRA    1F50
....................  
....................       case USB_STANDARD_REQUEST_GET_INTERFACE: 
....................             if ( curr_config && (usb_ep0_rx_buffer[4] < USB_NUM_INTERFACES[curr_config-1]) ) {   //book says only supports configed state 
1ED4:  MOVLB  1
1ED6:  MOVF   xB1,F
1ED8:  BZ    1F1C
1EDA:  MOVLW  01
1EDC:  SUBWF  xB1,W
1EDE:  CLRF   03
1EE0:  MOVFF  FF2,1B2
1EE4:  BCF    FF2.7
1EE6:  MOVLB  0
1EE8:  RCALL  19A4
1EEA:  MOVLB  1
1EEC:  BTFSC  xB2.7
1EEE:  BSF    FF2.7
1EF0:  MOVWF  01
1EF2:  MOVLB  5
1EF4:  SUBWF  x04,W
1EF6:  BTFSS  FD8.0
1EF8:  BRA    1EFE
1EFA:  MOVLB  1
1EFC:  BRA    1F1C
....................                debug_usb(debug_putc,"GI"); 
....................                usb_ep0_tx_buffer[0]=USB_Interface[usb_ep0_rx_buffer[4]];//our new outgoing byte 
1EFE:  CLRF   03
1F00:  MOVF   x04,W
1F02:  ADDLW  2E
1F04:  MOVWF  FE9
1F06:  MOVLW  00
1F08:  ADDWFC 03,W
1F0A:  MOVWF  FEA
1F0C:  MOVFF  FEF,540
....................                usb_request_send_response(1);; //send byte back 
1F10:  MOVLW  01
1F12:  MOVLB  1
1F14:  MOVWF  xB4
1F16:  MOVLB  0
1F18:  RCALL  1B28
....................             } 
....................             else 
1F1A:  BRA    1F20
....................                usb_request_stall(); 
1F1C:  MOVLB  0
1F1E:  RCALL  1B2E
....................             break; 
1F20:  BRA    1F50
....................  
....................       case USB_STANDARD_REQUEST_SET_INTERFACE: 
....................             if (curr_config) { //if configured state 
1F22:  MOVLB  1
1F24:  MOVF   xB1,F
1F26:  BZ    1F46
....................                debug_usb(debug_putc,"SI"); 
....................                USB_Interface[usb_ep0_rx_buffer[4]]=usb_ep0_rx_buffer[2]; 
1F28:  CLRF   03
1F2A:  MOVLB  5
1F2C:  MOVF   x04,W
1F2E:  ADDLW  2E
1F30:  MOVWF  FE9
1F32:  MOVLW  00
1F34:  ADDWFC 03,W
1F36:  MOVWF  FEA
1F38:  MOVFF  502,FEF
....................                usb_put_0len_0(); 
1F3C:  MOVLB  1
1F3E:  CLRF   xB4
1F40:  MOVLB  0
1F42:  RCALL  1B28
....................             } 
....................             else 
1F44:  BRA    1F4A
....................                usb_request_stall(); 
1F46:  MOVLB  0
1F48:  RCALL  1B2E
....................             break; 
1F4A:  BRA    1F50
....................  
.................... #IF USB_HID_DEVICE 
....................       case USB_STANDARD_REQUEST_GET_DESCRIPTOR: 
....................             debug_usb(debug_putc,"GD"); 
....................             usb_Get_Descriptor(); 
....................             break; 
.................... #endif 
....................  
.................... //      case USB_STANDARD_REQUEST_CLEAR_FEATURE: 
.................... //      case USB_STANDARD_REQUEST_SET_FEATURE: 
.................... //                let default take care of these, goto wrongstate 
....................       default: 
....................             usb_request_stall(); 
1F4C:  RCALL  1B2E
....................             break; 
1F4E:  BRA    1F50
....................    } 
.................... } 
1F50:  GOTO   21D8 (RETURN)
....................  
.................... /************************************************************** 
.................... /* usb_isr_tkn_setup_StandardEndpoint() 
.................... /* 
.................... /* Input: usb_ep0_rx_buffer[1] == bRequest 
.................... /* 
.................... /* Summary: bmRequestType told us it was a Standard Endpoint request. 
.................... /*          bRequest says which request.  Only certain requests are valid, 
.................... /*          if a non-valid request was made then return with an Wrong-Statue (IDLE) 
.................... /* 
.................... /* Part of usb_isr_tok_setup_dne() 
.................... /***************************************************************/ 
.................... void usb_isr_tkn_setup_StandardEndpoint(void) { 
....................    if (usb_endpoint_is_valid(usb_ep0_rx_buffer[4])) { 
*
2094:  MOVFF  504,1B1
2098:  BRA    1F54
209A:  MOVF   01,F
209C:  BZ    20FA
....................       switch(usb_ep0_rx_buffer[1]) { 
209E:  MOVLB  5
20A0:  MOVF   x01,W
20A2:  XORLW  01
20A4:  MOVLB  0
20A6:  BZ    20B2
20A8:  XORLW  02
20AA:  BZ    20C2
20AC:  XORLW  03
20AE:  BZ    20D2
20B0:  BRA    20F6
....................  
....................          case USB_STANDARD_REQUEST_CLEAR_FEATURE: 
....................                debug_usb(debug_putc,"CF"); 
....................                usb_unstall_ep(usb_ep0_rx_buffer[4]); 
20B2:  MOVFF  504,1B1
20B6:  BRA    1FAE
....................                usb_put_0len_0(); 
20B8:  MOVLB  1
20BA:  CLRF   xB4
20BC:  MOVLB  0
20BE:  RCALL  1B28
....................                break; 
20C0:  BRA    20FA
....................  
....................          case USB_STANDARD_REQUEST_SET_FEATURE: 
....................                      debug_usb(debug_putc,"SF"); 
....................                      usb_stall_ep(usb_ep0_rx_buffer[4]); 
20C2:  MOVFF  504,1B1
20C6:  BRA    1FF4
....................                      usb_put_0len_0(); 
20C8:  MOVLB  1
20CA:  CLRF   xB4
20CC:  MOVLB  0
20CE:  RCALL  1B28
....................                      break; 
20D0:  BRA    20FA
....................  
....................          case USB_STANDARD_REQUEST_GET_STATUS: 
....................                debug_usb(debug_putc,"GS"); 
....................                usb_ep0_tx_buffer[0]=0; 
20D2:  MOVLB  5
20D4:  CLRF   x40
....................                usb_ep0_tx_buffer[1]=0; 
20D6:  CLRF   x41
....................                if (usb_endpoint_stalled(usb_ep0_rx_buffer[4])) { 
20D8:  MOVFF  504,1B1
20DC:  MOVLB  0
20DE:  BRA    203C
20E0:  MOVF   01,F
20E2:  BZ    20EA
....................                   usb_ep0_tx_buffer[0]=1; 
20E4:  MOVLW  01
20E6:  MOVLB  5
20E8:  MOVWF  x40
....................                } 
....................                usb_request_send_response(2); 
20EA:  MOVLW  02
20EC:  MOVLB  1
20EE:  MOVWF  xB4
20F0:  MOVLB  0
20F2:  RCALL  1B28
....................                break; 
20F4:  BRA    20FA
....................  
....................          default: 
....................             usb_request_stall(); 
20F6:  RCALL  1B2E
....................             break; 
20F8:  BRA    20FA
....................       } 
....................    } 
.................... } 
20FA:  GOTO   21D8 (RETURN)
....................  
.................... /************************************************************** 
.................... /* usb_isr_tkn_setup_ClassInterface() 
.................... /* 
.................... /* Input: usb_ep0_rx_buffer[1] == bRequest 
.................... /* 
.................... /* Summary: bmRequestType told us it was a Class request.  The only Class this drivers supports is HID. 
.................... /*          bRequest says which request.  Only certain requests are valid, 
.................... /*          if a non-valid request was made then return with an Wrong-Statue (IDLE) 
.................... /* 
.................... /* Part of usb_isr_tok_setup_dne() 
.................... /* Only compiled if HID_DEVICE is TRUE 
.................... /***************************************************************/ 
.................... #IF USB_HID_DEVICE 
.................... void usb_isr_tkn_setup_ClassInterface(void) { 
....................    switch(usb_ep0_rx_buffer[1]) { 
....................  
....................     #IF USB_HID_BOOT_PROTOCOL 
....................       case USB_HID_REQUEST_GET_PROTOCOL:  //03 
....................             debug_usb(debug_putc,"GP"); 
....................             usb_ep0_tx_buffer[0]=hid_protocol[usb_ep0_rx_buffer[4]]; 
....................             usb_request_send_response(1); 
....................             break; 
....................     #ENDIF 
....................  
....................     #IF USB_HID_BOOT_PROTOCOL 
....................       case USB_HID_REQUEST_SET_PROTOCOL:  //0b 
....................             debug_usb(debug_putc,"SP"); 
....................             hid_protocol[usb_ep0_rx_buffer[4]]=usb_ep0_rx_buffer[2]; 
....................             usb_put_0len_0(); //send 0len packet69 
....................             break; 
....................     #ENDIF 
....................  
....................    #IF USB_HID_IDLE 
....................       case USB_HID_REQUEST_SET_IDLE:   //0a 
....................          #error TODO: if you want to support SET_IDLE, add code here 
....................    #ENDIF 
....................  
....................    #IF USB_HID_IDLE 
....................       case USB_HID_REQUEST_GET_IDLE:   //02 
....................          #error TODO: if you want to support GET_IDLE, add code here 
....................    #ENDIF 
....................  
....................       default: 
....................             usb_request_stall(); 
....................             break; 
....................    } 
.................... } 
.................... #ENDIF 
....................  
.................... /************************************************************** 
.................... /* usb_Get_Descriptor() 
.................... /* 
.................... /* Input: usb_ep0_rx_buffer[3] == wValue, which descriptor we want 
.................... /*        usb_ep0_rx_buffer[6,7] == Max length the host will accept 
.................... /* 
.................... /* Summary: Checks to see if we want a standard descriptor (Interface, Endpoint, Config, Device, String, etc.), 
.................... /*          or a class specific (HID) descriptor.  Since some pics (especially the PIC167x5) doesn't have 
.................... /*          pointers to constants we must simulate or own by setting up global registers that say 
.................... /*          which constant array to deal with, which position to start in this array, and the length. 
.................... /*          Once these globals are setup the first packet is sent.  If a descriptor takes more than one packet 
.................... /*          the PC will send an IN request to endpoint 0, and this will be handled by usb_isr_tok_in_dne() 
.................... /*          which will send the rest of the data. 
.................... /* 
.................... /* Part of usb_isr_tok_setup_dne() 
.................... /***************************************************************/ 
.................... void usb_Get_Descriptor() { 
....................    usb_getdesc_ptr=0; 
*
1BCC:  CLRF   2C
....................    USB_stack_status.getdesc_type=USB_GETDESC_CONFIG_TYPE; 
1BCE:  CLRF   22
....................  
....................    switch(usb_ep0_rx_buffer[3]) { 
1BD0:  MOVLB  5
1BD2:  MOVF   x03,W
1BD4:  XORLW  01
1BD6:  MOVLB  0
1BD8:  BZ    1BE4
1BDA:  XORLW  03
1BDC:  BZ    1BEE
1BDE:  XORLW  01
1BE0:  BZ    1BF4
1BE2:  BRA    1C26
....................       case USB_DESC_DEVICE_TYPE:    //1 
....................             usb_getdesc_len=USB_DESC_DEVICE_LEN; 
1BE4:  MOVLW  12
1BE6:  MOVWF  2D
....................             USB_stack_status.getdesc_type=USB_GETDESC_DEVICE_TYPE; 
1BE8:  MOVLW  03
1BEA:  MOVWF  22
....................             break; 
1BEC:  BRA    1C2A
....................  
....................       //windows hosts will send a FF max len and expect you to send all configs without asking for them individually. 
....................       case USB_DESC_CONFIG_TYPE:   //2 
....................             usb_getdesc_len=USB_TOTAL_CONFIG_LEN; 
1BEE:  MOVLW  43
1BF0:  MOVWF  2D
....................             break; 
1BF2:  BRA    1C2A
....................  
....................       case USB_DESC_STRING_TYPE: //3 
....................             USB_stack_status.getdesc_type=USB_GETDESC_STRING_TYPE; 
1BF4:  MOVLW  02
1BF6:  MOVWF  22
....................             usb_getdesc_ptr=USB_STRING_DESC_OFFSET[usb_ep0_rx_buffer[2]]; 
1BF8:  CLRF   03
1BFA:  MOVLB  5
1BFC:  MOVF   x02,W
1BFE:  ADDLW  28
1C00:  MOVWF  FE9
1C02:  MOVLW  00
1C04:  ADDWFC 03,W
1C06:  MOVWF  FEA
1C08:  MOVFF  FEF,2C
....................             usb_getdesc_len=USB_STRING_DESC[usb_getdesc_ptr]; 
1C0C:  CLRF   03
1C0E:  MOVF   2C,W
1C10:  MOVFF  FF2,1B1
1C14:  BCF    FF2.7
1C16:  MOVLB  0
1C18:  RCALL  19D8
1C1A:  MOVLB  1
1C1C:  BTFSC  xB1.7
1C1E:  BSF    FF2.7
1C20:  MOVWF  2D
....................             break; 
1C22:  MOVLB  0
1C24:  BRA    1C2A
....................  
.................... #IF USB_HID_DEVICE 
....................       case USB_DESC_CLASS_TYPE:  //0x21 
....................             usb_getdesc_ptr=USB_CLASS_DESCRIPTORS[0][0][0]; 
....................             if (usb_getdesc_ptr!=0xFF) { 
....................                usb_getdesc_len=USB_CONFIG_DESC[usb_getdesc_ptr]; 
....................                break; 
....................             } 
....................             else { 
....................                usb_request_stall(); 
....................                return; 
....................             } 
....................  
....................  
....................       case USB_DESC_HIDREPORT_TYPE: //0x22 
....................             usb_getdesc_ptr=USB_CLASS_SPECIFIC_DESC_LOOKUP[0][usb_ep0_rx_buffer[4]]; 
....................             if (usb_getdesc_ptr !=0xFF) { 
....................                USB_stack_status.getdesc_type=USB_GETDESC_HIDREPORT_TYPE; 
....................                usb_getdesc_len=USB_CLASS_SPECIFIC_DESC_LOOKUP_SIZE[0][usb_ep0_rx_buffer[4]]; 
....................                break; 
....................             } 
....................             else { 
....................                usb_request_stall(); 
....................                return; 
....................             } 
.................... #endif 
....................  
....................       default: 
....................             usb_request_stall(); 
1C26:  RCALL  1B2E
....................             return; 
1C28:  BRA    1C42
....................    } 
....................    if (usb_ep0_rx_buffer[7]==0) { 
1C2A:  MOVLB  5
1C2C:  MOVF   x07,F
1C2E:  BNZ   1C3A
....................       if (usb_getdesc_len > usb_ep0_rx_buffer[6]) 
1C30:  MOVF   2D,W
1C32:  SUBWF  x06,W
1C34:  BC    1C3A
....................          usb_getdesc_len = usb_ep0_rx_buffer[6]; 
1C36:  MOVFF  506,2D
....................    } 
....................    USB_stack_status.dev_req=GET_DESCRIPTOR; 
1C3A:  MOVLW  01
1C3C:  MOVWF  1F
....................    usb_copy_desc_seg_to_ep(); 
1C3E:  MOVLB  0
1C40:  RCALL  1B34
.................... } 
1C42:  GOTO   1EA8 (RETURN)
....................  
.................... /************************************************************** 
.................... /* usb_finish_set_address() 
.................... /* 
.................... /* Input: USB_address_pending holds the address we were asked to set to. 
.................... /* 
.................... /* Summary: Sets the address. 
.................... /* 
.................... /* This code should only be run on the PIC USB peripheral, and not the 
.................... /* National peripheral. 
.................... /* 
.................... /* Part of usb_isr_tok_setup_dne() 
.................... /***************************************************************/ 
....................  void usb_finish_set_address() { 
....................    debug_usb(debug_putc," FSA "); 
.................... 	USB_stack_status.curr_config=0;	// make sure current configuration is 0 
*
24AA:  CLRF   20
....................  
....................    #ifdef __PIC__ 
.................... 	USB_stack_status.dev_req=NONE;  // no request pending 
24AC:  CLRF   1F
....................    usb_set_address(USB_address_pending); 
24AE:  MOVFF  2B,1B2
24B2:  BRA    2490
....................    #endif 
.................... } 
24B4:  GOTO   25B6 (RETURN)
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... /// 
.................... /// The following function retrieve data from constant arrays.  This may 
.................... /// look un-optimized, but remember that you can't create a pointer to 
.................... /// a constant array. 
.................... /// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... void usb_copy_desc_seg_to_ep(void) { 
....................    int i=0; 
*
1B34:  MOVLB  1
1B36:  CLRF   xB2
....................    char c; 
....................  
....................    while ((usb_getdesc_len)&&(i<USB_MAX_EP0_PACKET_LENGTH)) 
....................    { 
1B38:  MOVF   2D,F
1B3A:  BZ    1BB6
1B3C:  MOVF   xB2,W
1B3E:  SUBLW  3F
1B40:  BNC   1BB6
....................       switch(USB_stack_status.getdesc_type) { 
1B42:  MOVF   22,W
1B44:  MOVLB  0
1B46:  BZ    1B52
1B48:  XORLW  02
1B4A:  BZ    1B6A
1B4C:  XORLW  01
1B4E:  BZ    1B82
1B50:  BRA    1B9A
....................          case USB_GETDESC_CONFIG_TYPE: 
....................             c=USB_CONFIG_DESC[usb_getdesc_ptr]; 
1B52:  CLRF   03
1B54:  MOVF   2C,W
1B56:  MOVFF  FF2,1B4
1B5A:  BCF    FF2.7
1B5C:  RCALL  1950
1B5E:  MOVLB  1
1B60:  BTFSC  xB4.7
1B62:  BSF    FF2.7
1B64:  MOVWF  xB3
....................             break; 
1B66:  MOVLB  0
1B68:  BRA    1B9A
....................  
....................         #IF USB_HID_DEVICE 
....................          case USB_GETDESC_HIDREPORT_TYPE: 
....................             c=USB_CLASS_SPECIFIC_DESC[usb_getdesc_ptr]; 
....................             break; 
....................         #endif 
....................  
....................          case USB_GETDESC_STRING_TYPE: 
....................             c=USB_STRING_DESC[usb_getdesc_ptr]; 
1B6A:  CLRF   03
1B6C:  MOVF   2C,W
1B6E:  MOVFF  FF2,1B4
1B72:  BCF    FF2.7
1B74:  RCALL  19D8
1B76:  MOVLB  1
1B78:  BTFSC  xB4.7
1B7A:  BSF    FF2.7
1B7C:  MOVWF  xB3
....................             break; 
1B7E:  MOVLB  0
1B80:  BRA    1B9A
....................  
....................          case USB_GETDESC_DEVICE_TYPE: 
....................             c=USB_DEVICE_DESC[usb_getdesc_ptr]; 
1B82:  CLRF   03
1B84:  MOVF   2C,W
1B86:  MOVFF  FF2,1B4
1B8A:  BCF    FF2.7
1B8C:  RCALL  19B6
1B8E:  MOVLB  1
1B90:  BTFSC  xB4.7
1B92:  BSF    FF2.7
1B94:  MOVWF  xB3
....................             break; 
1B96:  MOVLB  0
1B98:  BRA    1B9A
....................       } 
....................       usb_getdesc_ptr++; 
1B9A:  INCF   2C,F
....................       usb_getdesc_len--; 
1B9C:  DECF   2D,F
....................       usb_ep0_tx_buffer[i++]=c; 
1B9E:  MOVLB  1
1BA0:  MOVF   xB2,W
1BA2:  INCF   xB2,F
1BA4:  CLRF   03
1BA6:  ADDLW  40
1BA8:  MOVWF  FE9
1BAA:  MOVLW  05
1BAC:  ADDWFC 03,W
1BAE:  MOVWF  FEA
1BB0:  MOVFF  1B3,FEF
....................    } 
1BB4:  BRA    1B38
....................  
....................    if ((!usb_getdesc_len)&&(i!=USB_MAX_EP0_PACKET_LENGTH)) { 
1BB6:  MOVF   2D,F
1BB8:  BNZ   1BC2
1BBA:  MOVF   xB2,W
1BBC:  SUBLW  40
1BBE:  BZ    1BC2
....................          USB_stack_status.dev_req = NONE; 
1BC0:  CLRF   1F
....................    } 
....................  
....................    usb_request_send_response(i); 
1BC2:  MOVFF  1B2,1B4
1BC6:  MOVLB  0
1BC8:  RCALL  1B28
.................... } 
1BCA:  RETLW  00
....................  
.................... #ENDIF 
....................  
....................  
.................... struct { 
....................         int32   dwDTERrate;   //data terminal rate, in bits per second 
....................         int8    bCharFormat;  //num of stop bits (0=1, 1=1.5, 2=2) 
....................         int8    bParityType;  //parity (0=none, 1=odd, 2=even, 3=mark, 4=space) 
....................         int8    bDataBits;    //data bits (5,6,7,8 or 16) 
.................... } usb_cdc_line_coding; 
....................  
.................... //length of time, in ms, of break signal as we received in a SendBreak message. 
.................... //if ==0xFFFF, send break signal until we receive a 0x0000. 
.................... int16 usb_cdc_break; 
....................  
.................... int8 usb_cdc_encapsulated_cmd[8]; 
....................  
.................... int8 usb_cdc_put_buffer[USB_CDC_DATA_IN_SIZE]; 
.................... int1 usb_cdc_put_buffer_free; 
.................... #if USB_CDC_DATA_IN_SIZE>=0x100 
....................  int16 usb_cdc_put_buffer_nextin=0; 
.................... // int16 usb_cdc_last_data_packet_size; 
.................... #else 
....................  int8 usb_cdc_put_buffer_nextin=0; 
.................... // int8 usb_cdc_last_data_packet_size; 
.................... #endif 
....................  
.................... struct { 
....................    int1 got; 
....................   #if USB_CDC_DATA_OUT_SIZE>=0x100 
....................    int16 len; 
....................    int16 index; 
....................   #else 
....................    int8 len; 
....................    int8 index; 
....................   #endif 
.................... } usb_cdc_get_buffer_status; 
....................  
.................... int8 usb_cdc_get_buffer_status_buffer[USB_CDC_DATA_OUT_SIZE]; 
.................... #if (defined(__PIC__)) 
....................  #if __PIC__ 
....................   //#locate usb_cdc_get_buffer_status_buffer=0x500+(2*USB_MAX_EP0_PACKET_LENGTH)+USB_CDC_COMM_IN_SIZE 
....................   #if USB_MAX_EP0_PACKET_LENGTH==8 
....................      #locate usb_cdc_get_buffer_status_buffer=0x500+24 
....................   #elif USB_MAX_EP0_PACKET_LENGTH==64 
....................      #locate usb_cdc_get_buffer_status_buffer=0x500+136 
....................   #else 
....................    #error CCS BUG WONT LET ME USE MATH IN LOCATE 
....................   #endif 
....................  #endif 
.................... #endif 
....................  
.................... int1 usb_cdc_got_set_line_coding; 
....................  
.................... struct  { 
....................    int1 dte_present; //1=DTE present, 0=DTE not present 
....................    int1 active;      //1=activate carrier, 0=deactivate carrier 
....................    int reserved:6; 
.................... } usb_cdc_carrier; 
....................  
.................... enum {USB_CDC_OUT_NOTHING=0, USB_CDC_OUT_COMMAND=1, USB_CDC_OUT_LINECODING=2, USB_CDC_WAIT_0LEN=3} __usb_cdc_state=0; 
....................  
.................... #byte INTCON=0xFF2 
.................... #bit INT_GIE=INTCON.7 
....................  
.................... //handle OUT token done interrupt on endpoint 0 [read encapsulated cmd and line coding data] 
.................... void usb_isr_tok_out_cdc_control_dne(void) { 
....................    debug_usb(debug_putc,"CDC %X ",__usb_cdc_state); 
....................  
....................    switch (__usb_cdc_state) { 
*
23AC:  MOVF   x87,W
23AE:  XORLW  01
23B0:  BZ    23B8
23B2:  XORLW  03
23B4:  BZ    23DE
23B6:  BRA    2404
....................       //printf(putc_tbe,"@%X@\r\n", __usb_cdc_state); 
....................       case USB_CDC_OUT_COMMAND: 
....................          //usb_get_packet(0, usb_cdc_encapsulated_cmd, 8); 
....................          memcpy(usb_cdc_encapsulated_cmd, usb_ep0_rx_buffer,8); 
23B8:  CLRF   FEA
23BA:  MOVLW  39
23BC:  MOVWF  FE9
23BE:  MOVLW  05
23C0:  MOVWF  FE2
23C2:  CLRF   FE1
23C4:  MOVLW  08
23C6:  MOVWF  01
23C8:  MOVFF  FE6,FEE
23CC:  DECFSZ 01,F
23CE:  BRA    23C8
....................         #if USB_MAX_EP0_PACKET_LENGTH==8 
....................          __usb_cdc_state=USB_CDC_WAIT_0LEN; 
....................          usb_request_get_data(); 
....................         #else 
....................          usb_put_0len_0(); 
23D0:  MOVLB  1
23D2:  CLRF   xB4
23D4:  MOVLB  0
23D6:  CALL   1B28
....................          __usb_cdc_state=0; 
23DA:  CLRF   x87
....................         #endif 
....................          break; 
23DC:  BRA    240C
....................  
....................     #if USB_MAX_EP0_PACKET_LENGTH==8 
....................       case USB_CDC_WAIT_0LEN: 
....................          usb_put_0len_0(); 
....................          __usb_cdc_state=0; 
....................          break; 
....................     #endif 
....................  
....................       case USB_CDC_OUT_LINECODING: 
....................          //usb_get_packet(0, &usb_cdc_line_coding, 7); 
....................          //printf(putc_tbe,"\r\n!GSLC FIN!\r\n"); 
....................          memcpy(&usb_cdc_line_coding, usb_ep0_rx_buffer,7); 
23DE:  CLRF   FEA
23E0:  MOVLW  30
23E2:  MOVWF  FE9
23E4:  MOVLW  05
23E6:  MOVWF  FE2
23E8:  CLRF   FE1
23EA:  MOVLW  07
23EC:  MOVWF  01
23EE:  MOVFF  FE6,FEE
23F2:  DECFSZ 01,F
23F4:  BRA    23EE
....................          __usb_cdc_state=0; 
23F6:  CLRF   x87
....................          usb_put_0len_0(); 
23F8:  MOVLB  1
23FA:  CLRF   xB4
23FC:  MOVLB  0
23FE:  CALL   1B28
....................          break; 
2402:  BRA    240C
....................  
....................       default: 
....................          __usb_cdc_state=0; 
2404:  CLRF   x87
....................          usb_init_ep0_setup(); 
2406:  CALL   1AC2
....................          break; 
240A:  BRA    240C
....................    } 
.................... } 
240C:  GOTO   245C (RETURN)
....................  
.................... //handle IN token on 0 (setup packet) 
.................... void usb_isr_tkn_cdc(void) { 
....................    //make sure the request goes to a CDC interface 
....................    if ((usb_ep0_rx_buffer[4] == 1) || (usb_ep0_rx_buffer[4] == 0)) { 
*
2104:  MOVLB  5
2106:  DECFSZ x04,W
2108:  BRA    210C
210A:  BRA    2110
210C:  MOVF   x04,F
210E:  BNZ   21AC
....................       //printf(putc_tbe,"!%X!\r\n", usb_ep0_rx_buffer[1]); 
....................       switch(usb_ep0_rx_buffer[1]) { 
2110:  MOVF   x01,W
2112:  MOVLB  0
2114:  BZ    212C
2116:  XORLW  01
2118:  BZ    2134
211A:  XORLW  21
211C:  BZ    2156
211E:  XORLW  01
2120:  BZ    2160
2122:  XORLW  03
2124:  BZ    2186
2126:  XORLW  01
2128:  BZ    2194
212A:  BRA    21A6
....................          case 0x00:  //send_encapsulated_command 
....................             __usb_cdc_state=USB_CDC_OUT_COMMAND; 
212C:  MOVLW  01
212E:  MOVWF  x87
....................             usb_request_get_data(); 
2130:  RCALL  20FE
....................             break; 
2132:  BRA    21AA
....................  
....................          case 0x01:  //get_encapsulated_command 
....................             memcpy(usb_ep0_tx_buffer, usb_cdc_encapsulated_cmd, 8); 
2134:  MOVLW  05
2136:  MOVWF  FEA
2138:  MOVLW  40
213A:  MOVWF  FE9
213C:  CLRF   FE2
213E:  MOVLW  39
2140:  MOVWF  FE1
2142:  MOVLW  08
2144:  MOVWF  01
2146:  MOVFF  FE6,FEE
214A:  DECFSZ 01,F
214C:  BRA    2146
....................             usb_request_send_response(usb_ep0_rx_buffer[6]);  //send wLength bytes 
214E:  MOVFF  506,1B4
2152:  RCALL  1B28
....................             break; 
2154:  BRA    21AA
....................  
....................          case 0x20:  //set_line_coding 
....................             debug_usb(debug_putc,"!GSLC!"); 
....................             __usb_cdc_state=USB_CDC_OUT_LINECODING; 
2156:  MOVLW  02
2158:  MOVWF  x87
....................             usb_cdc_got_set_line_coding=TRUE; 
215A:  BSF    x81.1
....................             usb_request_get_data(); 
215C:  RCALL  20FE
....................             break; 
215E:  BRA    21AA
....................  
....................          case 0x21:  //get_line_coding 
....................             memcpy(usb_ep0_tx_buffer, &usb_cdc_line_coding, sizeof(usb_cdc_line_coding)); 
2160:  MOVLW  05
2162:  MOVWF  FEA
2164:  MOVLW  40
2166:  MOVWF  FE9
2168:  CLRF   FE2
216A:  MOVLW  30
216C:  MOVWF  FE1
216E:  MOVLW  07
2170:  MOVWF  01
2172:  MOVFF  FE6,FEE
2176:  DECFSZ 01,F
2178:  BRA    2172
....................             usb_request_send_response(sizeof(usb_cdc_line_coding)); //send wLength bytes 
217A:  MOVLW  07
217C:  MOVLB  1
217E:  MOVWF  xB4
2180:  MOVLB  0
2182:  RCALL  1B28
....................             break; 
2184:  BRA    21AA
....................  
....................          case 0x22:  //set_control_line_state 
....................             usb_cdc_carrier=usb_ep0_rx_buffer[2]; 
2186:  MOVFF  502,86
....................             usb_put_0len_0(); 
218A:  MOVLB  1
218C:  CLRF   xB4
218E:  MOVLB  0
2190:  RCALL  1B28
....................             break; 
2192:  BRA    21AA
....................  
....................          case 0x23:  //send_break 
....................             usb_cdc_break=make16(usb_ep0_rx_buffer[2],usb_ep0_rx_buffer[3]); 
2194:  MOVFF  502,38
2198:  MOVFF  503,37
....................             usb_put_0len_0(); 
219C:  MOVLB  1
219E:  CLRF   xB4
21A0:  MOVLB  0
21A2:  RCALL  1B28
....................             break; 
21A4:  BRA    21AA
....................  
....................          default: 
....................             usb_request_stall(); 
21A6:  RCALL  1B2E
....................             break; 
21A8:  BRA    21AA
21AA:  MOVLB  5
....................       } 
....................    } 
.................... } 
21AC:  MOVLB  0
21AE:  GOTO   21D8 (RETURN)
....................  
.................... //handle OUT token done interrupt on endpoint 3 [buffer incoming received chars] 
.................... void usb_isr_tok_out_cdc_data_dne(void) { 
....................    usb_cdc_get_buffer_status.got=TRUE; 
*
243C:  BSF    x83.0
....................    usb_cdc_get_buffer_status.index=0; 
243E:  CLRF   x85
.................... #if (defined(__PIC__)) 
....................    #if __PIC__ 
....................     usb_cdc_get_buffer_status.len=usb_rx_packet_size(USB_CDC_DATA_OUT_ENDPOINT); 
2440:  MOVLW  02
2442:  MOVLB  1
2444:  MOVWF  xB2
2446:  MOVLB  0
2448:  BRA    2410
244A:  MOVFF  01,84
....................    #else 
....................     usb_cdc_get_buffer_status.len=usb_get_packet_buffer( 
....................        USB_CDC_DATA_OUT_ENDPOINT,&usb_cdc_get_buffer_status_buffer[0],USB_CDC_DATA_OUT_SIZE); 
....................    #endif 
.................... #else 
....................    usb_cdc_get_buffer_status.len=usb_get_packet_buffer( 
....................       USB_CDC_DATA_OUT_ENDPOINT,&usb_cdc_get_buffer_status_buffer[0],USB_CDC_DATA_OUT_SIZE); 
.................... #endif 
.................... } 
244E:  GOTO   246A (RETURN)
....................  
.................... //handle IN token done interrupt on endpoint 2 [transmit buffered characters] 
.................... void usb_isr_tok_in_cdc_data_dne(void) { 
....................    if (usb_cdc_put_buffer_nextin) { 
*
258A:  MOVF   x82,F
258C:  BZ    2592
....................       usb_cdc_flush_out_buffer(); 
258E:  RCALL  2566
....................    } 
....................    //send a 0len packet if needed 
.................... //   else if (usb_cdc_last_data_packet_size==USB_CDC_DATA_IN_SIZE) { 
.................... //      usb_cdc_last_data_packet_size=0; 
.................... //      printf(putc_tbe, "FL 0\r\n"); 
.................... //      usb_put_packet(USB_CDC_DATA_IN_ENDPOINT,0,0,USB_DTS_TOGGLE); 
.................... //   } 
....................    else { 
2590:  BRA    2594
....................       usb_cdc_put_buffer_free=TRUE; 
2592:  BSF    x81.0
....................       //printf(putc_tbe, "FL DONE\r\n"); 
....................    } 
.................... } 
2594:  GOTO   25C4 (RETURN)
....................  
.................... void usb_cdc_flush_out_buffer(void) { 
....................    if (usb_cdc_put_buffer_nextin) { 
*
2566:  MOVF   x82,F
2568:  BZ    2588
....................       usb_cdc_put_buffer_free=FALSE; 
256A:  BCF    x81.0
....................       //usb_cdc_last_data_packet_size=usb_cdc_put_buffer_nextin; 
....................       //printf(putc_tbe, "FL %U\r\n", usb_cdc_put_buffer_nextin); 
....................       usb_put_packet(USB_CDC_DATA_IN_ENDPOINT,usb_cdc_put_buffer,usb_cdc_put_buffer_nextin,USB_DTS_TOGGLE); 
256C:  MOVLW  02
256E:  MOVLB  1
2570:  MOVWF  xB2
2572:  CLRF   xB4
2574:  MOVLW  41
2576:  MOVWF  xB3
2578:  CLRF   xB6
257A:  MOVFF  82,1B5
257E:  MOVLW  02
2580:  MOVWF  xB7
2582:  MOVLB  0
2584:  RCALL  24B8
....................       usb_cdc_put_buffer_nextin=0; 
2586:  CLRF   x82
....................    } 
.................... } 
2588:  RETLW  00
....................  
.................... void usb_cdc_init(void) { 
....................    usb_cdc_line_coding.dwDTERrate=9600; 
*
1A42:  CLRF   33
1A44:  CLRF   32
1A46:  MOVLW  25
1A48:  MOVWF  31
1A4A:  MOVLW  80
1A4C:  MOVWF  30
....................    usb_cdc_line_coding.bCharFormat=0; 
1A4E:  CLRF   34
....................    usb_cdc_line_coding.bParityType=0; 
1A50:  CLRF   35
....................    usb_cdc_line_coding.bDataBits=8; 
1A52:  MOVLW  08
1A54:  MOVWF  36
....................    (int8)usb_cdc_carrier=0; 
1A56:  CLRF   x86
....................    usb_cdc_got_set_line_coding=FALSE; 
1A58:  BCF    x81.1
....................    usb_cdc_break=0; 
1A5A:  CLRF   38
1A5C:  CLRF   37
....................    usb_cdc_put_buffer_nextin=0; 
1A5E:  CLRF   x82
....................    usb_cdc_get_buffer_status.got=0; 
1A60:  BCF    x83.0
....................    usb_cdc_put_buffer_free=TRUE; 
1A62:  BSF    x81.0
.................... } 
1A64:  RETLW  00
....................  
.................... ////////////////// END USB CONTROL HANDLING ////////////////////////////////// 
....................  
.................... ////////////////// BEGIN USB<->RS232 CDC LIBRARY ///////////////////////////// 
....................  
.................... char usb_cdc_getc(void) { 
....................    char c; 
....................  
....................    while (!usb_cdc_kbhit()) {} 
*
2B98:  BTFSC  x83.0
2B9A:  BRA    2B9E
2B9C:  BRA    2B98
....................  
....................    c=usb_cdc_get_buffer_status_buffer[usb_cdc_get_buffer_status.index++]; 
2B9E:  MOVF   x85,W
2BA0:  INCF   x85,F
2BA2:  CLRF   03
2BA4:  ADDLW  88
2BA6:  MOVWF  FE9
2BA8:  MOVLW  05
2BAA:  ADDWFC 03,W
2BAC:  MOVWF  FEA
2BAE:  MOVFF  FEF,1A0
2BB2:  MOVLB  1
....................    if (usb_cdc_get_buffer_status.index >= usb_cdc_get_buffer_status.len) { 
2BB4:  MOVLB  0
2BB6:  MOVF   x84,W
2BB8:  SUBWF  x85,W
2BBA:  BNC   2BD8
....................       usb_cdc_get_buffer_status.got=FALSE; 
2BBC:  BCF    x83.0
2BBE:  CLRF   18
2BC0:  BTFSC  FF2.7
2BC2:  BSF    18.7
2BC4:  BCF    FF2.7
....................       usb_flush_out(USB_CDC_DATA_OUT_ENDPOINT, USB_DTS_TOGGLE); 
2BC6:  MOVLW  02
2BC8:  MOVLB  1
2BCA:  MOVWF  xB1
2BCC:  MOVWF  xB2
2BCE:  MOVLB  0
2BD0:  CALL   21DC
2BD4:  BTFSC  18.7
2BD6:  BSF    FF2.7
....................    } 
....................  
....................    return(c); 
2BD8:  MOVLB  1
2BDA:  MOVFF  1A0,01
.................... } 
2BDE:  MOVLB  0
2BE0:  GOTO   2BEE (RETURN)
....................  
.................... void usb_cdc_putc_fast(char c) { 
....................    int1 old_gie; 
....................  
....................    //disable global interrupts 
....................    old_gie=INT_GIE; 
*
3088:  MOVLB  1
308A:  BCF    x9D.0
308C:  BTFSC  FF2.7
308E:  BSF    x9D.0
....................    INT_GIE=0; 
3090:  BCF    FF2.7
....................  
....................    if (usb_cdc_put_buffer_nextin >= USB_CDC_DATA_IN_SIZE) { 
3092:  MOVLB  0
3094:  MOVF   x82,W
3096:  SUBLW  3F
3098:  BC    309E
....................       usb_cdc_put_buffer_nextin=USB_CDC_DATA_IN_SIZE-1;  //we just overflowed the buffer! 
309A:  MOVLW  3F
309C:  MOVWF  x82
....................    } 
....................    usb_cdc_put_buffer[usb_cdc_put_buffer_nextin++]=c; 
309E:  MOVF   x82,W
30A0:  INCF   x82,F
30A2:  CLRF   03
30A4:  ADDLW  41
30A6:  MOVWF  FE9
30A8:  MOVLW  00
30AA:  ADDWFC 03,W
30AC:  MOVWF  FEA
30AE:  MOVFF  19C,FEF
....................  
....................    //renable global interrupts 
....................    INT_GIE=old_gie; 
30B2:  BCF    FF2.7
30B4:  MOVLB  1
30B6:  BTFSC  x9D.0
30B8:  BSF    FF2.7
....................  
....................    /* 
....................    if (usb_tbe(USB_CDC_DATA_IN_ENDPOINT)) { 
....................       if (usb_cdc_put_buffer_nextin) 
....................          usb_cdc_flush_out_buffer(); 
....................    } 
....................    */ 
....................    if (usb_cdc_put_buffer_free) { 
30BA:  MOVLB  0
30BC:  BTFSS  x81.0
30BE:  BRA    30D0
30C0:  CLRF   18
30C2:  BTFSC  FF2.7
30C4:  BSF    18.7
30C6:  BCF    FF2.7
....................       usb_cdc_flush_out_buffer(); 
30C8:  CALL   2566
30CC:  BTFSC  18.7
30CE:  BSF    FF2.7
....................    } 
.................... } 
30D0:  GOTO   30F6 (RETURN)
....................  
.................... void usb_cdc_putc(char c) { 
....................    while (!usb_cdc_putready()) { 
30D4:  MOVF   x82,W
30D6:  SUBLW  3F
30D8:  BC    30F0
....................       if (usb_cdc_put_buffer_free) { 
30DA:  BTFSS  x81.0
30DC:  BRA    30EE
30DE:  CLRF   18
30E0:  BTFSC  FF2.7
30E2:  BSF    18.7
30E4:  BCF    FF2.7
....................          usb_cdc_flush_out_buffer(); 
30E6:  CALL   2566
30EA:  BTFSC  18.7
30EC:  BSF    FF2.7
....................       } 
....................       //delay_ms(500); 
....................       //printf(putc_tbe,"TBE=%U CNT=%U LST=%U\r\n",usb_tbe(USB_CDC_DATA_IN_ENDPOINT), usb_cdc_put_buffer_nextin, usb_cdc_last_data_packet_size); 
....................    } 
30EE:  BRA    30D4
....................    usb_cdc_putc_fast(c); 
30F0:  MOVFF  19B,19C
30F4:  BRA    3088
.................... } 
30F6:  RETLW  00
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
.................... BYTE gethex1_usb() { 
....................    char digit; 
....................  
....................    digit = usb_cdc_getc(); 
....................  
....................    usb_cdc_putc(digit); 
....................  
....................    if(digit<='9') 
....................      return(digit-'0'); 
....................    else 
....................      return((toupper(digit)-'A')+10); 
.................... } 
....................  
.................... BYTE gethex_usb() { 
....................    int lo,hi; 
....................  
....................    hi = gethex1_usb(); 
....................    lo = gethex1_usb(); 
....................    if(lo==0xdd) 
....................      return(hi); 
....................    else 
....................      return( hi*16+lo ); 
.................... } 
....................  
.................... void get_string_usb(char* s, int max) { 
....................    int len; 
....................    char c; 
....................  
....................    --max; 
....................    len=0; 
....................    do { 
....................      c=usb_cdc_getc(); 
....................      if(c==8) {  // Backspace 
....................         if(len>0) { 
....................           len--; 
....................         } 
....................      } else if ((c>=' ')&&(c<='~')) 
....................        if(len<max) { 
....................          s[len++]=c; 
....................        } 
....................    } while(c!=13); 
....................    s[len]=0; 
.................... } 
....................  
....................  
.................... // stdlib.h is required for the ato_ conversions 
.................... // in the following functions 
.................... #ifdef _STDLIB 
....................  
.................... signed int get_int_usb() { 
....................   char s[5]; 
....................   signed int i; 
....................  
....................   get_string_usb(s, 5); 
....................  
....................   i=atoi(s); 
....................   return(i); 
.................... } 
....................  
.................... signed long get_long_usb() { 
....................   char s[7]; 
....................   signed long l; 
....................  
....................   get_string_usb(s, 7); 
....................   l=atol(s); 
....................   return(l); 
.................... } 
....................  
.................... float get_float_usb() { 
....................   char s[20]; 
....................   float f; 
....................  
....................   get_string_usb(s, 20); 
....................   f = atof(s); 
....................   return(f); 
.................... } 
....................  
.................... #endif 
....................  
....................  
.................... //TC74HC164 Setting 
.................... #define SR_CLK PIN_B6 
.................... #define SR_A   PIN_B7 
....................  
.................... //TC74HC165 Setting 
.................... #define SR_SL   PIN_C1 
.................... #define SR_CLK2 PIN_C0 
.................... #define SR_QH   PIN_C6 
....................  
.................... //MAX7219CNG Setting 
.................... #if 1//sy 
.................... #define LDD_LOAD PIN_B5 
.................... #else//sy 
.................... #define LDD_LOAD PIN_C2 
.................... #endif//sy 
....................  
.................... void initLedDriver(void); 
.................... #ifndef ONE_TWENTY_EIGHT//for sixty four 
.................... void sendSpiLED(int msb, int lsb); 
.................... #else//for one twenty eight 
.................... //sy void sendSpiLED(int id, int msb, int lsb); 
.................... void sendSpiLED2(int msb0, int lsb0, int msb1, int lsb1); 
.................... #endif//sy 
....................  
.................... //sy int i, j, k; 
.................... int i, j; 
.................... char *ch; 
.................... short flag; 
.................... int x, y, state; 
.................... #ifdef ONE_TWENTY_EIGHT//for sixty four 
.................... int x1, y1; 
.................... int lsb0, lsb1; 
.................... #endif 
....................  
.................... //OSC Messages Receive Setting 
.................... #ifndef ONE_TWENTY_EIGHT//for sixty four 
.................... int led_data[8]; 
.................... #else//for one twenty eight 
.................... long led_data[8]; 
.................... #endif//sy 
.................... int firstRun = TRUE; 
....................  
.................... char string[15]; 
.................... char space[] = " "; 
....................  
.................... void receiveOscMsgs(void); 
....................  
.................... //Button Settings 
.................... int start_row = 0; 
.................... #ifndef ONE_TWENTY_EIGHT//for sixty four 
.................... int btnCurrent[8], btnLast[8], btnState[8], btnDebounceCount[8][8]; 
.................... #else//for one twenty eight 
.................... long btnCurrent[8], btnLast[8], btnState[8], btnDebounceCount[8][16]; 
.................... #endif//sy 
....................  
.................... void buttonInit(void); 
.................... short buttonCheck(int row, int index); 
.................... void sendOscMsgPress(void); 
....................  
....................  
.................... //A/D Conversion Settings 
.................... #define kAdcFilterNumAdcs 7 
.................... const int adc_id[] = {0, 1, 2, 3, 4, 8, 9}; 
....................  
.................... int gAdcEnableState = 0; 
.................... short enableAdcFlag = FALSE; 
.................... int countAdc = 0, loopAdc = 0, enableAdcNum = 0; 
.................... int countAve[7]; 
.................... long lvalue = 0; 
.................... long adc_total[7]; 
.................... long adc_value[7][8]; 
....................  
.................... void enableAdc(int port); 
.................... void disableAdc(int port); 
.................... void sendOscMsgAdc(void); 
....................  
.................... //Digital Input Settings 
.................... int inCurrent, inLast, inState, inDebounceCount[2]; 
....................  
.................... void inputInit(void); 
.................... short inputCheck(int index); 
.................... void sendOscMsgInput(void); 
....................  
.................... //EEPROM 
.................... struct{ 
....................   int intensity; 
.................... }para; 
....................  
.................... void initAndSaveParaToEeprom(void); 
.................... void getParaFromEeprom(int *ptr, int num, int addr); 
.................... void putParaToEeprom(int *ptr, int num, int addr); 
....................  
.................... int my_atoi(char s); 
.................... void my_get_string_usb(char* s, int max); 
....................  
....................  
.................... void main() 
.................... { 
*
3B90:  CLRF   FF8
3B92:  BCF    FD0.7
3B94:  BSF    08.7
3B96:  CLRF   FEA
3B98:  CLRF   FE9
3B9A:  MOVF   FC1,W
3B9C:  ANDLW  C0
3B9E:  IORLW  0F
3BA0:  MOVWF  FC1
3BA2:  MOVLW  07
3BA4:  MOVWF  FB4
3BA6:  CLRF   19
3BA8:  CLRF   1A
3BAA:  CLRF   26
3BAC:  CLRF   28
3BAE:  MOVLW  04
3BB0:  MOVWF  29
3BB2:  MOVLW  16
3BB4:  MOVWF  2A
3BB6:  CLRF   2D
3BB8:  CLRF   x82
3BBA:  CLRF   x87
3BBC:  MOVLW  01
3BBE:  MOVWF  x97
3BC0:  MOVLW  20
3BC2:  MOVWF  xA7
3BC4:  CLRF   xA8
3BC6:  CLRF   xA9
3BC8:  MOVLB  1
3BCA:  CLRF   x02
3BCC:  MOVLB  0
3BCE:  BCF    x81.3
3BD0:  MOVLB  1
3BD2:  CLRF   x03
3BD4:  CLRF   x04
3BD6:  CLRF   x05
3BD8:  CLRF   x0D
3BDA:  CLRF   x0E
....................   setup_adc_ports(AN0_TO_AN9 || VSS_VDD); 
3BDC:  MOVF   FC1,W
3BDE:  ANDLW  C0
3BE0:  IORLW  05
3BE2:  MOVWF  FC1
....................   setup_adc(ADC_CLOCK_DIV_64); 
3BE4:  BCF    FC0.0
3BE6:  BSF    FC0.1
3BE8:  BSF    FC0.2
3BEA:  BSF    FC0.7
3BEC:  BSF    FC2.0
....................   setup_spi(SPI_MASTER | SPI_L_TO_H | SPI_XMIT_L_TO_H | SPI_CLK_DIV_16); 
3BEE:  BCF    FC6.5
3BF0:  BCF    F94.7
3BF2:  BSF    F93.0
3BF4:  BCF    F93.1
3BF6:  MOVLW  21
3BF8:  MOVWF  FC6
3BFA:  MOVLW  40
3BFC:  MOVWF  FC7
....................   setup_wdt(WDT_OFF); 
3BFE:  BCF    FD1.0
....................   setup_timer_0(RTCC_INTERNAL); 
3C00:  MOVLW  80
3C02:  MOVWF  FD5
....................   setup_timer_1(T1_DISABLED); 
3C04:  CLRF   FCD
....................   //sy setup_timer_2(T2_DIV_BY_1, 255, 1);// for PWM 
....................   setup_timer_2(T2_DISABLED, 255, 1); 
3C06:  MOVLW  00
3C08:  MOVWF  FCA
3C0A:  MOVLW  FF
3C0C:  MOVWF  FCB
....................   setup_timer_3(T3_DISABLED|T3_DIV_BY_1); 
3C0E:  CLRF   FB1
....................   setup_comparator(NC_NC_NC_NC); 
3C10:  MOVLW  07
3C12:  MOVWF  FB4
3C14:  MOVF   F92,W
3C16:  MOVWF  F92
3C18:  MOVLW  27
3C1A:  MOVWF  00
3C1C:  DECFSZ 00,F
3C1E:  BRA    3C1C
3C20:  BRA    3C22
3C22:  MOVF   FB4,W
3C24:  BCF    FA1.6
....................   setup_vref(FALSE); 
3C26:  CLRF   FB5
....................   //sy setup_ccp1(CCP_PWM); 
....................   //sy set_pwm1_duty(0); 
....................   //Setup_Oscillator parameter not selected from Intr Oscillator Config tab 
....................  
....................   // Parameters Initialized 
....................   for(i = 0; i < 7; i++) 
3C28:  MOVLB  0
3C2A:  CLRF   x88
3C2C:  MOVF   x88,W
3C2E:  SUBLW  06
3C30:  BNC   3C9A
....................   { 
....................     countAve[i] = 0; 
3C32:  CLRF   03
3C34:  MOVF   x88,W
3C36:  ADDLW  06
3C38:  MOVWF  FE9
3C3A:  MOVLW  01
3C3C:  ADDWFC 03,W
3C3E:  MOVWF  FEA
3C40:  CLRF   FEF
....................     adc_total[i] = 0; 
3C42:  BCF    FD8.0
3C44:  RLCF   x88,W
3C46:  CLRF   03
3C48:  ADDLW  0F
3C4A:  MOVWF  FE9
3C4C:  MOVLW  01
3C4E:  ADDWFC 03,W
3C50:  MOVWF  FEA
3C52:  CLRF   FEC
3C54:  MOVF   FED,F
3C56:  CLRF   FEF
....................     for(j = 0; j < 8; j++) 
3C58:  CLRF   x89
3C5A:  MOVF   x89,W
3C5C:  SUBLW  07
3C5E:  BNC   3C96
....................       adc_value[i][j] = 0; 
3C60:  MOVF   x88,W
3C62:  MULLW  10
3C64:  MOVF   FF3,W
3C66:  MOVLB  1
3C68:  CLRF   x94
3C6A:  MOVWF  x93
3C6C:  BCF    FD8.0
3C6E:  MOVLB  0
3C70:  RLCF   x89,W
3C72:  CLRF   03
3C74:  MOVLB  1
3C76:  ADDWF  x93,W
3C78:  MOVWF  01
3C7A:  MOVF   x94,W
3C7C:  ADDWFC 03,F
3C7E:  MOVF   01,W
3C80:  ADDLW  1D
3C82:  MOVWF  FE9
3C84:  MOVLW  01
3C86:  ADDWFC 03,W
3C88:  MOVWF  FEA
3C8A:  CLRF   FEC
3C8C:  MOVF   FED,F
3C8E:  CLRF   FEF
3C90:  MOVLB  0
3C92:  INCF   x89,F
3C94:  BRA    3C5A
....................   } 
3C96:  INCF   x88,F
3C98:  BRA    3C2C
....................  
....................   getParaFromEeprom(&para, sizeof(para), 0); 
3C9A:  MOVLW  01
3C9C:  MOVLB  1
3C9E:  MOVWF  x94
3CA0:  MOVLW  92
3CA2:  MOVWF  x93
3CA4:  MOVLW  01
3CA6:  MOVWF  x95
3CA8:  CLRF   x96
3CAA:  MOVLB  0
3CAC:  GOTO   2724
....................   if(!(para.intensity > 0)) 
3CB0:  MOVLB  1
3CB2:  MOVF   x92,F
3CB4:  BNZ   3CBC
....................     initAndSaveParaToEeprom(); 
3CB6:  MOVLB  0
3CB8:  GOTO   27BA
....................  
....................   // Button Initialized 
....................   buttonInit(); 
3CBC:  MOVLB  0
3CBE:  GOTO   27D6
....................  
....................   output_bit(SR_A, 1); 
3CC2:  BSF    F8A.7
3CC4:  BCF    F93.7
....................   for(i = 0; i < 8; i++) 
3CC6:  CLRF   x88
3CC8:  MOVF   x88,W
3CCA:  SUBLW  07
3CCC:  BNC   3CEA
....................   { 
....................     led_data[i] = 0; 
3CCE:  CLRF   03
3CD0:  MOVF   x88,W
3CD2:  ADDLW  8F
3CD4:  MOVWF  FE9
3CD6:  MOVLW  00
3CD8:  ADDWFC 03,W
3CDA:  MOVWF  FEA
3CDC:  CLRF   FEF
....................     output_bit(SR_CLK, 1); 
3CDE:  BSF    F8A.6
3CE0:  BCF    F93.6
....................     output_bit(SR_CLK, 0); 
3CE2:  BCF    F8A.6
3CE4:  BCF    F93.6
....................   } 
3CE6:  INCF   x88,F
3CE8:  BRA    3CC8
....................  
....................   // Input Initialized 
....................   inputInit(); 
3CEA:  GOTO   284E
....................  
....................   // MAX7219 Initialized 
....................   initLedDriver(); 
3CEE:  GOTO   28C2
....................  
....................   // USB CDC Class Initialized 
....................   usb_cdc_init(); 
3CF2:  CALL   1A42
....................   usb_init(); 
3CF6:  GOTO   2B8A
....................   while(!usb_cdc_connected()){} 
3CFA:  BTFSC  x81.1
3CFC:  BRA    3D00
3CFE:  BRA    3CFA
....................  
....................   while(TRUE) 
....................   { 
....................     usb_task(); 
3D00:  CALL   2B68
....................     if(usb_enumerated()) 
3D04:  MOVF   20,F
3D06:  BZ    3D10
....................     { 
....................       receiveOscMsgs(); 
3D08:  GOTO   30F8
....................  
....................       // Button Handling 
....................       sendOscMsgPress(); 
3D0C:  BRA    37F4
....................  
....................       // Digital Input Handling 
....................       //sy sendOscMsgInput(); 
....................  
....................       // Adc Handling 
....................       sendOscMsgAdc(); 
3D0E:  BRA    3974
....................     } 
....................   } 
3D10:  BRA    3D00
.................... } 
....................  
.................... /***********************************/ 
.................... /*                                 */ 
.................... /*    Functions for Max7219CNG     */ 
.................... /*                                 */ 
.................... /***********************************/ 
.................... #ifndef ONE_TWENTY_EIGHT//for sixty four 
.................... void initLedDriver(void) 
.................... { 
3D12:  SLEEP 
....................   sendSpiLED(0x0B, 0x07);           // Scan Limit full range 
*
28C2:  MOVLW  0B
28C4:  MOVLB  1
28C6:  MOVWF  x9D
28C8:  MOVLW  07
28CA:  MOVWF  x9E
28CC:  MOVLB  0
28CE:  RCALL  2878
....................   sendSpiLED(0x0C, 0x01);           // Shutdown Normal Operation 
28D0:  MOVLW  0C
28D2:  MOVLB  1
28D4:  MOVWF  x9D
28D6:  MOVLW  01
28D8:  MOVWF  x9E
28DA:  MOVLB  0
28DC:  RCALL  2878
....................   sendSpiLED(0x0F, 0x00);           // Display Test Off 
28DE:  MOVLW  0F
28E0:  MOVLB  1
28E2:  MOVWF  x9D
28E4:  CLRF   x9E
28E6:  MOVLB  0
28E8:  RCALL  2878
....................  
....................   // print startup pattern  
....................   sendSpiLED(0x0A, 0x0F); // Max Intensity 0x00[min] - 0x0F[max] 
28EA:  MOVLW  0A
28EC:  MOVLB  1
28EE:  MOVWF  x9D
28F0:  MOVLW  0F
28F2:  MOVWF  x9E
28F4:  MOVLB  0
28F6:  RCALL  2878
....................   sendSpiLED(1, 0); 
28F8:  MOVLW  01
28FA:  MOVLB  1
28FC:  MOVWF  x9D
28FE:  CLRF   x9E
2900:  MOVLB  0
2902:  RCALL  2878
....................   sendSpiLED(2, 0); 
2904:  MOVLW  02
2906:  MOVLB  1
2908:  MOVWF  x9D
290A:  CLRF   x9E
290C:  MOVLB  0
290E:  RCALL  2878
....................   sendSpiLED(3, 0); 
2910:  MOVLW  03
2912:  MOVLB  1
2914:  MOVWF  x9D
2916:  CLRF   x9E
2918:  MOVLB  0
291A:  RCALL  2878
....................   sendSpiLED(4, 24); 
291C:  MOVLW  04
291E:  MOVLB  1
2920:  MOVWF  x9D
2922:  MOVLW  18
2924:  MOVWF  x9E
2926:  MOVLB  0
2928:  RCALL  2878
....................   sendSpiLED(5, 24); 
292A:  MOVLW  05
292C:  MOVLB  1
292E:  MOVWF  x9D
2930:  MOVLW  18
2932:  MOVWF  x9E
2934:  MOVLB  0
2936:  RCALL  2878
....................   sendSpiLED(6, 0); 
2938:  MOVLW  06
293A:  MOVLB  1
293C:  MOVWF  x9D
293E:  CLRF   x9E
2940:  MOVLB  0
2942:  RCALL  2878
....................   sendSpiLED(7, 0); 
2944:  MOVLW  07
2946:  MOVLB  1
2948:  MOVWF  x9D
294A:  CLRF   x9E
294C:  MOVLB  0
294E:  RCALL  2878
....................   sendSpiLED(8, 0); 
2950:  MOVLW  08
2952:  MOVLB  1
2954:  MOVWF  x9D
2956:  CLRF   x9E
2958:  MOVLB  0
295A:  RCALL  2878
....................   for(i = 0; i < 64; i++) 
295C:  CLRF   x88
295E:  MOVF   x88,W
2960:  SUBLW  3F
2962:  BNC   2992
....................   { 
....................     sendSpiLED(0x0A, (64 - i) / 4);   // set to max intensity 
2964:  MOVLW  40
2966:  BSF    FD8.0
2968:  SUBFWB x88,W
296A:  MOVWF  00
296C:  RRCF   00,W
296E:  MOVLB  1
2970:  MOVWF  x93
2972:  RRCF   x93,F
2974:  MOVLW  3F
2976:  ANDWF  x93,F
2978:  MOVLW  0A
297A:  MOVWF  x9D
297C:  MOVFF  193,19E
2980:  MOVLB  0
2982:  RCALL  2878
....................     delay_ms(4); 
2984:  MOVLW  04
2986:  MOVLB  1
2988:  MOVWF  x93
298A:  MOVLB  0
298C:  RCALL  2898
....................   } 
298E:  INCF   x88,F
2990:  BRA    295E
....................   sendSpiLED(0x0A, 0x0F); // Max Intensity 0x00[min] - 0x0F[max] 
2992:  MOVLW  0A
2994:  MOVLB  1
2996:  MOVWF  x9D
2998:  MOVLW  0F
299A:  MOVWF  x9E
299C:  MOVLB  0
299E:  RCALL  2878
....................   sendSpiLED(1, 0); 
29A0:  MOVLW  01
29A2:  MOVLB  1
29A4:  MOVWF  x9D
29A6:  CLRF   x9E
29A8:  MOVLB  0
29AA:  RCALL  2878
....................   sendSpiLED(2, 0); 
29AC:  MOVLW  02
29AE:  MOVLB  1
29B0:  MOVWF  x9D
29B2:  CLRF   x9E
29B4:  MOVLB  0
29B6:  RCALL  2878
....................   sendSpiLED(3, 24); 
29B8:  MOVLW  03
29BA:  MOVLB  1
29BC:  MOVWF  x9D
29BE:  MOVLW  18
29C0:  MOVWF  x9E
29C2:  MOVLB  0
29C4:  RCALL  2878
....................   sendSpiLED(4, 36); 
29C6:  MOVLW  04
29C8:  MOVLB  1
29CA:  MOVWF  x9D
29CC:  MOVLW  24
29CE:  MOVWF  x9E
29D0:  MOVLB  0
29D2:  RCALL  2878
....................   sendSpiLED(5, 36); 
29D4:  MOVLW  05
29D6:  MOVLB  1
29D8:  MOVWF  x9D
29DA:  MOVLW  24
29DC:  MOVWF  x9E
29DE:  MOVLB  0
29E0:  RCALL  2878
....................   sendSpiLED(6, 24); 
29E2:  MOVLW  06
29E4:  MOVLB  1
29E6:  MOVWF  x9D
29E8:  MOVLW  18
29EA:  MOVWF  x9E
29EC:  MOVLB  0
29EE:  RCALL  2878
....................   sendSpiLED(7, 0); 
29F0:  MOVLW  07
29F2:  MOVLB  1
29F4:  MOVWF  x9D
29F6:  CLRF   x9E
29F8:  MOVLB  0
29FA:  RCALL  2878
....................   sendSpiLED(8, 0); 
29FC:  MOVLW  08
29FE:  MOVLB  1
2A00:  MOVWF  x9D
2A02:  CLRF   x9E
2A04:  MOVLB  0
2A06:  RCALL  2878
....................   for(i = 0; i < 64; i++) 
2A08:  CLRF   x88
2A0A:  MOVF   x88,W
2A0C:  SUBLW  3F
2A0E:  BNC   2A3E
....................   { 
....................     sendSpiLED(0x0A, (64 - i) / 4);   // set to max intensity 
2A10:  MOVLW  40
2A12:  BSF    FD8.0
2A14:  SUBFWB x88,W
2A16:  MOVWF  00
2A18:  RRCF   00,W
2A1A:  MOVLB  1
2A1C:  MOVWF  x93
2A1E:  RRCF   x93,F
2A20:  MOVLW  3F
2A22:  ANDWF  x93,F
2A24:  MOVLW  0A
2A26:  MOVWF  x9D
2A28:  MOVFF  193,19E
2A2C:  MOVLB  0
2A2E:  RCALL  2878
....................     delay_ms(4); 
2A30:  MOVLW  04
2A32:  MOVLB  1
2A34:  MOVWF  x93
2A36:  MOVLB  0
2A38:  RCALL  2898
....................   } 
2A3A:  INCF   x88,F
2A3C:  BRA    2A0A
....................   sendSpiLED(0x0A, 0x0F); // Max Intensity 0x00[min] - 0x0F[max] 
2A3E:  MOVLW  0A
2A40:  MOVLB  1
2A42:  MOVWF  x9D
2A44:  MOVLW  0F
2A46:  MOVWF  x9E
2A48:  MOVLB  0
2A4A:  RCALL  2878
....................   sendSpiLED(1, 0); 
2A4C:  MOVLW  01
2A4E:  MOVLB  1
2A50:  MOVWF  x9D
2A52:  CLRF   x9E
2A54:  MOVLB  0
2A56:  RCALL  2878
....................   sendSpiLED(2, 24); 
2A58:  MOVLW  02
2A5A:  MOVLB  1
2A5C:  MOVWF  x9D
2A5E:  MOVLW  18
2A60:  MOVWF  x9E
2A62:  MOVLB  0
2A64:  RCALL  2878
....................   sendSpiLED(3, 36); 
2A66:  MOVLW  03
2A68:  MOVLB  1
2A6A:  MOVWF  x9D
2A6C:  MOVLW  24
2A6E:  MOVWF  x9E
2A70:  MOVLB  0
2A72:  RCALL  2878
....................   sendSpiLED(4, 66); 
2A74:  MOVLW  04
2A76:  MOVLB  1
2A78:  MOVWF  x9D
2A7A:  MOVLW  42
2A7C:  MOVWF  x9E
2A7E:  MOVLB  0
2A80:  RCALL  2878
....................   sendSpiLED(5, 66); 
2A82:  MOVLW  05
2A84:  MOVLB  1
2A86:  MOVWF  x9D
2A88:  MOVLW  42
2A8A:  MOVWF  x9E
2A8C:  MOVLB  0
2A8E:  RCALL  2878
....................   sendSpiLED(6, 36); 
2A90:  MOVLW  06
2A92:  MOVLB  1
2A94:  MOVWF  x9D
2A96:  MOVLW  24
2A98:  MOVWF  x9E
2A9A:  MOVLB  0
2A9C:  RCALL  2878
....................   sendSpiLED(7, 24); 
2A9E:  MOVLW  07
2AA0:  MOVLB  1
2AA2:  MOVWF  x9D
2AA4:  MOVLW  18
2AA6:  MOVWF  x9E
2AA8:  MOVLB  0
2AAA:  RCALL  2878
....................   sendSpiLED(8, 0); 
2AAC:  MOVLW  08
2AAE:  MOVLB  1
2AB0:  MOVWF  x9D
2AB2:  CLRF   x9E
2AB4:  MOVLB  0
2AB6:  RCALL  2878
....................   for(i = 0; i < 64; i++) 
2AB8:  CLRF   x88
2ABA:  MOVF   x88,W
2ABC:  SUBLW  3F
2ABE:  BNC   2AEE
....................   { 
....................     sendSpiLED(0x0A, (64 - i) / 4);   // set to max intensity 
2AC0:  MOVLW  40
2AC2:  BSF    FD8.0
2AC4:  SUBFWB x88,W
2AC6:  MOVWF  00
2AC8:  RRCF   00,W
2ACA:  MOVLB  1
2ACC:  MOVWF  x93
2ACE:  RRCF   x93,F
2AD0:  MOVLW  3F
2AD2:  ANDWF  x93,F
2AD4:  MOVLW  0A
2AD6:  MOVWF  x9D
2AD8:  MOVFF  193,19E
2ADC:  MOVLB  0
2ADE:  RCALL  2878
....................     delay_ms(4); 
2AE0:  MOVLW  04
2AE2:  MOVLB  1
2AE4:  MOVWF  x93
2AE6:  MOVLB  0
2AE8:  RCALL  2898
....................   } 
2AEA:  INCF   x88,F
2AEC:  BRA    2ABA
....................  
....................   sendSpiLED(0x0A, para.intensity); // Max Intensity 0x00[min] - 0x0F[max] 
2AEE:  MOVLW  0A
2AF0:  MOVLB  1
2AF2:  MOVWF  x9D
2AF4:  MOVFF  192,19E
2AF8:  MOVLB  0
2AFA:  RCALL  2878
....................   for(i = 1; i < 9; i++) 
2AFC:  MOVLW  01
2AFE:  MOVWF  x88
2B00:  MOVF   x88,W
2B02:  SUBLW  08
2B04:  BNC   2B16
....................     sendSpiLED(i, 0x00); 
2B06:  MOVFF  88,19D
2B0A:  MOVLB  1
2B0C:  CLRF   x9E
2B0E:  MOVLB  0
2B10:  RCALL  2878
2B12:  INCF   x88,F
2B14:  BRA    2B00
.................... } 
2B16:  GOTO   3CF2 (RETURN)
....................  
.................... void sendSpiLED(int msb, int lsb) 
.................... { 
....................   output_bit(LDD_LOAD, 0); 
*
2878:  BCF    F8A.5
287A:  BCF    F93.5
....................   spi_write(msb); 
287C:  MOVF   FC9,W
287E:  MOVFF  19D,FC9
2882:  RRCF   FC7,W
2884:  BNC   2882
....................   spi_write(lsb); 
2886:  MOVF   FC9,W
2888:  MOVFF  19E,FC9
288C:  RRCF   FC7,W
288E:  BNC   288C
....................   output_bit(LDD_LOAD, 1); 
2890:  BSF    F8A.5
2892:  BCF    F93.5
....................   delay_cycles(1); 
2894:  NOP   
.................... } 
2896:  RETLW  00
.................... #else//for one twenty eight 
.................... void initLedDriver(void) 
.................... { 
....................   sendSpiLED2(0x0B, 0x07, 0x0B, 0x07);      // Scan Limit full range 
....................   sendSpiLED2(0x0C, 0x01, 0x0C, 0x01);      // Shutdown Normal Operation 
....................   sendSpiLED2(0x0F, 0x00, 0x0F, 0x00);      // Display Test Off 
....................  
....................   // print startup pattern  
....................   sendSpiLED2(0x0A, 0x0F, 0x0A, 0x0F); // Max Intensity 0x00[min] - 0x0F[max] 
....................   sendSpiLED2(1, 0, 1, 0); 
....................   sendSpiLED2(2, 0, 2, 0); 
....................   sendSpiLED2(3, 0, 3, 0); 
....................   sendSpiLED2(4, 24, 4, 0); 
....................   sendSpiLED2(5, 24, 5, 0); 
....................   sendSpiLED2(6, 0, 6, 0); 
....................   sendSpiLED2(7, 0, 7, 0); 
....................   sendSpiLED2(8, 0, 8, 0); 
....................   for(i = 0; i < 64; i++) 
....................   { 
....................     sendSpiLED2(0x0A, (64 - i) / 4, 0x0A, (64 - i) / 4);   // set to max intensity 
....................     delay_ms(4); 
....................   } 
....................   sendSpiLED2(0x0A, 0x0F, 0x0A, 0x0F); // Max Intensity 0x00[min] - 0x0F[max] 
....................   sendSpiLED2(1, 0, 1, 0); 
....................   sendSpiLED2(2, 0, 2, 0); 
....................   sendSpiLED2(3, 24, 3, 0); 
....................   sendSpiLED2(4, 36, 4, 0); 
....................   sendSpiLED2(5, 36, 5, 0); 
....................   sendSpiLED2(6, 24, 6, 0); 
....................   sendSpiLED2(7, 0, 7, 0); 
....................   sendSpiLED2(8, 0, 8, 0); 
....................   for(i = 0; i < 64; i++) 
....................   { 
....................     sendSpiLED2(0x0A, (64 - i) / 4, 0x0A, (64 - i) / 4);   // set to max intensity 
....................     delay_ms(4); 
....................   } 
....................   sendSpiLED2(0x0A, 0x0F, 0x0A, 0x0F); // Max Intensity 0x00[min] - 0x0F[max] 
....................   sendSpiLED2(1, 0, 1, 0); 
....................   sendSpiLED2(2, 24, 2, 0); 
....................   sendSpiLED2(3, 36, 3, 0); 
....................   sendSpiLED2(4, 66, 4, 0); 
....................   sendSpiLED2(5, 66, 5, 0); 
....................   sendSpiLED2(6, 36, 6, 0); 
....................   sendSpiLED2(7, 24, 7, 0); 
....................   sendSpiLED2(8, 0, 8, 0); 
....................   for(i = 0; i < 64; i++) 
....................   { 
....................     sendSpiLED2(0x0A, (64 - i) / 4, 0x0A, (64 - i) / 4);   // set to max intensity 
....................     delay_ms(4); 
....................   } 
....................  
....................   sendSpiLED2(0x0A, para.intensity, 0x0A, para.intensity); // Max Intensity 0x00[min] - 0x0F[max] 
....................  
....................   for(i = 1; i < 9; i++) 
....................   { 
....................     sendSpiLED2(i, 0x00, i, 0x00); 
....................   } 
.................... } 
....................  
.................... void sendSpiLED2(int msb0, int lsb0, int msb1, int lsb1) 
.................... { 
....................   output_bit(LDD_LOAD, 0); 
....................   spi_write(msb1); 
....................   spi_write(lsb1); 
....................   spi_write(msb0); 
....................   spi_write(lsb0); 
....................   output_bit(LDD_LOAD, 1); 
....................   delay_cycles(1); 
.................... } 
.................... #endif//sy 
....................  
.................... /***********************************/ 
.................... /*                                 */ 
.................... /*    Function for OSC Msgs Rcv    */ 
.................... /*                                 */ 
.................... /***********************************/ 
.................... void receiveOscMsgs(void) 
.................... { 
....................   if(usb_cdc_kbhit()) 
*
30F8:  BTFSS  x83.0
30FA:  BRA    35F4
....................   { 
....................     my_get_string_usb(string, 15); 
30FC:  MOVLB  1
30FE:  CLRF   x9C
3100:  MOVLW  98
3102:  MOVWF  x9B
3104:  MOVLW  0F
3106:  MOVWF  x9D
3108:  MOVLB  0
310A:  BRA    2BE4
....................  
....................     if(string[0] == 'l' && (string[1] == '0' || string[1] == '1')) // led 
310C:  MOVF   x98,W
310E:  SUBLW  6C
3110:  BNZ   31BA
3112:  MOVF   x99,W
3114:  SUBLW  30
3116:  BZ    311E
3118:  MOVF   x99,W
311A:  SUBLW  31
311C:  BNZ   31BA
....................     { 
....................       x = my_atoi(string[2]); 
311E:  MOVFF  9A,19B
3122:  RCALL  2C36
3124:  MOVFF  01,8C
....................       y = my_atoi(string[3]); 
3128:  MOVFF  9B,19B
312C:  RCALL  2C36
312E:  MOVFF  01,8D
....................       state = my_atoi(string[1]); 
3132:  MOVFF  99,19B
3136:  RCALL  2C36
3138:  MOVFF  01,8E
.................... #ifndef ONE_TWENTY_EIGHT//for sixty four 
....................       if(state) 
313C:  MOVF   x8E,F
313E:  BZ    3168
....................         led_data[y] |= (1 << x); 
3140:  CLRF   03
3142:  MOVF   x8D,W
3144:  ADDLW  8F
3146:  MOVWF  FE9
3148:  MOVLW  00
314A:  ADDWFC 03,W
314C:  MOVWF  FEA
314E:  MOVLW  01
3150:  MOVWF  00
3152:  MOVF   x8C,W
3154:  MOVWF  01
3156:  BZ    3160
3158:  BCF    FD8.0
315A:  RLCF   00,F
315C:  DECFSZ 01,F
315E:  BRA    3158
3160:  MOVF   00,W
3162:  IORWF  FEF,W
3164:  MOVWF  FEF
....................       else 
3166:  BRA    3190
....................         led_data[y] &= ~(1 << x); 
3168:  CLRF   03
316A:  MOVF   x8D,W
316C:  ADDLW  8F
316E:  MOVWF  FE9
3170:  MOVLW  00
3172:  ADDWFC 03,W
3174:  MOVWF  FEA
3176:  MOVLW  01
3178:  MOVWF  00
317A:  MOVF   x8C,W
317C:  MOVWF  01
317E:  BZ    3188
3180:  BCF    FD8.0
3182:  RLCF   00,F
3184:  DECFSZ 01,F
3186:  BRA    3180
3188:  MOVF   00,W
318A:  XORLW  FF
318C:  ANDWF  FEF,W
318E:  MOVWF  FEF
....................  
....................       sendSpiLED(y + 1, led_data[y]); 
3190:  MOVLW  01
3192:  ADDWF  x8D,W
3194:  MOVLB  1
3196:  MOVWF  x9B
3198:  CLRF   03
319A:  MOVLB  0
319C:  MOVF   x8D,W
319E:  ADDLW  8F
31A0:  MOVWF  FE9
31A2:  MOVLW  00
31A4:  ADDWFC 03,W
31A6:  MOVWF  FEA
31A8:  MOVFF  FEF,19C
31AC:  MOVFF  19B,19D
31B0:  MOVFF  19C,19E
31B4:  CALL   2878
.................... #else//for one twenty eight 
....................       if(x < 8) 
....................       { 
....................         x1 = y; 
....................         y1 = 7 - x; 
....................         x = x1; 
....................         y = y1; 
....................       } 
....................       if(state == 0) 
....................         led_data[y] &= ~((long)1 << x); 
....................       else 
....................         led_data[y] |= ((long)1 << x); 
....................  
....................       lsb0 = (int)(led_data[y] & 0x00FF); 
....................       lsb1 = (int)((led_data[y] & 0xFF00) >> 8); 
....................       sendSpiLED2(y + 1, lsb0, y + 1, lsb1); 
.................... #endif 
....................     } 
....................     else if(string[0] == 'l' && string[1] == 'c') // led_col 
31B8:  BRA    35F4
31BA:  MOVF   x98,W
31BC:  SUBLW  6C
31BE:  BTFSS  FD8.2
31C0:  BRA    3324
31C2:  MOVF   x99,W
31C4:  SUBLW  63
31C6:  BTFSS  FD8.2
31C8:  BRA    3324
....................     { 
.................... #ifndef ONE_TWENTY_EIGHT//for sixty four 
....................       int column, data; 
....................       ch = strtok(string, space); 
31CA:  MOVLB  1
31CC:  CLRF   x9C
31CE:  MOVLW  98
31D0:  MOVWF  x9B
31D2:  CLRF   x9E
31D4:  MOVLW  A7
31D6:  MOVWF  x9D
31D8:  MOVLB  0
31DA:  RCALL  2D7C
31DC:  MOVFF  02,8B
31E0:  MOVFF  01,8A
....................       ch = strtok(0, space); 
31E4:  MOVLB  1
31E6:  CLRF   x9C
31E8:  CLRF   x9B
31EA:  CLRF   x9E
31EC:  MOVLW  A7
31EE:  MOVWF  x9D
31F0:  MOVLB  0
31F2:  RCALL  2D7C
31F4:  MOVFF  02,8B
31F8:  MOVFF  01,8A
....................       column = atoi(ch); 
31FC:  MOVFF  8B,19C
3200:  MOVFF  8A,19B
3204:  RCALL  2E7C
3206:  MOVFF  01,193
....................       ch = strtok(0, space); 
320A:  MOVLB  1
320C:  CLRF   x9C
320E:  CLRF   x9B
3210:  CLRF   x9E
3212:  MOVLW  A7
3214:  MOVWF  x9D
3216:  MOVLB  0
3218:  RCALL  2D7C
321A:  MOVFF  02,8B
321E:  MOVFF  01,8A
....................       data = atoi(ch); 
3222:  MOVFF  8B,19C
3226:  MOVFF  8A,19B
322A:  RCALL  2E7C
322C:  MOVFF  01,194
....................  
....................       if(firstRun == TRUE) 
3230:  DECFSZ x97,W
3232:  BRA    327A
....................       { 
....................         for(i = 0; i < 8; i++) 
3234:  CLRF   x88
3236:  MOVF   x88,W
3238:  SUBLW  07
323A:  BNC   3278
....................         { 
....................           led_data[i] = 0; 
323C:  CLRF   03
323E:  MOVF   x88,W
3240:  ADDLW  8F
3242:  MOVWF  FE9
3244:  MOVLW  00
3246:  ADDWFC 03,W
3248:  MOVWF  FEA
324A:  CLRF   FEF
....................           sendSpiLED(i + 1, led_data[i]); 
324C:  MOVLW  01
324E:  ADDWF  x88,W
3250:  MOVLB  1
3252:  MOVWF  x9B
3254:  CLRF   03
3256:  MOVLB  0
3258:  MOVF   x88,W
325A:  ADDLW  8F
325C:  MOVWF  FE9
325E:  MOVLW  00
3260:  ADDWFC 03,W
3262:  MOVWF  FEA
3264:  MOVFF  FEF,19C
3268:  MOVFF  19B,19D
326C:  MOVFF  19C,19E
3270:  CALL   2878
....................         } 
3274:  INCF   x88,F
3276:  BRA    3236
....................         firstRun = FALSE; 
3278:  CLRF   x97
....................       } 
....................       for(i = 0; i < 8; i++) 
327A:  CLRF   x88
327C:  MOVF   x88,W
327E:  SUBLW  07
3280:  BNC   3322
....................       { 
....................         if(data & (1 << i)) 
3282:  MOVLW  01
3284:  MOVWF  00
3286:  MOVF   x88,W
3288:  MOVWF  01
328A:  BZ    3294
328C:  BCF    FD8.0
328E:  RLCF   00,F
3290:  DECFSZ 01,F
3292:  BRA    328C
3294:  MOVF   00,W
3296:  MOVLB  1
3298:  ANDWF  x94,W
329A:  BZ    32C8
....................           led_data[i] |= 1 << column; 
329C:  CLRF   03
329E:  MOVLB  0
32A0:  MOVF   x88,W
32A2:  ADDLW  8F
32A4:  MOVWF  FE9
32A6:  MOVLW  00
32A8:  ADDWFC 03,W
32AA:  MOVWF  FEA
32AC:  MOVLW  01
32AE:  MOVWF  00
32B0:  MOVLB  1
32B2:  MOVF   x93,W
32B4:  MOVWF  01
32B6:  BZ    32C0
32B8:  BCF    FD8.0
32BA:  RLCF   00,F
32BC:  DECFSZ 01,F
32BE:  BRA    32B8
32C0:  MOVF   00,W
32C2:  IORWF  FEF,W
32C4:  MOVWF  FEF
....................         else 
32C6:  BRA    32F4
....................           led_data[i] &= ~(1 << column); 
32C8:  CLRF   03
32CA:  MOVLB  0
32CC:  MOVF   x88,W
32CE:  ADDLW  8F
32D0:  MOVWF  FE9
32D2:  MOVLW  00
32D4:  ADDWFC 03,W
32D6:  MOVWF  FEA
32D8:  MOVLW  01
32DA:  MOVWF  00
32DC:  MOVLB  1
32DE:  MOVF   x93,W
32E0:  MOVWF  01
32E2:  BZ    32EC
32E4:  BCF    FD8.0
32E6:  RLCF   00,F
32E8:  DECFSZ 01,F
32EA:  BRA    32E4
32EC:  MOVF   00,W
32EE:  XORLW  FF
32F0:  ANDWF  FEF,W
32F2:  MOVWF  FEF
....................  
....................         sendSpiLED(i + 1, led_data[i]); 
32F4:  MOVLW  01
32F6:  MOVLB  0
32F8:  ADDWF  x88,W
32FA:  MOVLB  1
32FC:  MOVWF  x9B
32FE:  CLRF   03
3300:  MOVLB  0
3302:  MOVF   x88,W
3304:  ADDLW  8F
3306:  MOVWF  FE9
3308:  MOVLW  00
330A:  ADDWFC 03,W
330C:  MOVWF  FEA
330E:  MOVFF  FEF,19C
3312:  MOVFF  19B,19D
3316:  MOVFF  19C,19E
331A:  CALL   2878
....................       } 
331E:  INCF   x88,F
3320:  BRA    327C
.................... #else//for one twenty eight 
....................       int column, data; 
....................       int column1, i1; 
....................       ch = strtok(string, space); 
....................       ch = strtok(0, space); 
....................       column = atoi(ch); 
....................       ch = strtok(0, space); 
....................       data = atoi(ch); 
....................  
....................       if(firstRun == TRUE) 
....................       { 
....................         for(i = 0; i < 8; i++) 
....................         { 
....................           led_data[i] = 0; 
....................           lsb0 = (int)(led_data[i] & 0x00FF); 
....................           lsb1 = (int)((led_data[i] & 0xFF00) >> 8); 
....................           sendSpiLED2(i + 1, lsb0, i + 1, lsb1); 
....................         } 
....................         firstRun = FALSE; 
....................       } 
....................       for(i = 0; i < 8; i++) 
....................       { 
....................         if(column < 8) 
....................         { 
....................           column1 = i; 
....................           i1 = 7 - column; 
....................         } 
....................         else 
....................         { 
....................           column1 = column; 
....................           i1 = i; 
....................         } 
....................         if(data & (1 << i)) 
....................           led_data[i1] |= ((long)1 << column1); 
....................         else 
....................           led_data[i1] &= ~((long)1 << column1); 
....................          
....................         if(column < 8) { 
....................           lsb0 = (int)(led_data[i1] & 0x00FF); 
....................           sendSpiLED2(i1 + 1, lsb0, 0, 0); 
....................         } 
....................         else { 
....................           lsb1 = (int)((led_data[i1] >> 8) & 0x00FF); 
....................           sendSpiLED2(0, 0, i1 + 1, lsb1); 
....................         } 
....................       } 
.................... #endif//sy 
....................     } 
....................     else if(string[0] == 'l' && string[1] == 'r') // led_row 
3322:  BRA    35F4
3324:  MOVF   x98,W
3326:  SUBLW  6C
3328:  BTFSS  FD8.2
332A:  BRA    3420
332C:  MOVF   x99,W
332E:  SUBLW  72
3330:  BTFSS  FD8.2
3332:  BRA    3420
....................     { 
.................... #ifndef ONE_TWENTY_EIGHT//for sixty four 
....................       int row, data; 
....................       ch = strtok(string, space); 
3334:  MOVLB  1
3336:  CLRF   x9C
3338:  MOVLW  98
333A:  MOVWF  x9B
333C:  CLRF   x9E
333E:  MOVLW  A7
3340:  MOVWF  x9D
3342:  MOVLB  0
3344:  RCALL  2D7C
3346:  MOVFF  02,8B
334A:  MOVFF  01,8A
....................       ch = strtok(0, space); 
334E:  MOVLB  1
3350:  CLRF   x9C
3352:  CLRF   x9B
3354:  CLRF   x9E
3356:  MOVLW  A7
3358:  MOVWF  x9D
335A:  MOVLB  0
335C:  RCALL  2D7C
335E:  MOVFF  02,8B
3362:  MOVFF  01,8A
....................       row = atoi(ch); 
3366:  MOVFF  8B,19C
336A:  MOVFF  8A,19B
336E:  RCALL  2E7C
3370:  MOVFF  01,195
....................       ch = strtok(0, space); 
3374:  MOVLB  1
3376:  CLRF   x9C
3378:  CLRF   x9B
337A:  CLRF   x9E
337C:  MOVLW  A7
337E:  MOVWF  x9D
3380:  MOVLB  0
3382:  RCALL  2D7C
3384:  MOVFF  02,8B
3388:  MOVFF  01,8A
....................       data = atoi(ch); 
338C:  MOVFF  8B,19C
3390:  MOVFF  8A,19B
3394:  RCALL  2E7C
3396:  MOVFF  01,196
....................        
....................       if(firstRun == TRUE) 
339A:  DECFSZ x97,W
339C:  BRA    33E4
....................       { 
....................         for(i = 0; i < 8; i++) 
339E:  CLRF   x88
33A0:  MOVF   x88,W
33A2:  SUBLW  07
33A4:  BNC   33E2
....................         { 
....................           led_data[i] = 0; 
33A6:  CLRF   03
33A8:  MOVF   x88,W
33AA:  ADDLW  8F
33AC:  MOVWF  FE9
33AE:  MOVLW  00
33B0:  ADDWFC 03,W
33B2:  MOVWF  FEA
33B4:  CLRF   FEF
....................           sendSpiLED(i + 1, led_data[i]); 
33B6:  MOVLW  01
33B8:  ADDWF  x88,W
33BA:  MOVLB  1
33BC:  MOVWF  x9B
33BE:  CLRF   03
33C0:  MOVLB  0
33C2:  MOVF   x88,W
33C4:  ADDLW  8F
33C6:  MOVWF  FE9
33C8:  MOVLW  00
33CA:  ADDWFC 03,W
33CC:  MOVWF  FEA
33CE:  MOVFF  FEF,19C
33D2:  MOVFF  19B,19D
33D6:  MOVFF  19C,19E
33DA:  CALL   2878
....................         } 
33DE:  INCF   x88,F
33E0:  BRA    33A0
....................         firstRun = FALSE; 
33E2:  CLRF   x97
....................       } 
....................       led_data[row] = data; 
33E4:  CLRF   03
33E6:  MOVLB  1
33E8:  MOVF   x95,W
33EA:  ADDLW  8F
33EC:  MOVWF  FE9
33EE:  MOVLW  00
33F0:  ADDWFC 03,W
33F2:  MOVWF  FEA
33F4:  MOVFF  196,FEF
....................       sendSpiLED(row + 1, led_data[row]); 
33F8:  MOVLW  01
33FA:  ADDWF  x95,W
33FC:  MOVWF  x9B
33FE:  CLRF   03
3400:  MOVF   x95,W
3402:  ADDLW  8F
3404:  MOVWF  FE9
3406:  MOVLW  00
3408:  ADDWFC 03,W
340A:  MOVWF  FEA
340C:  MOVFF  FEF,19C
3410:  MOVFF  19B,19D
3414:  MOVFF  19C,19E
3418:  MOVLB  0
341A:  CALL   2878
.................... #else//for one twenty eight 
....................       int row;  
....................       long data; 
....................       int row1, i1; 
....................       ch = strtok(string, space); 
....................       ch = strtok(0, space); 
....................       row = atoi(ch); 
....................       ch = strtok(0, space); 
....................       data = atol(ch); 
....................        
....................       if(firstRun == TRUE) 
....................       { 
....................         for(i = 0; i < 8; i++) 
....................         { 
....................           led_data[i] = 0; 
....................           lsb0 = (int)(led_data[i] & 0x00FF); 
....................           lsb1 = (int)((led_data[i] & 0xFF00) >> 8); 
....................           sendSpiLED2(i + 1, lsb0, i + 1, lsb1); 
....................         } 
....................         firstRun = FALSE; 
....................       } 
....................  
....................       for(i = 0; i < 16; i++) 
....................       { 
....................         if(i < 8) 
....................         { 
....................           i1 = row; 
....................           row1 = 7 - i; 
....................          
....................           if(data & (1 << i)) 
....................             led_data[row1] |= ((long)1 << i1); 
....................           else 
....................             led_data[row1] &= ~((long)1 << i1); 
....................          
....................           sendSpiLED2(row1 + 1, led_data[row1], 0, 0); 
....................         } 
....................         else 
....................         { 
....................           if(data & (1 << i)) 
....................             led_data[row] |= ((long)1 << i); 
....................           else 
....................             led_data[row] &= ~((long)1 << i); 
....................         } 
....................       } 
....................       lsb1 = (int)((data >> 8) & 0x00FF); 
....................       sendSpiLED2(0, 0, row + 1, lsb1); 
.................... #endif//sy 
....................     } 
....................     else if(string[0] == 'a' && string[1] == 'e') // adc_enable 
341E:  BRA    35F4
3420:  MOVF   x98,W
3422:  SUBLW  61
3424:  BNZ   34AA
3426:  MOVF   x99,W
3428:  SUBLW  65
342A:  BNZ   34AA
....................     { 
....................       int pin, state; 
....................       ch = strtok(string, space); 
342C:  MOVLB  1
342E:  CLRF   x9C
3430:  MOVLW  98
3432:  MOVWF  x9B
3434:  CLRF   x9E
3436:  MOVLW  A7
3438:  MOVWF  x9D
343A:  MOVLB  0
343C:  RCALL  2D7C
343E:  MOVFF  02,8B
3442:  MOVFF  01,8A
....................       ch = strtok(0, space); 
3446:  MOVLB  1
3448:  CLRF   x9C
344A:  CLRF   x9B
344C:  CLRF   x9E
344E:  MOVLW  A7
3450:  MOVWF  x9D
3452:  MOVLB  0
3454:  RCALL  2D7C
3456:  MOVFF  02,8B
345A:  MOVFF  01,8A
....................       pin = atoi(ch); 
345E:  MOVFF  8B,19C
3462:  MOVFF  8A,19B
3466:  RCALL  2E7C
3468:  MOVFF  01,197
....................       ch = strtok(0, space); 
346C:  MOVLB  1
346E:  CLRF   x9C
3470:  CLRF   x9B
3472:  CLRF   x9E
3474:  MOVLW  A7
3476:  MOVWF  x9D
3478:  MOVLB  0
347A:  RCALL  2D7C
347C:  MOVFF  02,8B
3480:  MOVFF  01,8A
....................       state = atoi(ch); 
3484:  MOVFF  8B,19C
3488:  MOVFF  8A,19B
348C:  RCALL  2E7C
348E:  MOVFF  01,198
....................       if(state) 
3492:  MOVLB  1
3494:  MOVF   x98,F
3496:  BZ    34A0
....................         enableAdc(pin); 
3498:  MOVFF  197,19B
349C:  MOVLB  0
349E:  BRA    301E
....................       else 
....................         disableAdc(pin); 
34A0:  MOVFF  197,19B
34A4:  MOVLB  0
34A6:  BRA    3052
....................     } 
....................     //sy else if(!strcmp(ch, p)) // pwm 
.................... /* 
....................     else if(string[0] == 'p' && string[1] == 'w' && string[2] == 'm') 
....................     { 
....................       int prescale, period; 
....................       float duty; 
....................       ch = strtok(string, space); 
....................       ch = strtok(0, space); 
....................       prescale = atoi(ch); 
....................       ch = strtok(0, space); 
....................       period = atoi(ch); 
....................       ch = strtok(0, space); 
....................       duty = atof(ch); 
....................       if(prescale == 1) 
....................         setup_timer_2(T2_DIV_BY_1, period, 1); 
....................       else if(prescale == 4) 
....................         setup_timer_2(T2_DIV_BY_4, period, 1); 
....................       else if(prescale == 16) 
....................         setup_timer_2(T2_DIV_BY_16, period, 1); 
....................       set_pwm1_duty((long)(1024.0 * duty)); 
....................     } 
.................... */ 
.................... /*sy 
....................     else if(!strcmp(ch, o)) // output 
....................     { 
....................       int pin, state; 
....................       ch = strtok(0, space); 
....................       pin = atoi(ch); 
....................       ch = strtok(0, space); 
....................       state = atoi(ch); 
....................       if(pin == 0) 
....................         output_bit(PIN_B4, state); 
....................       else if(pin == 1) 
....................         output_bit(PIN_B0, state); 
....................     } 
.................... */ 
....................     else if(string[0] == 'i') // intensity 
34A8:  BRA    35F4
34AA:  MOVF   x98,W
34AC:  SUBLW  69
34AE:  BNZ   3518
....................     { 
....................       ch = strtok(string, space); 
34B0:  MOVLB  1
34B2:  CLRF   x9C
34B4:  MOVLW  98
34B6:  MOVWF  x9B
34B8:  CLRF   x9E
34BA:  MOVLW  A7
34BC:  MOVWF  x9D
34BE:  MOVLB  0
34C0:  RCALL  2D7C
34C2:  MOVFF  02,8B
34C6:  MOVFF  01,8A
....................       ch = strtok(0, space); 
34CA:  MOVLB  1
34CC:  CLRF   x9C
34CE:  CLRF   x9B
34D0:  CLRF   x9E
34D2:  MOVLW  A7
34D4:  MOVWF  x9D
34D6:  MOVLB  0
34D8:  RCALL  2D7C
34DA:  MOVFF  02,8B
34DE:  MOVFF  01,8A
....................       para.intensity = atoi(ch); 
34E2:  MOVFF  8B,19C
34E6:  MOVFF  8A,19B
34EA:  RCALL  2E7C
34EC:  MOVFF  01,192
.................... #ifndef ONE_TWENTY_EIGHT//for sixty four 
....................       sendSpiLED(0x0A, para.intensity); 
34F0:  MOVLW  0A
34F2:  MOVLB  1
34F4:  MOVWF  x9D
34F6:  MOVFF  192,19E
34FA:  MOVLB  0
34FC:  CALL   2878
.................... #else//for one twenty eight 
....................       sendSpiLED2(0x0A, para.intensity, 0x0A, para.intensity); 
.................... #endif 
....................       putParaToEeprom(&para, sizeof(para), 0); 
3500:  MOVLW  01
3502:  MOVLB  1
3504:  MOVWF  x9C
3506:  MOVLW  92
3508:  MOVWF  x9B
350A:  MOVLW  01
350C:  MOVWF  x9D
350E:  CLRF   x9E
3510:  MOVLB  0
3512:  CALL   2764
....................     } 
....................     else if(string[0] == 't') // test 
3516:  BRA    35F4
3518:  MOVF   x98,W
351A:  SUBLW  74
351C:  BNZ   3570
....................     { 
....................       int state; 
....................       ch = strtok(string, space); 
351E:  MOVLB  1
3520:  CLRF   x9C
3522:  MOVLW  98
3524:  MOVWF  x9B
3526:  CLRF   x9E
3528:  MOVLW  A7
352A:  MOVWF  x9D
352C:  MOVLB  0
352E:  RCALL  2D7C
3530:  MOVFF  02,8B
3534:  MOVFF  01,8A
....................       ch = strtok(0, space); 
3538:  MOVLB  1
353A:  CLRF   x9C
353C:  CLRF   x9B
353E:  CLRF   x9E
3540:  MOVLW  A7
3542:  MOVWF  x9D
3544:  MOVLB  0
3546:  RCALL  2D7C
3548:  MOVFF  02,8B
354C:  MOVFF  01,8A
....................       state = atoi(ch); 
3550:  MOVFF  8B,19C
3554:  MOVFF  8A,19B
3558:  RCALL  2E7C
355A:  MOVFF  01,199
.................... #ifndef ONE_TWENTY_EIGHT//for sixty four 
....................       sendSpiLED(15, state); 
355E:  MOVLW  0F
3560:  MOVLB  1
3562:  MOVWF  x9D
3564:  MOVFF  199,19E
3568:  MOVLB  0
356A:  CALL   2878
.................... #else//for one twenty eight 
....................       sendSpiLED2(15, state, 15, state); 
.................... #endif//sy 
....................     } 
....................     else if(string[0] == 's') // shutdown 
356E:  BRA    35F4
3570:  MOVF   x98,W
3572:  SUBLW  73
3574:  BNZ   35CC
....................     { 
....................       int state; 
....................       ch = strtok(string, space); 
3576:  MOVLB  1
3578:  CLRF   x9C
357A:  MOVLW  98
357C:  MOVWF  x9B
357E:  CLRF   x9E
3580:  MOVLW  A7
3582:  MOVWF  x9D
3584:  MOVLB  0
3586:  CALL   2D7C
358A:  MOVFF  02,8B
358E:  MOVFF  01,8A
....................       ch = strtok(0, space); 
3592:  MOVLB  1
3594:  CLRF   x9C
3596:  CLRF   x9B
3598:  CLRF   x9E
359A:  MOVLW  A7
359C:  MOVWF  x9D
359E:  MOVLB  0
35A0:  CALL   2D7C
35A4:  MOVFF  02,8B
35A8:  MOVFF  01,8A
....................       state = atoi(ch); 
35AC:  MOVFF  8B,19C
35B0:  MOVFF  8A,19B
35B4:  RCALL  2E7C
35B6:  MOVFF  01,19A
.................... #ifndef ONE_TWENTY_EIGHT//for sixty four 
....................       sendSpiLED(12, state); 
35BA:  MOVLW  0C
35BC:  MOVLB  1
35BE:  MOVWF  x9D
35C0:  MOVFF  19A,19E
35C4:  MOVLB  0
35C6:  CALL   2878
.................... #else//for one twenty eight 
....................       sendSpiLED2(12, state, 12, state); 
.................... #endif 
....................     } 
....................     else if(string[0] == 'f') // firmware 
35CA:  BRA    35F4
35CC:  MOVF   x98,W
35CE:  SUBLW  66
35D0:  BNZ   35F4
....................     { 
....................       usb_cdc_putc('f'); 
35D2:  MOVLW  66
35D4:  MOVLB  1
35D6:  MOVWF  x9B
35D8:  MOVLB  0
35DA:  RCALL  30D4
....................       usb_cdc_putc(10); 
35DC:  MOVLW  0A
35DE:  MOVLB  1
35E0:  MOVWF  x9B
35E2:  MOVLB  0
35E4:  RCALL  30D4
....................       delay_cycles(1); 
35E6:  NOP   
....................       usb_cdc_putc(23); 
35E8:  MOVLW  17
35EA:  MOVLB  1
35EC:  MOVWF  x9B
35EE:  MOVLB  0
35F0:  RCALL  30D4
....................       delay_cycles(1); 
35F2:  NOP   
....................     } 
....................   } 
.................... } 
35F4:  GOTO   3D0C (RETURN)
....................  
.................... /***********************************/ 
.................... /*                                 */ 
.................... /*  Functions for Button Handling  */ 
.................... /*                                 */ 
.................... /***********************************/ 
.................... void buttonInit(void) 
.................... { 
....................   for(i = 0; i < 8; i++) 
*
27D6:  CLRF   x88
27D8:  MOVF   x88,W
27DA:  SUBLW  07
27DC:  BNC   284A
....................   { 
....................     btnCurrent[i] = 0x00; 
27DE:  CLRF   03
27E0:  MOVF   x88,W
27E2:  ADDLW  AA
27E4:  MOVWF  FE9
27E6:  MOVLW  00
27E8:  ADDWFC 03,W
27EA:  MOVWF  FEA
27EC:  CLRF   FEF
....................     btnLast[i] = 0x00; 
27EE:  CLRF   03
27F0:  MOVF   x88,W
27F2:  ADDLW  B2
27F4:  MOVWF  FE9
27F6:  MOVLW  00
27F8:  ADDWFC 03,W
27FA:  MOVWF  FEA
27FC:  CLRF   FEF
....................     btnState[i] = 0x00; 
27FE:  CLRF   03
2800:  MOVF   x88,W
2802:  ADDLW  BA
2804:  MOVWF  FE9
2806:  MOVLW  00
2808:  ADDWFC 03,W
280A:  MOVWF  FEA
280C:  CLRF   FEF
....................  
.................... #ifndef ONE_TWENTY_EIGHT//for sixty four 
....................     for(j = 0; j < 8; j++) 
280E:  CLRF   x89
2810:  MOVF   x89,W
2812:  SUBLW  07
2814:  BNC   2846
.................... #else//for one twenty eight 
....................     for(j = 0; j < 16; j++) 
.................... #endif 
....................       btnDebounceCount[i][j] = 0; 
2816:  MOVF   x88,W
2818:  MULLW  08
281A:  MOVF   FF3,W
281C:  MOVLB  1
281E:  CLRF   x94
2820:  MOVWF  x93
2822:  CLRF   03
2824:  MOVLB  0
2826:  MOVF   x89,W
2828:  MOVLB  1
282A:  ADDWF  x93,W
282C:  MOVWF  01
282E:  MOVF   x94,W
2830:  ADDWFC 03,F
2832:  MOVF   01,W
2834:  ADDLW  C2
2836:  MOVWF  FE9
2838:  MOVLW  00
283A:  ADDWFC 03,W
283C:  MOVWF  FEA
283E:  CLRF   FEF
2840:  MOVLB  0
2842:  INCF   x89,F
2844:  BRA    2810
....................   } 
2846:  INCF   x88,F
2848:  BRA    27D8
.................... } 
284A:  GOTO   3CC2 (RETURN)
....................  
.................... short buttonCheck(int row, int index) 
.................... { 
....................   flag = FALSE; 
*
35F8:  BCF    x81.2
....................  
.................... #ifndef ONE_TWENTY_EIGHT//for sixty four 
....................   if(((btnCurrent[row] ^ btnLast[row]) & (1 << index)) && ((btnCurrent[row] ^ btnState[row]) & (1 << index))) 
35FA:  CLRF   03
35FC:  MOVLB  1
35FE:  MOVF   x93,W
3600:  ADDLW  AA
3602:  MOVWF  FE9
3604:  MOVLW  00
3606:  ADDWFC 03,W
3608:  MOVWF  FEA
360A:  MOVFF  FEF,195
360E:  CLRF   03
3610:  MOVF   x93,W
3612:  ADDLW  B2
3614:  MOVWF  FE9
3616:  MOVLW  00
3618:  ADDWFC 03,W
361A:  MOVWF  FEA
361C:  MOVF   FEF,W
361E:  XORWF  x95,F
3620:  MOVLW  01
3622:  MOVWF  00
3624:  MOVF   x94,W
3626:  MOVWF  01
3628:  BZ    3632
362A:  BCF    FD8.0
362C:  RLCF   00,F
362E:  DECFSZ 01,F
3630:  BRA    362A
3632:  MOVF   00,W
3634:  ANDWF  x95,W
3636:  BZ    369A
3638:  CLRF   03
363A:  MOVF   x93,W
363C:  ADDLW  AA
363E:  MOVWF  FE9
3640:  MOVLW  00
3642:  ADDWFC 03,W
3644:  MOVWF  FEA
3646:  MOVFF  FEF,195
364A:  CLRF   03
364C:  MOVF   x93,W
364E:  ADDLW  BA
3650:  MOVWF  FE9
3652:  MOVLW  00
3654:  ADDWFC 03,W
3656:  MOVWF  FEA
3658:  MOVF   FEF,W
365A:  XORWF  x95,F
365C:  MOVLW  01
365E:  MOVWF  00
3660:  MOVF   x94,W
3662:  MOVWF  01
3664:  BZ    366E
3666:  BCF    FD8.0
3668:  RLCF   00,F
366A:  DECFSZ 01,F
366C:  BRA    3666
366E:  MOVF   00,W
3670:  ANDWF  x95,W
3672:  BZ    369A
....................     btnDebounceCount[row][index] = 0; 
3674:  MOVF   x93,W
3676:  MULLW  08
3678:  MOVF   FF3,W
367A:  CLRF   x96
367C:  MOVWF  x95
367E:  CLRF   03
3680:  MOVF   x94,W
3682:  ADDWF  x95,W
3684:  MOVWF  01
3686:  MOVF   x96,W
3688:  ADDWFC 03,F
368A:  MOVF   01,W
368C:  ADDLW  C2
368E:  MOVWF  FE9
3690:  MOVLW  00
3692:  ADDWFC 03,W
3694:  MOVWF  FEA
3696:  CLRF   FEF
....................   else if (((btnCurrent[row] ^ btnLast[row]) & (1 << index)) == 0 && ((btnCurrent[row] ^ btnState[row]) & (1 << index))) 
3698:  BRA    37E6
369A:  CLRF   03
369C:  MOVF   x93,W
369E:  ADDLW  AA
36A0:  MOVWF  FE9
36A2:  MOVLW  00
36A4:  ADDWFC 03,W
36A6:  MOVWF  FEA
36A8:  MOVFF  FEF,195
36AC:  CLRF   03
36AE:  MOVF   x93,W
36B0:  ADDLW  B2
36B2:  MOVWF  FE9
36B4:  MOVLW  00
36B6:  ADDWFC 03,W
36B8:  MOVWF  FEA
36BA:  MOVF   FEF,W
36BC:  XORWF  x95,F
36BE:  MOVLW  01
36C0:  MOVWF  00
36C2:  MOVF   x94,W
36C4:  MOVWF  01
36C6:  BZ    36D0
36C8:  BCF    FD8.0
36CA:  RLCF   00,F
36CC:  DECFSZ 01,F
36CE:  BRA    36C8
36D0:  MOVF   00,W
36D2:  ANDWF  x95,W
36D4:  BTFSS  FD8.2
36D6:  BRA    37E6
36D8:  CLRF   03
36DA:  MOVF   x93,W
36DC:  ADDLW  AA
36DE:  MOVWF  FE9
36E0:  MOVLW  00
36E2:  ADDWFC 03,W
36E4:  MOVWF  FEA
36E6:  MOVFF  FEF,195
36EA:  CLRF   03
36EC:  MOVF   x93,W
36EE:  ADDLW  BA
36F0:  MOVWF  FE9
36F2:  MOVLW  00
36F4:  ADDWFC 03,W
36F6:  MOVWF  FEA
36F8:  MOVF   FEF,W
36FA:  XORWF  x95,F
36FC:  MOVLW  01
36FE:  MOVWF  00
3700:  MOVF   x94,W
3702:  MOVWF  01
3704:  BZ    370E
3706:  BCF    FD8.0
3708:  RLCF   00,F
370A:  DECFSZ 01,F
370C:  BRA    3706
370E:  MOVF   00,W
3710:  ANDWF  x95,W
3712:  BZ    37E6
....................   { 
....................     if(btnDebounceCount[row][index] < 4 && ++btnDebounceCount[row][index] == 4) 
3714:  MOVF   x93,W
3716:  MULLW  08
3718:  MOVF   FF3,W
371A:  CLRF   x96
371C:  MOVWF  x95
371E:  CLRF   03
3720:  MOVF   x94,W
3722:  ADDWF  x95,W
3724:  MOVWF  01
3726:  MOVF   x96,W
3728:  ADDWFC 03,F
372A:  MOVF   01,W
372C:  ADDLW  C2
372E:  MOVWF  FE9
3730:  MOVLW  00
3732:  ADDWFC 03,W
3734:  MOVWF  FEA
3736:  MOVF   FEF,W
3738:  SUBLW  03
373A:  BNC   37E6
373C:  MOVF   x93,W
373E:  MULLW  08
3740:  MOVF   FF3,W
3742:  CLRF   x96
3744:  MOVWF  x95
3746:  CLRF   03
3748:  MOVF   x94,W
374A:  ADDWF  x95,W
374C:  MOVWF  01
374E:  MOVF   x96,W
3750:  ADDWFC 03,F
3752:  MOVF   01,W
3754:  ADDLW  C2
3756:  MOVWF  FE9
3758:  MOVLW  00
375A:  ADDWFC 03,W
375C:  MOVWF  FEA
375E:  INCF   FEF,F
3760:  MOVF   FEF,W
3762:  SUBLW  04
3764:  BNZ   37E6
....................     { 
....................       if(btnCurrent[row] & (1 << index)) 
3766:  CLRF   03
3768:  MOVF   x93,W
376A:  ADDLW  AA
376C:  MOVWF  FE9
376E:  MOVLW  00
3770:  ADDWFC 03,W
3772:  MOVWF  FEA
3774:  MOVFF  FEF,195
3778:  MOVLW  01
377A:  MOVWF  00
377C:  MOVF   x94,W
377E:  MOVWF  01
3780:  BZ    378A
3782:  BCF    FD8.0
3784:  RLCF   00,F
3786:  DECFSZ 01,F
3788:  BRA    3782
378A:  MOVF   00,W
378C:  ANDWF  x95,W
378E:  BZ    37B8
....................         btnState[row] |= (1 << index); 
3790:  CLRF   03
3792:  MOVF   x93,W
3794:  ADDLW  BA
3796:  MOVWF  FE9
3798:  MOVLW  00
379A:  ADDWFC 03,W
379C:  MOVWF  FEA
379E:  MOVLW  01
37A0:  MOVWF  00
37A2:  MOVF   x94,W
37A4:  MOVWF  01
37A6:  BZ    37B0
37A8:  BCF    FD8.0
37AA:  RLCF   00,F
37AC:  DECFSZ 01,F
37AE:  BRA    37A8
37B0:  MOVF   00,W
37B2:  IORWF  FEF,W
37B4:  MOVWF  FEF
....................       else 
37B6:  BRA    37E0
....................         btnState[row] &= ~(1 << index); 
37B8:  CLRF   03
37BA:  MOVF   x93,W
37BC:  ADDLW  BA
37BE:  MOVWF  FE9
37C0:  MOVLW  00
37C2:  ADDWFC 03,W
37C4:  MOVWF  FEA
37C6:  MOVLW  01
37C8:  MOVWF  00
37CA:  MOVF   x94,W
37CC:  MOVWF  01
37CE:  BZ    37D8
37D0:  BCF    FD8.0
37D2:  RLCF   00,F
37D4:  DECFSZ 01,F
37D6:  BRA    37D0
37D8:  MOVF   00,W
37DA:  XORLW  FF
37DC:  ANDWF  FEF,W
37DE:  MOVWF  FEF
....................       flag = TRUE; 
37E0:  MOVLB  0
37E2:  BSF    x81.2
37E4:  MOVLB  1
....................     } 
....................   } 
.................... #else//for one twenty eight 
....................   if(((btnCurrent[row] ^ btnLast[row]) & ((long)1 << index)) && ((btnCurrent[row] ^ btnState[row]) & ((long)1 << index))) 
....................     btnDebounceCount[row][index] = 0; 
....................   else if (((btnCurrent[row] ^ btnLast[row]) & ((long)1 << index)) == 0 && ((btnCurrent[row] ^ btnState[row]) & ((long)1 << index))) 
....................   { 
....................     if(btnDebounceCount[row][index] < 4 && ++btnDebounceCount[row][index] == 4) 
....................     { 
....................       if(btnCurrent[row] & ((long)1 << index)) 
....................         btnState[row] |= ((long)1 << index); 
....................       else 
....................         btnState[row] &= ~((long)1 << index); 
....................       flag = TRUE; 
....................     } 
....................   } 
.................... #endif 
....................   return flag; 
37E6:  MOVLW  00
37E8:  MOVLB  0
37EA:  BTFSC  x81.2
37EC:  MOVLW  01
37EE:  MOVWF  01
.................... } 
37F0:  GOTO   38DE (RETURN)
....................  
.................... void sendOscMsgPress(void) 
.................... { 
....................   if(start_row == 0) 
37F4:  MOVF   xA9,F
37F6:  BNZ   37FC
....................     output_bit(SR_A, 0); 
37F8:  BCF    F8A.7
37FA:  BCF    F93.7
....................  
....................   for(i = start_row; i < start_row + 4; i++) 
37FC:  MOVFF  A9,88
3800:  MOVLW  04
3802:  ADDWF  xA9,W
3804:  SUBWF  x88,W
3806:  BTFSC  FD8.0
3808:  BRA    395E
....................   { 
....................     output_bit(SR_CLK, 1); 
380A:  BSF    F8A.6
380C:  BCF    F93.6
....................     output_bit(SR_CLK, 0); 
380E:  BCF    F8A.6
3810:  BCF    F93.6
....................  
....................     output_bit(SR_A, 1); 
3812:  BSF    F8A.7
3814:  BCF    F93.7
....................  
....................     btnLast[i] = btnCurrent[i]; 
3816:  CLRF   03
3818:  MOVF   x88,W
381A:  ADDLW  B2
381C:  MOVWF  01
381E:  MOVLW  00
3820:  ADDWFC 03,F
3822:  MOVLB  1
3824:  MOVFF  03,194
3828:  CLRF   03
382A:  MOVLB  0
382C:  MOVF   x88,W
382E:  ADDLW  AA
3830:  MOVWF  FE9
3832:  MOVLW  00
3834:  ADDWFC 03,W
3836:  MOVWF  FEA
3838:  MOVFF  FEF,195
383C:  MOVLB  1
383E:  MOVFF  194,FEA
3842:  MOVFF  01,FE9
3846:  MOVFF  195,FEF
....................  
....................     output_bit(SR_SL, 0); 
384A:  BCF    F8B.1
384C:  BCF    F94.1
....................     delay_us(5); 
384E:  MOVLW  13
3850:  MOVWF  00
3852:  DECFSZ 00,F
3854:  BRA    3852
3856:  BRA    3858
....................     output_bit(SR_SL, 1); 
3858:  BSF    F8B.1
385A:  BCF    F94.1
....................  
.................... #ifndef ONE_TWENTY_EIGHT//for sixty four 
....................     for(j = 0; j < 8; j++) 
385C:  MOVLB  0
385E:  CLRF   x89
3860:  MOVF   x89,W
3862:  SUBLW  07
3864:  BTFSS  FD8.0
3866:  BRA    395A
.................... #else//for one twenty eight 
....................     for(j = 0; j < 16; j++) 
.................... #endif 
....................     { 
....................       if(input(SR_QH)) 
3868:  BSF    F94.6
386A:  BTFSS  F82.6
386C:  BRA    38AA
....................         btnCurrent[i] &= ~((long)1 << j); 
386E:  CLRF   03
3870:  MOVF   x88,W
3872:  ADDLW  AA
3874:  MOVWF  FE9
3876:  MOVLW  00
3878:  ADDWFC 03,W
387A:  MOVWF  FEA
387C:  CLRF   03
387E:  MOVLW  01
3880:  MOVWF  02
3882:  MOVF   x89,W
3884:  MOVWF  00
3886:  BZ    3892
3888:  BCF    FD8.0
388A:  RLCF   02,F
388C:  RLCF   03,F
388E:  DECFSZ 00,F
3890:  BRA    3888
3892:  MOVF   02,W
3894:  CLRF   00
3896:  DECF   00,F
3898:  XORWF  00,F
389A:  MOVLW  FF
389C:  XORWF  03,F
389E:  MOVF   00,W
38A0:  ANDWF  FEF,W
38A2:  MOVWF  00
38A4:  MOVF   00,W
38A6:  MOVWF  FEF
....................       else 
38A8:  BRA    38D4
....................         btnCurrent[i] |= ((long)1 << j); 
38AA:  CLRF   03
38AC:  MOVF   x88,W
38AE:  ADDLW  AA
38B0:  MOVWF  FE9
38B2:  MOVLW  00
38B4:  ADDWFC 03,W
38B6:  MOVWF  FEA
38B8:  CLRF   03
38BA:  MOVLW  01
38BC:  MOVWF  02
38BE:  MOVF   x89,W
38C0:  MOVWF  00
38C2:  BZ    38CE
38C4:  BCF    FD8.0
38C6:  RLCF   02,F
38C8:  RLCF   03,F
38CA:  DECFSZ 00,F
38CC:  BRA    38C4
38CE:  MOVF   02,W
38D0:  IORWF  FEF,W
38D2:  MOVWF  FEF
....................  
....................       if(buttonCheck(i, j)) 
38D4:  MOVFF  88,193
38D8:  MOVFF  89,194
38DC:  BRA    35F8
38DE:  MOVF   01,F
38E0:  BZ    394E
....................       { 
.................... #ifdef ONE_TWENTY_EIGHT//for sixty four 
....................         if(j < 8) 
....................         { 
....................           if(btnState[i] & ((long)1 << j)) 
....................             usb_cdc_putc('p'); 
....................           else 
....................             usb_cdc_putc('r'); 
....................           delay_cycles(1); 
....................           usb_cdc_putc((j << 4) + (7 - i)); 
....................           delay_cycles(1); 
....................         } 
....................         else 
.................... #endif 
....................         { 
....................           if(btnState[i] & ((long)1 << j)) 
38E2:  CLRF   03
38E4:  MOVF   x88,W
38E6:  ADDLW  BA
38E8:  MOVWF  FE9
38EA:  MOVLW  00
38EC:  ADDWFC 03,W
38EE:  MOVWF  FEA
38F0:  MOVFF  FEF,193
38F4:  CLRF   03
38F6:  MOVLW  01
38F8:  MOVWF  02
38FA:  MOVF   x89,W
38FC:  MOVWF  00
38FE:  BZ    390A
3900:  BCF    FD8.0
3902:  RLCF   02,F
3904:  RLCF   03,F
3906:  DECFSZ 00,F
3908:  BRA    3900
390A:  MOVF   02,W
390C:  MOVLB  1
390E:  ANDWF  x93,W
3910:  MOVWF  00
3912:  CLRF   03
3914:  MOVF   00,W
3916:  IORWF  03,W
3918:  BZ    3928
....................             usb_cdc_putc('p'); 
391A:  MOVLW  70
391C:  MOVWF  x9B
391E:  MOVLB  0
3920:  CALL   30D4
....................           else 
3924:  BRA    3932
3926:  MOVLB  1
....................             usb_cdc_putc('r'); 
3928:  MOVLW  72
392A:  MOVWF  x9B
392C:  MOVLB  0
392E:  CALL   30D4
....................           delay_cycles(1); 
3932:  NOP   
....................           usb_cdc_putc((i << 4) + j); 
3934:  SWAPF  x88,W
3936:  MOVWF  00
3938:  MOVLW  F0
393A:  ANDWF  00,F
393C:  MOVF   00,W
393E:  ADDWF  x89,W
3940:  MOVLB  1
3942:  MOVWF  x93
3944:  MOVWF  x9B
3946:  MOVLB  0
3948:  CALL   30D4
....................           delay_cycles(1); 
394C:  NOP   
....................         } 
....................       } 
....................       output_bit(SR_CLK2, 1); 
394E:  BSF    F8B.0
3950:  BCF    F94.0
....................       output_bit(SR_CLK2, 0); 
3952:  BCF    F8B.0
3954:  BCF    F94.0
....................     } 
3956:  INCF   x89,F
3958:  BRA    3860
....................   } 
395A:  INCF   x88,F
395C:  BRA    3800
....................   if(start_row == 0) 
395E:  MOVF   xA9,F
3960:  BNZ   3968
....................     start_row = 4; 
3962:  MOVLW  04
3964:  MOVWF  xA9
....................   else if(start_row == 4) 
3966:  BRA    3970
3968:  MOVF   xA9,W
396A:  SUBLW  04
396C:  BNZ   3970
....................     start_row = 0; 
396E:  CLRF   xA9
.................... } 
3970:  GOTO   3D0E (RETURN)
....................  
.................... /***********************************/ 
.................... /*                                 */ 
.................... /*  Functions for A/D Conversion   */ 
.................... /*                                 */ 
.................... /***********************************/ 
.................... void enableAdc(int port) 
.................... { 
....................   if(port >= kAdcFilterNumAdcs) 
*
301E:  MOVLB  1
3020:  MOVF   x9B,W
3022:  SUBLW  06
3024:  BC    3028
....................     return; 
3026:  BRA    304C
....................  
....................   if((gAdcEnableState & 0x7F) == 0) 
3028:  MOVF   x02,W
302A:  ANDLW  7F
302C:  BNZ   3034
....................     enableAdcFlag = TRUE; 
302E:  MOVLB  0
3030:  BSF    x81.3
3032:  MOVLB  1
....................  
....................   gAdcEnableState |= (1 << port); 
3034:  MOVLW  01
3036:  MOVWF  00
3038:  MOVF   x9B,W
303A:  MOVWF  01
303C:  BZ    3046
303E:  BCF    FD8.0
3040:  RLCF   00,F
3042:  DECFSZ 01,F
3044:  BRA    303E
3046:  MOVF   00,W
3048:  IORWF  x02,F
....................   enableAdcNum++; 
304A:  INCF   x05,F
.................... } 
304C:  MOVLB  0
304E:  GOTO   34A8 (RETURN)
....................  
.................... void disableAdc(int port) 
.................... { 
....................   if(port >= kAdcFilterNumAdcs) 
3052:  MOVLB  1
3054:  MOVF   x9B,W
3056:  SUBLW  06
3058:  BC    305C
....................     return; 
305A:  BRA    3082
....................  
....................   gAdcEnableState &= ~(1 << port); 
305C:  MOVLW  01
305E:  MOVWF  00
3060:  MOVF   x9B,W
3062:  MOVWF  01
3064:  BZ    306E
3066:  BCF    FD8.0
3068:  RLCF   00,F
306A:  DECFSZ 01,F
306C:  BRA    3066
306E:  MOVF   00,W
3070:  XORLW  FF
3072:  ANDWF  x02,F
....................  
....................   if((gAdcEnableState & 0x7F) == 0) 
3074:  MOVF   x02,W
3076:  ANDLW  7F
3078:  BNZ   3080
....................     enableAdcFlag = FALSE; 
307A:  MOVLB  0
307C:  BCF    x81.3
307E:  MOVLB  1
....................   enableAdcNum--; 
3080:  DECF   x05,F
.................... } 
3082:  MOVLB  0
3084:  GOTO   34A8 (RETURN)
....................  
.................... void sendOscMsgAdc(void) 
.................... { 
....................   if(enableAdcFlag) 
*
3974:  BTFSS  x81.3
3976:  BRA    3B8A
....................   { 
....................     if(countAdc >= (8 * enableAdcNum)) 
3978:  MOVLB  1
397A:  MOVF   x05,W
397C:  MULLW  08
397E:  MOVF   FF3,W
3980:  SUBWF  x03,W
3982:  BTFSS  FD8.0
3984:  BRA    3B88
....................     { 
....................       if((gAdcEnableState & (1 << loopAdc)) == (1 << loopAdc)) 
3986:  MOVLW  01
3988:  MOVWF  00
398A:  MOVF   x04,W
398C:  MOVWF  01
398E:  BZ    3998
3990:  BCF    FD8.0
3992:  RLCF   00,F
3994:  DECFSZ 01,F
3996:  BRA    3990
3998:  MOVF   00,W
399A:  ANDWF  x02,W
399C:  MOVWF  x93
399E:  MOVLW  01
39A0:  MOVWF  00
39A2:  MOVF   x04,W
39A4:  MOVWF  01
39A6:  BZ    39B0
39A8:  BCF    FD8.0
39AA:  RLCF   00,F
39AC:  DECFSZ 01,F
39AE:  BRA    39A8
39B0:  MOVF   00,W
39B2:  SUBWF  x93,W
39B4:  BTFSS  FD8.2
39B6:  BRA    3B7C
....................       { 
....................         set_adc_channel(adc_id[loopAdc]); 
39B8:  CLRF   03
39BA:  MOVF   x04,W
39BC:  MOVFF  FF2,193
39C0:  BCF    FF2.7
39C2:  MOVLB  0
39C4:  CALL   1A0E
39C8:  MOVLB  1
39CA:  BTFSC  x93.7
39CC:  BSF    FF2.7
39CE:  MOVWF  x93
39D0:  RLCF   x93,W
39D2:  MOVWF  00
39D4:  RLCF   00,F
39D6:  MOVLW  FC
39D8:  ANDWF  00,F
39DA:  MOVF   FC2,W
39DC:  ANDLW  C3
39DE:  IORWF  00,W
39E0:  MOVWF  FC2
....................         lvalue = read_adc(ADC_START_AND_READ); 
39E2:  BSF    FC2.1
39E4:  BTFSC  FC2.1
39E6:  BRA    39E4
39E8:  MOVFF  FC3,10D
39EC:  MOVFF  FC4,10E
....................         adc_total[loopAdc] += lvalue; 
39F0:  BCF    FD8.0
39F2:  RLCF   x04,W
39F4:  CLRF   03
39F6:  ADDLW  0F
39F8:  MOVWF  FE9
39FA:  MOVLW  01
39FC:  ADDWFC 03,W
39FE:  MOVWF  FEA
3A00:  MOVF   x0D,W
3A02:  ADDWF  FEF,W
3A04:  MOVWF  01
3A06:  MOVF   x0E,W
3A08:  ADDWFC FEC,W
3A0A:  MOVF   FED,F
3A0C:  MOVFF  01,FEF
3A10:  MOVWF  FEC
....................         adc_total[loopAdc] -= adc_value[loopAdc][countAve[loopAdc]]; 
3A12:  BCF    FD8.0
3A14:  RLCF   x04,W
3A16:  CLRF   03
3A18:  ADDLW  0F
3A1A:  MOVWF  01
3A1C:  MOVLW  01
3A1E:  ADDWFC 03,F
3A20:  MOVFF  01,193
3A24:  MOVFF  03,194
3A28:  MOVFF  03,FEA
3A2C:  MOVFF  01,FE9
3A30:  MOVFF  FEC,196
3A34:  MOVF   FED,F
3A36:  MOVFF  FEF,195
3A3A:  MOVF   x04,W
3A3C:  MULLW  10
3A3E:  MOVF   FF3,W
3A40:  CLRF   x98
3A42:  MOVWF  x97
3A44:  CLRF   03
3A46:  MOVF   x04,W
3A48:  ADDLW  06
3A4A:  MOVWF  FE9
3A4C:  MOVLW  01
3A4E:  ADDWFC 03,W
3A50:  MOVWF  FEA
3A52:  BCF    FD8.0
3A54:  RLCF   FEF,W
3A56:  CLRF   03
3A58:  ADDWF  x97,W
3A5A:  MOVWF  01
3A5C:  MOVF   x98,W
3A5E:  ADDWFC 03,F
3A60:  MOVF   01,W
3A62:  ADDLW  1D
3A64:  MOVWF  FE9
3A66:  MOVLW  01
3A68:  ADDWFC 03,W
3A6A:  MOVWF  FEA
3A6C:  MOVFF  FEC,03
3A70:  MOVF   FED,F
3A72:  MOVF   FEF,W
3A74:  SUBWF  x95,W
3A76:  MOVWF  00
3A78:  MOVF   03,W
3A7A:  SUBWFB x96,W
3A7C:  MOVFF  194,FEA
3A80:  MOVFF  193,FE9
3A84:  MOVWF  FEC
3A86:  MOVF   FED,F
3A88:  MOVFF  00,FEF
....................         adc_value[loopAdc][countAve[loopAdc]] = lvalue; 
3A8C:  MOVF   x04,W
3A8E:  MULLW  10
3A90:  MOVF   FF3,W
3A92:  CLRF   x94
3A94:  MOVWF  x93
3A96:  CLRF   03
3A98:  MOVF   x04,W
3A9A:  ADDLW  06
3A9C:  MOVWF  FE9
3A9E:  MOVLW  01
3AA0:  ADDWFC 03,W
3AA2:  MOVWF  FEA
3AA4:  BCF    FD8.0
3AA6:  RLCF   FEF,W
3AA8:  CLRF   03
3AAA:  ADDWF  x93,W
3AAC:  MOVWF  01
3AAE:  MOVF   x94,W
3AB0:  ADDWFC 03,F
3AB2:  MOVF   01,W
3AB4:  ADDLW  1D
3AB6:  MOVWF  FE9
3AB8:  MOVLW  01
3ABA:  ADDWFC 03,W
3ABC:  MOVWF  FEA
3ABE:  MOVFF  10E,FEC
3AC2:  MOVF   FED,F
3AC4:  MOVFF  10D,FEF
....................         lvalue = adc_total[loopAdc] / 8; 
3AC8:  BCF    FD8.0
3ACA:  RLCF   x04,W
3ACC:  CLRF   03
3ACE:  ADDLW  0F
3AD0:  MOVWF  FE9
3AD2:  MOVLW  01
3AD4:  ADDWFC 03,W
3AD6:  MOVWF  FEA
3AD8:  MOVFF  FEC,194
3ADC:  MOVF   FED,F
3ADE:  MOVFF  FEF,193
3AE2:  RRCF   x94,W
3AE4:  MOVWF  x0E
3AE6:  RRCF   x93,W
3AE8:  MOVWF  x0D
3AEA:  RRCF   x0E,F
3AEC:  RRCF   x0D,F
3AEE:  RRCF   x0E,F
3AF0:  RRCF   x0D,F
3AF2:  MOVLW  1F
3AF4:  ANDWF  x0E,F
....................  
....................         countAve[loopAdc]++; 
3AF6:  CLRF   03
3AF8:  MOVF   x04,W
3AFA:  ADDLW  06
3AFC:  MOVWF  FE9
3AFE:  MOVLW  01
3B00:  ADDWFC 03,W
3B02:  MOVWF  FEA
3B04:  INCF   FEF,F
....................         if(countAve[loopAdc] == 8) 
3B06:  CLRF   03
3B08:  MOVF   x04,W
3B0A:  ADDLW  06
3B0C:  MOVWF  FE9
3B0E:  MOVLW  01
3B10:  ADDWFC 03,W
3B12:  MOVWF  FEA
3B14:  MOVF   FEF,W
3B16:  SUBLW  08
3B18:  BNZ   3B2A
....................           countAve[loopAdc] = 0; 
3B1A:  CLRF   03
3B1C:  MOVF   x04,W
3B1E:  ADDLW  06
3B20:  MOVWF  FE9
3B22:  MOVLW  01
3B24:  ADDWFC 03,W
3B26:  MOVWF  FEA
3B28:  CLRF   FEF
....................  
....................         usb_cdc_putc('a'); 
3B2A:  MOVLW  61
3B2C:  MOVWF  x9B
3B2E:  MOVLB  0
3B30:  CALL   30D4
....................         delay_cycles(1); 
3B34:  NOP   
....................         usb_cdc_putc((int)((loopAdc << 4) + ((lvalue & 0x0300) >> 8))); 
3B36:  MOVLB  1
3B38:  SWAPF  x04,W
3B3A:  MOVWF  x93
3B3C:  MOVLW  F0
3B3E:  ANDWF  x93,F
3B40:  CLRF   x94
3B42:  MOVF   x0E,W
3B44:  ANDLW  03
3B46:  MOVWF  x95
3B48:  CLRF   03
3B4A:  ADDWF  x93,W
3B4C:  MOVWF  01
3B4E:  MOVLW  00
3B50:  ADDWFC 03,F
3B52:  MOVFF  01,193
3B56:  MOVFF  01,19B
3B5A:  MOVLB  0
3B5C:  CALL   30D4
....................         delay_cycles(1); 
3B60:  NOP   
....................         usb_cdc_putc((int)(lvalue & 0x00FF)); 
3B62:  MOVLB  1
3B64:  MOVFF  10D,00
3B68:  CLRF   03
3B6A:  MOVFF  10D,193
3B6E:  MOVFF  10D,19B
3B72:  MOVLB  0
3B74:  CALL   30D4
....................         delay_cycles(1); 
3B78:  NOP   
3B7A:  MOVLB  1
....................       } 
....................       loopAdc++; 
3B7C:  INCF   x04,F
....................       if(loopAdc >= kAdcFilterNumAdcs) 
3B7E:  MOVF   x04,W
3B80:  SUBLW  06
3B82:  BC    3B86
....................         loopAdc = 0; 
3B84:  CLRF   x04
....................  
....................       countAdc = 0; 
3B86:  CLRF   x03
....................     } 
....................     countAdc++; 
3B88:  INCF   x03,F
3B8A:  MOVLB  0
....................   } 
.................... } 
3B8C:  GOTO   3D10 (RETURN)
....................  
.................... /**********************************/ 
.................... /*                                */ 
.................... /*  Functions for Input Handling  */ 
.................... /*                                */ 
.................... /**********************************/ 
.................... void inputInit(void) 
.................... { 
....................   inCurrent = 0x00; 
*
284E:  MOVLB  1
2850:  CLRF   x8D
....................   inLast    = 0x00; 
2852:  CLRF   x8E
....................   inState   = 0x00; 
2854:  CLRF   x8F
....................  
....................   for(i = 0; i < 2; i++) 
2856:  MOVLB  0
2858:  CLRF   x88
285A:  MOVF   x88,W
285C:  SUBLW  01
285E:  BNC   2874
....................     inDebounceCount[i] = 0; 
2860:  CLRF   03
2862:  MOVF   x88,W
2864:  ADDLW  90
2866:  MOVWF  FE9
2868:  MOVLW  01
286A:  ADDWFC 03,W
286C:  MOVWF  FEA
286E:  CLRF   FEF
2870:  INCF   x88,F
2872:  BRA    285A
.................... } 
2874:  GOTO   3CEE (RETURN)
....................  
.................... short inputCheck(int index) 
.................... { 
....................   flag = FALSE; 
....................  
....................   if(((inCurrent ^ inLast) & (1 << index)) && ((inCurrent ^ inState) & (1 << index))) 
....................     inDebounceCount[index] = 0; 
....................   else if (((inCurrent ^ inLast) & (1 << index)) == 0 && ((inCurrent ^ inState) & (1 << index))) 
....................   { 
....................     if(inDebounceCount[index] < 32 && ++inDebounceCount[index] == 32) 
....................     { 
....................       if(inCurrent & (1 << index)) 
....................         inState |= (1 << index); 
....................       else 
....................         inState &= ~(1 << index); 
....................       flag = TRUE; 
....................     } 
....................   } 
....................   return flag; 
.................... } 
....................  
.................... /* 
.................... void sendOscMsgInput(void) 
.................... { 
....................   inLast = inCurrent; 
....................  
....................   for(j = 0; j < 2; j++) 
....................   { 
....................     if(j == 0) 
....................       k = input(PIN_B4); 
....................     else if(j == 1) 
....................       k = input(PIN_B0); 
....................  
....................     if(k == 0) 
....................       inCurrent |= (1 << j); 
....................     else 
....................       inCurrent &= ~(1 << j); 
....................        
....................     if(inputCheck(j)) 
....................       printf(usb_cdc_putc, "input %d %d\r", j, ((inState & (1 << j)) ? 1 : 0)); 
....................   } 
.................... } 
.................... */ 
....................  
.................... /***********************************/ 
.................... /*                                 */ 
.................... /*      Functions for EEPROM       */ 
.................... /*                                 */ 
.................... /***********************************/ 
.................... void initAndSaveParaToEeprom(void) 
.................... { 
....................   para.intensity = 0x0F; 
*
27BA:  MOVLW  0F
27BC:  MOVLB  1
27BE:  MOVWF  x92
....................   putParaToEeprom(&para, sizeof(para), 0); 
27C0:  MOVLW  01
27C2:  MOVWF  x9C
27C4:  MOVLW  92
27C6:  MOVWF  x9B
27C8:  MOVLW  01
27CA:  MOVWF  x9D
27CC:  CLRF   x9E
27CE:  MOVLB  0
27D0:  RCALL  2764
.................... } 
27D2:  GOTO   3CBC (RETURN)
....................  
.................... void getParaFromEeprom(int *ptr, int num, int addr) 
.................... { 
....................   int count; 
....................   for(count = 0; count < num; count++) 
*
2724:  MOVLB  1
2726:  CLRF   x97
2728:  MOVF   x95,W
272A:  SUBWF  x97,W
272C:  BC    275E
....................     ptr[count] = read_eeprom(addr + count); 
272E:  CLRF   03
2730:  MOVF   x97,W
2732:  ADDWF  x93,W
2734:  MOVWF  FE9
2736:  MOVF   x94,W
2738:  ADDWFC 03,W
273A:  MOVWF  FEA
273C:  MOVF   x97,W
273E:  ADDWF  x96,W
2740:  MOVWF  x9A
2742:  MOVFF  FF2,19B
2746:  BCF    FF2.7
2748:  MOVFF  19A,FA9
274C:  BCF    FA6.6
274E:  BCF    FA6.7
2750:  BSF    FA6.0
2752:  MOVF   FA8,W
2754:  BTFSC  x9B.7
2756:  BSF    FF2.7
2758:  MOVWF  FEF
275A:  INCF   x97,F
275C:  BRA    2728
.................... } 
275E:  MOVLB  0
2760:  GOTO   3CB0 (RETURN)
....................  
.................... void putParaToEeprom(int *ptr,int num,int addr) 
.................... { 
....................   int count; 
....................   for(count = 0; count < num; count++) 
2764:  MOVLB  1
2766:  CLRF   x9F
2768:  MOVF   x9D,W
276A:  SUBWF  x9F,W
276C:  BC    27B6
....................     write_eeprom(addr + count, ptr[count]); 
276E:  MOVF   x9F,W
2770:  ADDWF  x9E,W
2772:  MOVWF  xA0
2774:  CLRF   03
2776:  MOVF   x9F,W
2778:  ADDWF  x9B,W
277A:  MOVWF  FE9
277C:  MOVF   x9C,W
277E:  ADDWFC 03,W
2780:  MOVWF  FEA
2782:  MOVFF  FEF,1A1
2786:  MOVFF  1A0,FA9
278A:  MOVFF  1A1,FA8
278E:  BCF    FA6.6
2790:  BCF    FA6.7
2792:  BSF    FA6.2
2794:  MOVFF  FF2,00
2798:  BCF    FF2.7
279A:  MOVLB  F
279C:  MOVLW  55
279E:  MOVWF  FA7
27A0:  MOVLW  AA
27A2:  MOVWF  FA7
27A4:  BSF    FA6.1
27A6:  BTFSC  FA6.1
27A8:  BRA    27A6
27AA:  BCF    FA6.2
27AC:  MOVF   00,W
27AE:  IORWF  FF2,F
27B0:  MOVLB  1
27B2:  INCF   x9F,F
27B4:  BRA    2768
.................... } 
27B6:  MOVLB  0
27B8:  RETLW  00
....................  
.................... int my_atoi(char s) 
.................... { 
....................   int result = 0; 
*
2C36:  MOVLB  1
2C38:  CLRF   x9C
....................  
....................   if (s >= '0' && s <= '9') 
2C3A:  MOVF   x9B,W
2C3C:  SUBLW  2F
2C3E:  BC    2C58
2C40:  MOVF   x9B,W
2C42:  SUBLW  39
2C44:  BNC   2C58
....................     result = (result << 4) + (s - '0'); 
2C46:  SWAPF  x9C,W
2C48:  MOVWF  x9D
2C4A:  MOVLW  F0
2C4C:  ANDWF  x9D,F
2C4E:  MOVLW  30
2C50:  SUBWF  x9B,W
2C52:  ADDWF  x9D,W
2C54:  MOVWF  x9C
....................   else 
2C56:  BRA    2C6A
....................     result = (result << 4) + (s - 'A' + 10); 
2C58:  SWAPF  x9C,W
2C5A:  MOVWF  x9D
2C5C:  MOVLW  F0
2C5E:  ANDWF  x9D,F
2C60:  MOVLW  41
2C62:  SUBWF  x9B,W
2C64:  ADDLW  0A
2C66:  ADDWF  x9D,W
2C68:  MOVWF  x9C
....................   return result; 
2C6A:  MOVFF  19C,01
.................... } 
2C6E:  MOVLB  0
2C70:  RETLW  00
....................  
.................... void my_get_string_usb(char* s, int max) 
.................... { 
....................   int len = 0; 
*
2BE4:  MOVLB  1
2BE6:  CLRF   x9E
....................   char c; 
....................  
....................   --max; 
2BE8:  DECF   x9D,F
....................   do { 
....................     c = usb_cdc_getc(); 
2BEA:  MOVLB  0
2BEC:  BRA    2B98
2BEE:  MOVFF  01,19F
....................     if(c >= ' ' && c <= '~') 
2BF2:  MOVLB  1
2BF4:  MOVF   x9F,W
2BF6:  SUBLW  1F
2BF8:  BC    2C1A
2BFA:  MOVF   x9F,W
2BFC:  SUBLW  7E
2BFE:  BNC   2C1A
....................       if(len < max) 
2C00:  MOVF   x9D,W
2C02:  SUBWF  x9E,W
2C04:  BC    2C1A
....................         s[len++] = c; 
2C06:  MOVF   x9E,W
2C08:  INCF   x9E,F
2C0A:  CLRF   03
2C0C:  ADDWF  x9B,W
2C0E:  MOVWF  FE9
2C10:  MOVF   x9C,W
2C12:  ADDWFC 03,W
2C14:  MOVWF  FEA
2C16:  MOVFF  19F,FEF
....................   } while(c != 13); 
2C1A:  MOVF   x9F,W
2C1C:  SUBLW  0D
2C1E:  BNZ   2BEA
....................   s[len] = 0; 
2C20:  CLRF   03
2C22:  MOVF   x9E,W
2C24:  ADDWF  x9B,W
2C26:  MOVWF  FE9
2C28:  MOVF   x9C,W
2C2A:  ADDWFC 03,W
2C2C:  MOVWF  FEA
2C2E:  CLRF   FEF
.................... } 
2C30:  MOVLB  0
2C32:  GOTO   310C (RETURN)

Configuration Fuses:
   Word  1: 0E24   NOIESO NOFCMEN HSPLL PLL5 CPUDIV1 USBDIV
   Word  2: 0E39   NOBROWNOUT WDT128 NOWDT BORV20 NOPUT VREGEN
   Word  3: 0500   NOPBADEN CCP2C1 NOMCLR LPT1OSC
   Word  4: 0080   NOSTVREN NODEBUG NOLVP NOXINST
   Word  5: C00F   NOPROTECT NOCPD NOCPB
   Word  6: E00F   NOWRT NOWRTD NOWRTC NOWRTB
   Word  7: 400F   NOEBTR NOEBTRB
